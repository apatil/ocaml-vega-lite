(* Generated by gen/gen.ml *)

module V2 = struct
module rec
VlOnlyGuideConfig:sig type t = bool val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = bool

  (** Fields
  
    shortTimeLabels:
      Whether month names and weekday names should be abbreviated.
      
      __Default value:__  `false`
  *)
  let to_yojson x =
    `Assoc
      [("shortTimeLabels",
(((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) x))]       
end
and
ViewConfig:sig
  type nonrec t =
    {
    width: [ `Int of int  | `Float of float ] option ;
    strokeWidth: [ `Int of int  | `Float of float ] option ;
    strokeOpacity: [ `Int of int  | `Float of float ] option ;
    strokeDashOffset: [ `Int of int  | `Float of float ] option ;
    strokeDash: [ `Int of int  | `Float of float ] list option ;
    stroke: string option ;
    height: [ `Int of int  | `Float of float ] option ;
    fillOpacity: [ `Int of int  | `Float of float ] option ;
    fill: string option ;
    clip: bool option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?clip:bool ->
      ?fill:string ->
        ?fillOpacity:[ `Int of int  | `Float of float ] ->
          ?height:[ `Int of int  | `Float of float ] ->
            ?stroke:string ->
              ?strokeDash:[ `Int of int  | `Float of float ]
                list ->
                ?strokeDashOffset:[ `Int of int 
                                  | `Float of float ]
                  ->
                  ?strokeOpacity:[ `Int of int 
                                 | `Float of float ]
                    ->
                    ?strokeWidth:[ `Int of int 
                                 | `Float of float ]
                      ->
                      ?width:[ `Int of int  | `Float of float ]
                        -> unit -> t
  val withClip : bool -> t -> t
  val withFill : string -> t -> t
  val withFillOpacity :
    [ `Int of int  | `Float of float ] -> t -> t
  val withHeight : [ `Int of int  | `Float of float ] -> t -> t
  val withStroke : string -> t -> t
  val withStrokeDash :
    [ `Int of int  | `Float of float ] list -> t -> t
  val withStrokeDashOffset :
    [ `Int of int  | `Float of float ] -> t -> t
  val withStrokeOpacity :
    [ `Int of int  | `Float of float ] -> t -> t
  val withStrokeWidth :
    [ `Int of int  | `Float of float ] -> t -> t
  val withWidth : [ `Int of int  | `Float of float ] -> t -> t
end =
struct
  type nonrec t =
    {
    width: [ `Int of int  | `Float of float ] option ;
    strokeWidth: [ `Int of int  | `Float of float ] option ;
    strokeOpacity: [ `Int of int  | `Float of float ] option ;
    strokeDashOffset: [ `Int of int  | `Float of float ] option ;
    strokeDash: [ `Int of int  | `Float of float ] list option ;
    stroke: string option ;
    height: [ `Int of int  | `Float of float ] option ;
    fillOpacity: [ `Int of int  | `Float of float ] option ;
    fill: string option ;
    clip: bool option }

  (** Fields
  
    width:
      The default width of the single plot or each plot in a trellis plot when the visualization has a continuous (non-ordinal) x-scale or ordinal x-scale with `rangeStep` = `null`.
      
      __Default value:__ `200`
  
    strokeWidth:
      The stroke width, in pixels.
      
      __Default value:__ (none)
  
    strokeOpacity:
      The stroke opacity (value between [0,1]).
      
      __Default value:__ (none)
  
    strokeDashOffset:
      The offset (in pixels) into which to begin drawing with the stroke dash array.
      
      __Default value:__ (none)
  
    strokeDash:
      An array of alternating stroke, space lengths for creating dashed or dotted lines.
      
      __Default value:__ (none)
  
    stroke:
      The stroke color.
      
      __Default value:__ (none)
  
    height:
      The default height of the single plot or each plot in a trellis plot when the visualization has a continuous (non-ordinal) y-scale with `rangeStep` = `null`.
      
      __Default value:__ `200`
  
    fillOpacity:
      The fill opacity (value between [0,1]).
      
      __Default value:__ (none)
  
    fill:
      The fill color.
      
      __Default value:__ (none)
  
    clip:
      Whether the view should be clipped.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("clip",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) v))
               x.clip));
         ("fill",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  -> (`String s : Yojson.Safe.json))) v))
              x.fill));
         ("fillOpacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.fillOpacity));
         ("height",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.height));
         ("stroke",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  -> (`String s : Yojson.Safe.json))) v))
              x.stroke));
         ("strokeDash",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : [ `Int of int  | `Float of float ] list)  ->
                      let yojson_of_el =
                        function | `Int i -> `Int i | `Float f -> `Float f
                         in
                      (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
                    v)) x.strokeDash));
         ("strokeDashOffset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.strokeDashOffset));
         ("strokeOpacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.strokeOpacity));
         ("strokeWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.strokeWidth));
         ("width",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
x.width))])       
  let make ?clip  ?fill  ?fillOpacity  ?height  ?stroke  ?strokeDash 
    ?strokeDashOffset  ?strokeOpacity  ?strokeWidth  ?width  () =
    {
      width;
      strokeWidth;
      strokeOpacity;
      strokeDashOffset;
      strokeDash;
      stroke;
      height;
      fillOpacity;
      fill;
      clip
    } 
  let withClip v x = { x with clip = (Some v) } 
  let withFill v x = { x with fill = (Some v) } 
  let withFillOpacity v x = { x with fillOpacity = (Some v) } 
  let withHeight v x = { x with height = (Some v) } 
  let withStroke v x = { x with stroke = (Some v) } 
  let withStrokeDash v x = { x with strokeDash = (Some v) } 
  let withStrokeDashOffset v x = { x with strokeDashOffset = (Some v) } 
  let withStrokeOpacity v x = { x with strokeOpacity = (Some v) } 
  let withStrokeWidth v x = { x with strokeWidth = (Some v) } 
  let withWidth v x = { x with width = (Some v) } 
end and
VgTitleConfig:sig
  type nonrec t =
    {
    orient: TitleOrient.t option ;
    offset: [ `Int of int  | `Float of float ] option ;
    limit: [ `Int of int  | `Float of float ] option ;
    fontWeight:
      [ `FontWeight of FontWeight.t 
      | `Num of FontWeightNumber.t ] option ;
    fontSize: [ `Int of int  | `Float of float ] option ;
    font: string option ;
    color: string option ;
    baseline: VerticalAlign.t option ;
    angle: [ `Int of int  | `Float of float ] option ;
    anchor: Anchor.t option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?anchor:Anchor.t ->
      ?angle:[ `Int of int  | `Float of float ] ->
        ?baseline:VerticalAlign.t ->
          ?color:string ->
            ?font:string ->
              ?fontSize:[ `Int of int 
                        | `Float of float ]
                ->
                ?fontWeight:[
                              `FontWeight of
FontWeight.t 
                            | `Num of FontWeightNumber.t ]
                  ->
                  ?limit:[ `Int of int 
                         | `Float of float ]
                    ->
                    ?offset:[ `Int of int 
                            | `Float of float ]
                      ->
                      ?orient:TitleOrient.t -> unit -> t
  val withAnchor : Anchor.t -> t -> t
  val withAngle :
    [ `Int of int  | `Float of float ] -> t -> t
  val withBaseline : VerticalAlign.t -> t -> t
  val withColor : string -> t -> t
  val withFont : string -> t -> t
  val withFontSize :
    [ `Int of int  | `Float of float ] -> t -> t
  val withFontWeight :
    [ `FontWeight of FontWeight.t 
    | `Num of FontWeightNumber.t ] -> t -> t
  val withLimit :
    [ `Int of int  | `Float of float ] -> t -> t
  val withOffset :
    [ `Int of int  | `Float of float ] -> t -> t
  val withOrient : TitleOrient.t -> t -> t
end =
struct
  type nonrec t =
    {
    orient: TitleOrient.t option ;
    offset: [ `Int of int  | `Float of float ] option ;
    limit: [ `Int of int  | `Float of float ] option ;
    fontWeight:
      [ `FontWeight of FontWeight.t  | `Num of FontWeightNumber.t ]
        option
      ;
    fontSize: [ `Int of int  | `Float of float ] option ;
    font: string option ;
    color: string option ;
    baseline: VerticalAlign.t option ;
    angle: [ `Int of int  | `Float of float ] option ;
    anchor: Anchor.t option }

  (** Fields
  
    orient:
      Default title orientation ("top", "bottom", "left", or "right")
  
    offset:
      Offset in pixels of the title from the chart body and axes.
  
    limit:
      The maximum allowed length in pixels of legend labels.
  
    fontWeight:
      Font weight for title text.
  
    fontSize:
      Font size in pixels for title text.
      
      __Default value:__ `10`.
  
    font:
      Font name for title text.
  
    color:
      Text color for title text.
  
    baseline:
      Vertical text baseline for title text.
  
    angle:
      Angle in degrees of title text.
  
    anchor:
      The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.
      
      __Default value:__ `"middle"` for [single](spec.html) and [layered](layer.html) views.
      `"start"` for other composite views.
      
      __Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only customizable only for [single](spec.html) and [layered](layer.html) views.  For other composite views, `anchor` is always `"start"`.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("anchor",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : Anchor.t)  ->
                       (Anchor.to_yojson x : Yojson.Safe.json))) v))
               x.anchor));
         ("angle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f))
                    v)) x.angle));
         ("baseline",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : VerticalAlign.t)  ->
                      (VerticalAlign.to_yojson x : Yojson.Safe.json)))
                    v)) x.baseline));
         ("color",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v)) x.color));
         ("font",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v)) x.font));
         ("fontSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f))
                    v)) x.fontSize));
         ("fontWeight",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Num v ->
                        ((fun (x : FontWeightNumber.t)  ->
                            (FontWeightNumber.to_yojson x : Yojson.Safe.json)))
                          v
                    | `FontWeight v ->
                        ((fun (x : FontWeight.t)  ->
                            (FontWeight.to_yojson x : Yojson.Safe.json)))
                          v)) v)) x.fontWeight));
         ("limit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f))
                    v)) x.limit));
         ("offset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f))
                    v)) x.offset));
         ("orient",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : TitleOrient.t)  ->
                      (TitleOrient.to_yojson x : Yojson.Safe.json))) v))
x.orient))])            
  let make ?anchor  ?angle  ?baseline  ?color  ?font  ?fontSize 
    ?fontWeight  ?limit  ?offset  ?orient  () =
    {
      orient;
      offset;
      limit;
      fontWeight;
      fontSize;
      font;
      color;
      baseline;
      angle;
      anchor
    } 
  let withAnchor v x = { x with anchor = (Some v) } 
  let withAngle v x = { x with angle = (Some v) } 
  let withBaseline v x = { x with baseline = (Some v) } 
  let withColor v x = { x with color = (Some v) } 
  let withFont v x = { x with font = (Some v) } 
  let withFontSize v x = { x with fontSize = (Some v) } 
  let withFontWeight v x = { x with fontWeight = (Some v) } 
  let withLimit v x = { x with limit = (Some v) } 
  let withOffset v x = { x with offset = (Some v) } 
  let withOrient v x = { x with orient = (Some v) } 
end and
VgSelectBinding:sig
  type nonrec t =
    {
    options: string list ;
    input: [ `Select ] ;
    element: string option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?element:string ->
      input:[ `Select ] ->
        options:string list -> unit -> t
  val withElement : string -> t -> t
  val withInput : [ `Select ] -> t -> t
  val withOptions : string list -> t -> t
end =
struct
  type nonrec t =
    {
    options: string list ;
    input: [ `Select ] ;
    element: string option }

  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("element",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (s : string)  ->
                       (`String s : Yojson.Safe.json))) v))
               x.element));
         ("input",
           (((function | `Select -> `String "select")) x.input));
         ("options",
           (((fun (l : string list)  ->
                let yojson_of_el (s : string) =
                  (`String s : Yojson.Safe.json)  in
                (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
x.options))])                 
  let make ?element  ~input  ~options  () =
    { options; input; element } 
  let withElement v x = { x with element = (Some v) } 
  let withInput v x = { x with input = v } 
  let withOptions v x = { x with options = v } 
end and
VgScheme:sig
  type nonrec t =
    {
    scheme: string ;
    extent:
      [ `Int of int  | `Float of float ] list
        option
      ;
    count:
      [ `Int of int  | `Float of float ] option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?count:[ `Int of int  | `Float of float ] ->
      ?extent:[ `Int of int  | `Float of float ]
        list -> scheme:string -> unit -> t
  val withCount :
    [ `Int of int  | `Float of float ] -> t -> t
  val withExtent :
    [ `Int of int  | `Float of float ] list ->
      t -> t
  val withScheme : string -> t -> t
end =
struct
  type nonrec t =
    {
    scheme: string ;
    extent: [ `Int of int  | `Float of float ] list option ;
    count: [ `Int of int  | `Float of float ] option }

  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("count",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function
                     | `Int i -> `Int i
                     | `Float f -> `Float f)) v)) x.count));
         ("extent",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (l :
                        [ `Int of int  | `Float of float ]
                          list)
                       ->
                      let yojson_of_el =
                        function
                        | `Int i -> `Int i
                        | `Float f -> `Float f  in
                      (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v)) x.extent));
         ("scheme",
           (((fun (s : string)  ->
(`String s : Yojson.Safe.json))) x.scheme))])                      
  let make ?count  ?extent  ~scheme  () =
    { scheme; extent; count } 
  let withCount v x = { x with count = (Some v) } 
  let withExtent v x = { x with extent = (Some v) } 
  let withScheme v x = { x with scheme = v } 
end and
VgRangeBinding:sig
  type nonrec t =
    {
    step:
      [ `Int of int  | `Float of float ]
        option
      ;
    min:
      [ `Int of int  | `Float of float ]
        option
      ;
    max:
      [ `Int of int  | `Float of float ]
        option
      ;
    input: [ `Range ] ;
    element: string option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?element:string ->
      ?max:[ `Int of int 
           | `Float of float ]
        ->
        ?min:[ `Int of int 
             | `Float of float ]
          ->
          ?step:[ `Int of int 
                | `Float of float ]
            ->
            input:[ `Range ] ->
              unit -> t
  val withElement : string -> t -> t
  val withInput : [ `Range ] -> t -> t
  val withMax :
    [ `Int of int  | `Float of float ]
      -> t -> t
  val withMin :
    [ `Int of int  | `Float of float ]
      -> t -> t
  val withStep :
    [ `Int of int  | `Float of float ]
      -> t -> t
end =
struct
  type nonrec t =
    {
    step: [ `Int of int  | `Float of float ] option ;
    min: [ `Int of int  | `Float of float ] option ;
    max: [ `Int of int  | `Float of float ] option ;
    input: [ `Range ] ;
    element: string option }

  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("element",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (s : string)  ->
                       (`String s : Yojson.Safe.json)))
                     v)) x.element));
         ("input",
           (((function | `Range -> `String "range"))
              x.input));
         ("max",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v)) x.max));
         ("min",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v)) x.min));
         ("step",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
| `Float f -> `Float f)) v)) x.step))])                           
  let make ?element  ?max  ?min  ?step  ~input  () =
    { input; step; min; max; element } 
  let withElement v x = { x with element = (Some v) } 
  let withInput v x = { x with input = v } 
  let withMax v x = { x with max = (Some v) } 
  let withMin v x = { x with min = (Some v) } 
  let withStep v x = { x with step = (Some v) } 
end and
VgRadioBinding:sig
  type nonrec t =
    {
    options: string list ;
    input: [ `Radio ] ;
    element: string option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?element:string ->
      input:[ `Radio ] ->
        options:string list ->
          unit -> t
  val withElement :
    string -> t -> t
  val withInput :
    [ `Radio ] -> t -> t
  val withOptions :
    string list -> t -> t
end =
struct
  type nonrec t =
    {
    options: string list ;
    input: [ `Radio ] ;
    element: string option }

  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("element",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (s : string)  ->
                       (`String s : Yojson.Safe.json)))
                     v)) x.element));
         ("input",
           (((function | `Radio -> `String "radio"))
              x.input));
         ("options",
           (((fun (l : string list)  ->
                let yojson_of_el (s : string) =
                  (`String s : Yojson.Safe.json)
                   in
                (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) x.options))])                                
  let make ?element  ~input  ~options  () =
    { options; input; element } 
  let withElement v x =
    { x with element = (Some v) } 
  let withInput v x = { x with input = v } 
  let withOptions v x = { x with options = v } 
end and
VgMarkConfig:sig
  type nonrec t =
    {
    theta:
      [ `Int of int 
      | `Float of float ] option ;
    text: string option ;
    tension:
      [ `Int of int 
      | `Float of float ] option ;
    strokeWidth:
      [ `Int of int 
      | `Float of float ] option ;
    strokeOpacity:
      [ `Int of int 
      | `Float of float ] option ;
    strokeDashOffset:
      [ `Int of int 
      | `Float of float ] option ;
    strokeDash:
      [ `Int of int 
      | `Float of float ] list
        option
      ;
    stroke: string option ;
    size:
      [ `Int of int 
      | `Float of float ] option ;
    shape: string option ;
    radius:
      [ `Int of int 
      | `Float of float ] option ;
    orient: Orient.t option ;
    opacity:
      [ `Int of int 
      | `Float of float ] option ;
    limit:
      [ `Int of int 
      | `Float of float ] option ;
    interpolate:
Interpolate.t option ;
    fontWeight:
      [
        `FontWeight of
FontWeight.t 
      | `Num of
FontWeightNumber.t ]
        option
      ;
    fontStyle:
FontStyle.t option ;
    fontSize:
      [ `Int of int 
      | `Float of float ] option ;
    font: string option ;
    fillOpacity:
      [ `Int of int 
      | `Float of float ] option ;
    fill: string option ;
    dy:
      [ `Int of int 
      | `Float of float ] option ;
    dx:
      [ `Int of int 
      | `Float of float ] option ;
    baseline:
VerticalAlign.t option ;
    angle:
      [ `Int of int 
      | `Float of float ] option ;
    align:
HorizontalAlign.t option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?align:HorizontalAlign.t ->
      ?angle:[ `Int of int 
             | `Float of float ]
        ->
        ?baseline:VerticalAlign.t
          ->
          ?dx:[ `Int of int 
              | `Float of float ]
            ->
            ?dy:[ `Int of int 
                | `Float of
                    float ]
              ->
              ?fill:string ->
                ?fillOpacity:
                  [ `Int of int 
                  | `Float of
                      float ]
                  ->
                  ?font:string
                    ->
                    ?fontSize:
                      [
                       `Int of
                       int 
                      | `Float
                       of float ]
                      ->
                      ?fontStyle:FontStyle.t
                       ->
                       ?fontWeight:
                       [
                       `FontWeight
                       of
FontWeight.t
                        | 
                       `Num of
FontWeightNumber.t
                       ] ->
                       ?interpolate:Interpolate.t
                       ->
                       ?limit:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?opacity:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?orient:Orient.t
                       ->
                       ?radius:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?shape:string
                       ->
                       ?size:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?stroke:string
                       ->
                       ?strokeDash:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       list ->
                       ?strokeDashOffset:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?strokeOpacity:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?strokeWidth:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?tension:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?text:string
                       ->
                       ?theta:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       unit -> t
  val withAlign :
HorizontalAlign.t -> t -> t
  val withAngle :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withBaseline :
VerticalAlign.t -> t -> t
  val withDx :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withDy :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withFill :
    string -> t -> t
  val withFillOpacity :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withFont :
    string -> t -> t
  val withFontSize :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withFontStyle :
FontStyle.t -> t -> t
  val withFontWeight :
    [
      `FontWeight of
FontWeight.t 
    | `Num of FontWeightNumber.t ]
      -> t -> t
  val withInterpolate :
Interpolate.t -> t -> t
  val withLimit :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withOpacity :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withOrient :
Orient.t -> t -> t
  val withRadius :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withShape :
    string -> t -> t
  val withSize :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withStroke :
    string -> t -> t
  val withStrokeDash :
    [ `Int of int 
    | `Float of float ] list ->
      t -> t
  val withStrokeDashOffset :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withStrokeOpacity :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withStrokeWidth :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withTension :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withText :
    string -> t -> t
  val withTheta :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
end =
struct
  type nonrec t =
    {
    theta:
      [ `Int of int  | `Float of float ]
        option
      ;
    text: string option ;
    tension:
      [ `Int of int  | `Float of float ]
        option
      ;
    strokeWidth:
      [ `Int of int  | `Float of float ]
        option
      ;
    strokeOpacity:
      [ `Int of int  | `Float of float ]
        option
      ;
    strokeDashOffset:
      [ `Int of int  | `Float of float ]
        option
      ;
    strokeDash:
      [ `Int of int  | `Float of float ] list
        option
      ;
    stroke: string option ;
    size:
      [ `Int of int  | `Float of float ]
        option
      ;
    shape: string option ;
    radius:
      [ `Int of int  | `Float of float ]
        option
      ;
    orient: Orient.t option ;
    opacity:
      [ `Int of int  | `Float of float ]
        option
      ;
    limit:
      [ `Int of int  | `Float of float ]
        option
      ;
    interpolate: Interpolate.t option ;
    fontWeight:
      [ `FontWeight of FontWeight.t 
      | `Num of FontWeightNumber.t ] option ;
    fontStyle: FontStyle.t option ;
    fontSize:
      [ `Int of int  | `Float of float ]
        option
      ;
    font: string option ;
    fillOpacity:
      [ `Int of int  | `Float of float ]
        option
      ;
    fill: string option ;
    dy:
      [ `Int of int  | `Float of float ]
        option
      ;
    dx:
      [ `Int of int  | `Float of float ]
        option
      ;
    baseline: VerticalAlign.t option ;
    angle:
      [ `Int of int  | `Float of float ]
        option
      ;
    align: HorizontalAlign.t option }

  (** Fields
  
    theta:
      Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating "north".
  
    text:
      Placeholder text if the `text` channel is not specified
  
    tension:
      Depending on the interpolation type, sets the tension parameter (for line and area marks).
  
    strokeWidth:
      The stroke width, in pixels.
  
    strokeOpacity:
      The stroke opacity (value between [0,1]).
      
      __Default value:__ `1`
  
    strokeDashOffset:
      The offset (in pixels) into which to begin drawing with the stroke dash array.
  
    strokeDash:
      An array of alternating stroke, space lengths for creating dashed or dotted lines.
  
    stroke:
      Default Stroke Color.  This has higher precedence than config.color
      
      __Default value:__ (None)
  
    size:
      The pixel area each the point/circle/square.
      For example: in the case of circles, the radius is determined in part by the square root of the size value.
      
      __Default value:__ `30`
  
    shape:
      The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
      
      __Default value:__ `"circle"`
  
    radius:
      Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.
  
    orient:
      The orientation of a non-stacked bar, tick, area, and line charts.
      The value is either horizontal (default) or vertical.
      - For bar, rule and tick, this determines whether the size of the bar and tick
      should be applied to x or y dimension.
      - For area, this property determines the orient property of the Vega output.
      - For line, this property determines the sort order of the points in the line
      if `config.sortLineBy` is not specified.
      For stacked charts, this is always determined by the orientation of the stack;
      therefore explicitly specified value will be ignored.
  
    opacity:
      The overall opacity (value between [0,1]).
      
      __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
  
    limit:
      The maximum length of the text mark in pixels (default 0, indicating no limit). The text value will be automatically truncated if the rendered size exceeds the limit.
  
    interpolate:
      The line interpolation method to use for line and area marks. One of the following:
      - `"linear"`: piecewise linear segments, as in a polyline.
      - `"linear-closed"`: close the linear segments to form a polygon.
      - `"step"`: alternate between horizontal and vertical segments, as in a step function.
      - `"step-before"`: alternate between vertical and horizontal segments, as in a step function.
      - `"step-after"`: alternate between horizontal and vertical segments, as in a step function.
      - `"basis"`: a B-spline, with control point duplication on the ends.
      - `"basis-open"`: an open B-spline; may not intersect the start or end.
      - `"basis-closed"`: a closed B-spline, as in a loop.
      - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
      - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
      - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
      - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the spline.
      - `"monotone"`: cubic interpolation that preserves monotonicity in y.
  
    fontWeight:
      The font weight (e.g., `"bold"`).
  
    fontStyle:
      The font style (e.g., `"italic"`).
  
    fontSize:
      The font size, in pixels.
  
    font:
      The typeface to set the text in (e.g., `"Helvetica Neue"`).
  
    fillOpacity:
      The fill opacity (value between [0,1]).
      
      __Default value:__ `1`
  
    fill:
      Default Fill Color.  This has higher precedence than config.color
      
      __Default value:__ (None)
  
    dy:
      The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.
  
    dx:
      The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.
  
    baseline:
      The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
      
      __Default value:__ `"middle"`
  
    angle:
      The rotation angle of the text, in degrees.
  
    align:
      The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("align",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun
                       (x :
HorizontalAlign.t)
                        ->
                       (HorizontalAlign.to_yojson
                          x : Yojson.Safe.json)))
                     v)) x.align));
         ("angle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.angle));
         ("baseline",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : VerticalAlign.t)
                       ->
                      (VerticalAlign.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.baseline));
         ("dx",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.dx));
         ("dy",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.dy));
         ("fill",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.fill));
         ("fillOpacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.fillOpacity));
         ("font",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.font));
         ("fontSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.fontSize));
         ("fontStyle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : FontStyle.t)  ->
                      (FontStyle.to_yojson x : 
Yojson.Safe.json))) v))
              x.fontStyle));
         ("fontWeight",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Num v ->
                        ((fun
                            (x :
FontWeightNumber.t)
                             ->
                            (FontWeightNumber.to_yojson
                               x : Yojson.Safe.json)))
                          v
                    | `FontWeight v ->
                        ((fun
                            (x :
FontWeight.t)
                             ->
                            (FontWeight.to_yojson
                               x : Yojson.Safe.json)))
                          v)) v))
              x.fontWeight));
         ("interpolate",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Interpolate.t) 
                      ->
                      (Interpolate.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.interpolate));
         ("limit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.limit));
         ("opacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.opacity));
         ("orient",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Orient.t)  ->
                      (Orient.to_yojson x : 
Yojson.Safe.json))) v))
              x.orient));
         ("radius",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.radius));
         ("shape",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.shape));
         ("size",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.size));
         ("stroke",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.stroke));
         ("strokeDash",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (l :
                        [ `Int of int 
                        | `Float of float ]
                          list)
                       ->
                      let yojson_of_el =
                        function
                        | `Int i -> `Int i
                        | `Float f ->
                            `Float f
                         in
                      (`List
                         (List.map
                            yojson_of_el l) : 
Yojson.Safe.json))) v))
              x.strokeDash));
         ("strokeDashOffset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.strokeDashOffset));
         ("strokeOpacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.strokeOpacity));
         ("strokeWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.strokeWidth));
         ("tension",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.tension));
         ("text",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.text));
         ("theta",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
v)) x.theta))])                                     
  let make ?align  ?angle  ?baseline  ?dx 
    ?dy  ?fill  ?fillOpacity  ?font 
    ?fontSize  ?fontStyle  ?fontWeight 
    ?interpolate  ?limit  ?opacity  ?orient 
    ?radius  ?shape  ?size  ?stroke 
    ?strokeDash  ?strokeDashOffset 
    ?strokeOpacity  ?strokeWidth  ?tension 
    ?text  ?theta  () =
    {
      theta;
      text;
      tension;
      strokeWidth;
      strokeOpacity;
      strokeDashOffset;
      strokeDash;
      stroke;
      size;
      shape;
      radius;
      orient;
      opacity;
      limit;
      interpolate;
      fontWeight;
      fontStyle;
      fontSize;
      font;
      fillOpacity;
      fill;
      dy;
      dx;
      baseline;
      angle;
      align
    } 
  let withAlign v x =
    { x with align = (Some v) } 
  let withAngle v x =
    { x with angle = (Some v) } 
  let withBaseline v x =
    { x with baseline = (Some v) } 
  let withDx v x = { x with dx = (Some v) } 
  let withDy v x = { x with dy = (Some v) } 
  let withFill v x =
    { x with fill = (Some v) } 
  let withFillOpacity v x =
    { x with fillOpacity = (Some v) } 
  let withFont v x =
    { x with font = (Some v) } 
  let withFontSize v x =
    { x with fontSize = (Some v) } 
  let withFontStyle v x =
    { x with fontStyle = (Some v) } 
  let withFontWeight v x =
    { x with fontWeight = (Some v) } 
  let withInterpolate v x =
    { x with interpolate = (Some v) } 
  let withLimit v x =
    { x with limit = (Some v) } 
  let withOpacity v x =
    { x with opacity = (Some v) } 
  let withOrient v x =
    { x with orient = (Some v) } 
  let withRadius v x =
    { x with radius = (Some v) } 
  let withShape v x =
    { x with shape = (Some v) } 
  let withSize v x =
    { x with size = (Some v) } 
  let withStroke v x =
    { x with stroke = (Some v) } 
  let withStrokeDash v x =
    { x with strokeDash = (Some v) } 
  let withStrokeDashOffset v x =
    { x with strokeDashOffset = (Some v) } 
  let withStrokeOpacity v x =
    { x with strokeOpacity = (Some v) } 
  let withStrokeWidth v x =
    { x with strokeWidth = (Some v) } 
  let withTension v x =
    { x with tension = (Some v) } 
  let withText v x =
    { x with text = (Some v) } 
  let withTheta v x =
    { x with theta = (Some v) } 
end and
VgLegendConfig:sig
  type nonrec t =
    {
    titlePadding:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    titleLimit:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    titleFontWeight:
      [ `Float of float 
      | `Int of int 
      | `String of string ]
        option
      ;
    titleFontSize:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    titleFont:
      string option ;
    titleColor:
      string option ;
    titleBaseline:
      string option ;
    titleAlign:
      string option ;
    symbolType:
      string option ;
    symbolStrokeWidth:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    symbolSize:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    symbolColor:
      string option ;
    strokeWidth:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    strokeDash:
      [ `Int of int 
      | `Float of float ]
        list option
      ;
    strokeColor:
      string option ;
    padding:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    orient:
LegendOrient.t
        option
      ;
    offset:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    labelOffset:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    labelLimit:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    labelFontSize:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    labelFont:
      string option ;
    labelColor:
      string option ;
    labelBaseline:
      string option ;
    labelAlign:
      string option ;
    gradientWidth:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    gradientStrokeWidth:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    gradientStrokeColor:
      string option ;
    gradientLabelOffset:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    gradientLabelLimit:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    gradientLabelBaseline:
      string option ;
    gradientHeight:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    fillColor:
      string option ;
    entryPadding:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    cornerRadius:
      [ `Int of int 
      | `Float of float ]
        option
      }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?cornerRadius:
      [ `Int of int 
      | `Float of float ]
      ->
      ?entryPadding:
        [ `Int of int 
        | `Float of float ]
        ->
        ?fillColor:string
          ->
          ?gradientHeight:
            [
              `Int of int 
            | `Float of
                float ]
            ->
            ?gradientLabelBaseline:string
              ->
              ?gradientLabelLimit:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?gradientLabelOffset:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?gradientStrokeColor:string
                ->
                ?gradientStrokeWidth:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?gradientWidth:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?labelAlign:string
                ->
                ?labelBaseline:string
                ->
                ?labelColor:string
                ->
                ?labelFont:string
                ->
                ?labelFontSize:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?labelLimit:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?labelOffset:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?offset:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?orient:LegendOrient.t
                ->
                ?padding:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?strokeColor:string
                ->
                ?strokeDash:
                [
                `Int of
                int 
                | `Float
                of float ]
                list ->
                ?strokeWidth:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?symbolColor:string
                ->
                ?symbolSize:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?symbolStrokeWidth:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?symbolType:string
                ->
                ?titleAlign:string
                ->
                ?titleBaseline:string
                ->
                ?titleColor:string
                ->
                ?titleFont:string
                ->
                ?titleFontSize:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?titleFontWeight:
                [
                `Float of
                float 
                | `Int of
                int 
                | `String
                of string ]
                ->
                ?titleLimit:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                ?titlePadding:
                [
                `Int of
                int 
                | `Float
                of float ]
                ->
                unit -> t
  val withCornerRadius :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withEntryPadding :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withFillColor :
    string -> t -> t
  val withGradientHeight
    :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val
    withGradientLabelBaseline
    : string -> t -> t
  val
    withGradientLabelLimit
    :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val
    withGradientLabelOffset
    :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val
    withGradientStrokeColor
    : string -> t -> t
  val
    withGradientStrokeWidth
    :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withGradientWidth :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withLabelAlign :
    string -> t -> t
  val withLabelBaseline :
    string -> t -> t
  val withLabelColor :
    string -> t -> t
  val withLabelFont :
    string -> t -> t
  val withLabelFontSize :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withLabelLimit :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withLabelOffset :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withOffset :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withOrient :
LegendOrient.t ->
      t -> t
  val withPadding :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withStrokeColor :
    string -> t -> t
  val withStrokeDash :
    [ `Int of int 
    | `Float of float ]
      list -> t -> t
  val withStrokeWidth :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withSymbolColor :
    string -> t -> t
  val withSymbolSize :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val
    withSymbolStrokeWidth
    :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withSymbolType :
    string -> t -> t
  val withTitleAlign :
    string -> t -> t
  val withTitleBaseline :
    string -> t -> t
  val withTitleColor :
    string -> t -> t
  val withTitleFont :
    string -> t -> t
  val withTitleFontSize :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withTitleFontWeight
    :
    [ `Float of float 
    | `Int of int 
    | `String of string ]
      -> t -> t
  val withTitleLimit :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withTitlePadding :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
end =
struct
  type nonrec t =
    {
    titlePadding:
      [ `Int of int  | `Float of float ]
        option
      ;
    titleLimit:
      [ `Int of int  | `Float of float ]
        option
      ;
    titleFontWeight:
      [ `Float of float  | `Int of int 
      | `String of string ] option ;
    titleFontSize:
      [ `Int of int  | `Float of float ]
        option
      ;
    titleFont: string option ;
    titleColor: string option ;
    titleBaseline: string option ;
    titleAlign: string option ;
    symbolType: string option ;
    symbolStrokeWidth:
      [ `Int of int  | `Float of float ]
        option
      ;
    symbolSize:
      [ `Int of int  | `Float of float ]
        option
      ;
    symbolColor: string option ;
    strokeWidth:
      [ `Int of int  | `Float of float ]
        option
      ;
    strokeDash:
      [ `Int of int  | `Float of float ]
        list option
      ;
    strokeColor: string option ;
    padding:
      [ `Int of int  | `Float of float ]
        option
      ;
    orient: LegendOrient.t option ;
    offset:
      [ `Int of int  | `Float of float ]
        option
      ;
    labelOffset:
      [ `Int of int  | `Float of float ]
        option
      ;
    labelLimit:
      [ `Int of int  | `Float of float ]
        option
      ;
    labelFontSize:
      [ `Int of int  | `Float of float ]
        option
      ;
    labelFont: string option ;
    labelColor: string option ;
    labelBaseline: string option ;
    labelAlign: string option ;
    gradientWidth:
      [ `Int of int  | `Float of float ]
        option
      ;
    gradientStrokeWidth:
      [ `Int of int  | `Float of float ]
        option
      ;
    gradientStrokeColor: string option ;
    gradientLabelOffset:
      [ `Int of int  | `Float of float ]
        option
      ;
    gradientLabelLimit:
      [ `Int of int  | `Float of float ]
        option
      ;
    gradientLabelBaseline: string option ;
    gradientHeight:
      [ `Int of int  | `Float of float ]
        option
      ;
    fillColor: string option ;
    entryPadding:
      [ `Int of int  | `Float of float ]
        option
      ;
    cornerRadius:
      [ `Int of int  | `Float of float ]
        option
      }

  (** Fields
  
    titlePadding:
      The padding, in pixels, between title and legend.
  
    titleLimit:
      Maximum allowed pixel width of axis titles.
  
    titleFontWeight:
      The font weight of the legend title.
  
    titleFontSize:
      The font size of the legend title.
  
    titleFont:
      The font of the legend title.
  
    titleColor:
      The color of the legend title, can be in hex color code or regular color name.
  
    titleBaseline:
      Optional mark property definitions for custom legend styling. 
       Vertical text baseline for legend titles.
  
    titleAlign:
      Horizontal text alignment for legend titles.
  
    symbolType:
      Default shape type (such as "circle") for legend symbols.
  
    symbolStrokeWidth:
      The width of the symbol's stroke.
  
    symbolSize:
      The size of the legend symbol, in pixels.
  
    symbolColor:
      The color of the legend symbol,
  
    strokeWidth:
      Border stroke width for the full legend.
  
    strokeDash:
      Border stroke dash pattern for the full legend.
  
    strokeColor:
      Border stroke color for the full legend.
  
    padding:
      The padding, in pixels, between the legend and axis.
  
    orient:
      The orientation of the legend, which determines how the legend is positioned within the scene. One of "left", "right", "top-left", "top-right", "bottom-left", "bottom-right", "none".
      
      __Default value:__ `"right"`
  
    offset:
      The offset, in pixels, by which to displace the legend from the edge of the enclosing group or data rectangle.
      
      __Default value:__  `0`
  
    labelOffset:
      The offset of the legend label.
  
    labelLimit:
      Maximum allowed pixel width of axis tick labels.
  
    labelFontSize:
      The font size of legend label.
      
      __Default value:__ `10`.
  
    labelFont:
      The font of the legend label.
  
    labelColor:
      The color of the legend label, can be in hex color code or regular color name.
  
    labelBaseline:
      The position of the baseline of legend label, can be top, middle or bottom.
  
    labelAlign:
      The alignment of the legend label, can be left, middle or right.
  
    gradientWidth:
      The width of the gradient, in pixels.
  
    gradientStrokeWidth:
      The width of the gradient stroke, in pixels.
  
    gradientStrokeColor:
      The color of the gradient stroke, can be in hex color code or regular color name.
  
    gradientLabelOffset:
      Vertical offset in pixels for color ramp gradient labels.
  
    gradientLabelLimit:
      The maximum allowed length in pixels of color ramp gradient labels.
  
    gradientLabelBaseline:
      Text baseline for color ramp gradient labels.
  
    gradientHeight:
      The height of the gradient, in pixels.
  
    fillColor:
      Background fill color for the full legend.
  
    entryPadding:
      Padding (in pixels) between legend entries in a symbol legend.
  
    cornerRadius:
      Corner radius for the full legend.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("cornerRadius",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function
                     | `Int i -> `Int i
                     | `Float f ->
                         `Float f)) v))
               x.cornerRadius));
         ("entryPadding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.entryPadding));
         ("fillColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.fillColor));
         ("gradientHeight",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.gradientHeight));
         ("gradientLabelBaseline",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v))
              x.gradientLabelBaseline));
         ("gradientLabelLimit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.gradientLabelLimit));
         ("gradientLabelOffset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.gradientLabelOffset));
         ("gradientStrokeColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v))
              x.gradientStrokeColor));
         ("gradientStrokeWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.gradientStrokeWidth));
         ("gradientWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.gradientWidth));
         ("labelAlign",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.labelAlign));
         ("labelBaseline",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.labelBaseline));
         ("labelColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.labelColor));
         ("labelFont",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.labelFont));
         ("labelFontSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.labelFontSize));
         ("labelLimit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.labelLimit));
         ("labelOffset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.labelOffset));
         ("offset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.offset));
         ("orient",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
LegendOrient.t)
                       ->
                      (LegendOrient.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.orient));
         ("padding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.padding));
         ("strokeColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.strokeColor));
         ("strokeDash",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (l :
                        [ `Int of int 
                        | `Float of
                            float ]
                          list)
                       ->
                      let yojson_of_el =
                        function
                        | `Int i ->
                            `Int i
                        | `Float f ->
                            `Float f
                         in
                      (`List
                         (List.map
                            yojson_of_el
                            l) : 
Yojson.Safe.json)))
                    v)) x.strokeDash));
         ("strokeWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.strokeWidth));
         ("symbolColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.symbolColor));
         ("symbolSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.symbolSize));
         ("symbolStrokeWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.symbolStrokeWidth));
         ("symbolType",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.symbolType));
         ("titleAlign",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.titleAlign));
         ("titleBaseline",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.titleBaseline));
         ("titleColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.titleColor));
         ("titleFont",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.titleFont));
         ("titleFontSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.titleFontSize));
         ("titleFontWeight",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `String v ->
                        ((fun
                            (s : string)
                             ->
                            (`String s : 
Yojson.Safe.json)))
                          v
                    | `Int v ->
                        ((fun (i : int) 
                            ->
                            (`Int i : 
Yojson.Safe.json)))
                          v
                    | `Float v ->
                        ((fun
                            (f : float) 
                            ->
                            (`Float f : 
Yojson.Safe.json)))
                          v)) v))
              x.titleFontWeight));
         ("titleLimit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.titleLimit));
         ("titlePadding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
x.titlePadding))])                                          
  let make ?cornerRadius  ?entryPadding 
    ?fillColor  ?gradientHeight 
    ?gradientLabelBaseline 
    ?gradientLabelLimit 
    ?gradientLabelOffset 
    ?gradientStrokeColor 
    ?gradientStrokeWidth  ?gradientWidth
     ?labelAlign  ?labelBaseline 
    ?labelColor  ?labelFont 
    ?labelFontSize  ?labelLimit 
    ?labelOffset  ?offset  ?orient 
    ?padding  ?strokeColor  ?strokeDash 
    ?strokeWidth  ?symbolColor 
    ?symbolSize  ?symbolStrokeWidth 
    ?symbolType  ?titleAlign 
    ?titleBaseline  ?titleColor 
    ?titleFont  ?titleFontSize 
    ?titleFontWeight  ?titleLimit 
    ?titlePadding  () =
    {
      titlePadding;
      titleLimit;
      titleFontWeight;
      titleFontSize;
      titleFont;
      titleColor;
      titleBaseline;
      titleAlign;
      symbolType;
      symbolStrokeWidth;
      symbolSize;
      symbolColor;
      strokeWidth;
      strokeDash;
      strokeColor;
      padding;
      orient;
      offset;
      labelOffset;
      labelLimit;
      labelFontSize;
      labelFont;
      labelColor;
      labelBaseline;
      labelAlign;
      gradientWidth;
      gradientStrokeWidth;
      gradientStrokeColor;
      gradientLabelOffset;
      gradientLabelLimit;
      gradientLabelBaseline;
      gradientHeight;
      fillColor;
      entryPadding;
      cornerRadius
    } 
  let withCornerRadius v x =
    { x with cornerRadius = (Some v) } 
  let withEntryPadding v x =
    { x with entryPadding = (Some v) } 
  let withFillColor v x =
    { x with fillColor = (Some v) } 
  let withGradientHeight v x =
    { x with gradientHeight = (Some v) } 
  let withGradientLabelBaseline v x =
    {
      x with
      gradientLabelBaseline = (Some v)
    } 
  let withGradientLabelLimit v x =
    {
      x with
      gradientLabelLimit = (Some v)
    } 
  let withGradientLabelOffset v x =
    {
      x with
      gradientLabelOffset = (Some v)
    } 
  let withGradientStrokeColor v x =
    {
      x with
      gradientStrokeColor = (Some v)
    } 
  let withGradientStrokeWidth v x =
    {
      x with
      gradientStrokeWidth = (Some v)
    } 
  let withGradientWidth v x =
    { x with gradientWidth = (Some v) } 
  let withLabelAlign v x =
    { x with labelAlign = (Some v) } 
  let withLabelBaseline v x =
    { x with labelBaseline = (Some v) } 
  let withLabelColor v x =
    { x with labelColor = (Some v) } 
  let withLabelFont v x =
    { x with labelFont = (Some v) } 
  let withLabelFontSize v x =
    { x with labelFontSize = (Some v) } 
  let withLabelLimit v x =
    { x with labelLimit = (Some v) } 
  let withLabelOffset v x =
    { x with labelOffset = (Some v) } 
  let withOffset v x =
    { x with offset = (Some v) } 
  let withOrient v x =
    { x with orient = (Some v) } 
  let withPadding v x =
    { x with padding = (Some v) } 
  let withStrokeColor v x =
    { x with strokeColor = (Some v) } 
  let withStrokeDash v x =
    { x with strokeDash = (Some v) } 
  let withStrokeWidth v x =
    { x with strokeWidth = (Some v) } 
  let withSymbolColor v x =
    { x with symbolColor = (Some v) } 
  let withSymbolSize v x =
    { x with symbolSize = (Some v) } 
  let withSymbolStrokeWidth v x =
    {
      x with
      symbolStrokeWidth = (Some v)
    } 
  let withSymbolType v x =
    { x with symbolType = (Some v) } 
  let withTitleAlign v x =
    { x with titleAlign = (Some v) } 
  let withTitleBaseline v x =
    { x with titleBaseline = (Some v) } 
  let withTitleColor v x =
    { x with titleColor = (Some v) } 
  let withTitleFont v x =
    { x with titleFont = (Some v) } 
  let withTitleFontSize v x =
    { x with titleFontSize = (Some v) } 
  let withTitleFontWeight v x =
    { x with titleFontWeight = (Some v)
    } 
  let withTitleLimit v x =
    { x with titleLimit = (Some v) } 
  let withTitlePadding v x =
    { x with titlePadding = (Some v) } 
end and
VgLegendBase:sig
  type nonrec t =
    {
    titleAlign:
      string option ;
    padding:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    orient:
LegendOrient.t
        option
      ;
    offset:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    fillColor:
      string option ;
    entryPadding:
      [ `Int of int 
      | `Float of
          float ]
        option
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?entryPadding:
      [ `Int of int 
      | `Float of
          float ]
      ->
      ?fillColor:string
        ->
        ?offset:
          [
            `Int of
             int 
          | `Float of
             float ]
          ->
          ?orient:LegendOrient.t
            ->
            ?padding:
             [
             `Int of
             int 
             | `Float
             of float ]
             ->
             ?titleAlign:string
             ->
             unit -> t
  val withEntryPadding
    :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withFillColor :
    string -> t -> t
  val withOffset :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withOrient :
LegendOrient.t ->
      t -> t
  val withPadding :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withTitleAlign :
    string -> t -> t
end =
struct
  type nonrec t =
    {
    titleAlign: string option ;
    padding:
      [ `Int of int 
      | `Float of float ] option ;
    orient: LegendOrient.t option ;
    offset:
      [ `Int of int 
      | `Float of float ] option ;
    fillColor: string option ;
    entryPadding:
      [ `Int of int 
      | `Float of float ] option }

  (** Fields
  
    titleAlign:
      Horizontal text alignment for legend titles.
  
    padding:
      The padding, in pixels, between the legend and axis.
  
    orient:
      The orientation of the legend, which determines how the legend is positioned within the scene. One of "left", "right", "top-left", "top-right", "bottom-left", "bottom-right", "none".
      
      __Default value:__ `"right"`
  
    offset:
      The offset, in pixels, by which to displace the legend from the edge of the enclosing group or data rectangle.
      
      __Default value:__  `0`
  
    fillColor:
      Background fill color for the full legend.
  
    entryPadding:
      Padding (in pixels) between legend entries in a symbol legend.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("entryPadding",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function
                     | `Int i ->
                         `Int i
                     | `Float f ->
                         `Float f))
                     v))
               x.entryPadding));
         ("fillColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (s : string) 
                      ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.fillColor));
         ("offset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i ->
                        `Int i
                    | `Float f ->
                        `Float f))
                    v)) x.offset));
         ("orient",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
LegendOrient.t)
                       ->
                      (LegendOrient.to_yojson
                         x : 
Yojson.Safe.json)))
                    v)) x.orient));
         ("padding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i ->
                        `Int i
                    | `Float f ->
                        `Float f))
                    v)) x.padding));
         ("titleAlign",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (s : string) 
                      ->
                      (`String s : 
Yojson.Safe.json)))
                    v))
x.titleAlign))])                                               
  let make ?entryPadding 
    ?fillColor  ?offset  ?orient 
    ?padding  ?titleAlign  () =
    {
      titleAlign;
      padding;
      orient;
      offset;
      fillColor;
      entryPadding
    } 
  let withEntryPadding v x =
    {
      x with
      entryPadding = (Some v)
    } 
  let withFillColor v x =
    { x with fillColor = (Some v) } 
  let withOffset v x =
    { x with offset = (Some v) } 
  let withOrient v x =
    { x with orient = (Some v) } 
  let withPadding v x =
    { x with padding = (Some v) } 
  let withTitleAlign v x =
    { x with titleAlign = (Some v)
    } 
end and
VgGenericBinding:sig
  type nonrec t =
    {
    input:
    string ;
    element:
    string
    option }
  val
    to_yojson
    :
    t ->
Yojson.Safe.json
  val make :
    ?element:string
    ->
    input:string
    ->
    unit -> t
  val
    withElement
    :
    string ->
    t -> t
  val
    withInput
    :
    string ->
    t -> t
end =
struct
  type nonrec t =
    {
    input: string ;
    element: string option }

  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("element",
            (((function
               | None  ->
                   `Null
               | Some v ->
                   ((fun
                     (s :
                     string) 
                     ->
                     (`String
                     s : 
Yojson.Safe.json)))
                     v))
               x.element));
         ("input",
           (((fun (s : string)
                 ->
                (`String s : 
Yojson.Safe.json)))
x.input))])                                                    
  let make ?element  ~input 
    () = { input; element } 
  let withElement v x =
    {
      x with
      element = (Some v)
    } 
  let withInput v x =
    { x with input = v } 
end and
VgEventStream:sig
  type t =
Yojson.Safe.json
  val
  to_yojson
  :
  t ->
Yojson.Safe.json
end =
struct
  type t =
Yojson.Safe.json

  let to_yojson
    (j :
Yojson.Safe.json)
    =
(j : Yojson.Safe.json)                                                         
end and
VgCheckboxBinding:
                                                         sig
  type nonrec t =
    {
    input:
      [ `Checkbox ] ;
    element:
      string option }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?element:string
      ->
      input:
        [
          `Checkbox ]
        -> unit -> t
  val withElement :
    string -> t -> t
  val withInput :
    [ `Checkbox ] ->
      t -> t
end =
struct
  type nonrec t =
    {
    input:
      [ `Checkbox ] ;
    element:
      string option }

  let to_yojson x =
    `Assoc
      (List.filter
         (fun 
           (k,v)  ->
           match v
           with
           | 
           `Null ->
           false
           | 
           _ -> true)
         [("element",
           (((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.element));
         ("input",
           (
           ((function
           | `Checkbox
           ->
           `String
           "checkbox"))
x.input))])                                                              
  let make ?element 
    ~input  () =
    { input; element
    } 
  let withElement v
    x =
    {
      x with
      element =
        (Some v)
    } 
  let withInput v x
    =
    {
      x with
      input = v
    } 
end and
VgBinding:
                                                              sig
  type t =
    [
      `VgCheckbox
      of
VgCheckboxBinding.t
       | 
      `VgRadio
      of
VgRadioBinding.t
       | 
      `VgSelect
      of
VgSelectBinding.t
       | 
      `VgRange
      of
VgRangeBinding.t
       | 
      `VgGeneric
      of
VgGenericBinding.t
      ]
  val to_yojson
    :
    t ->
Yojson.Safe.json
end =
struct
  type t =
    [
      `VgCheckbox
      of
VgCheckboxBinding.t
       | 
      `VgRadio
      of
VgRadioBinding.t
       | 
      `VgSelect
      of
VgSelectBinding.t
       | 
      `VgRange
      of
VgRangeBinding.t
       | 
      `VgGeneric
      of
VgGenericBinding.t
      ]

  let to_yojson
    =
    function
    | `VgGeneric
      v ->
      ((fun
      (x :
VgGenericBinding.t)
       ->
      (VgGenericBinding.to_yojson
      x : Yojson.Safe.json)))
      v
    | `VgRange
      v ->
      ((fun
      (x :
VgRangeBinding.t)
       ->
      (VgRangeBinding.to_yojson
      x : Yojson.Safe.json)))
      v
    | `VgSelect
      v ->
      ((fun
      (x :
VgSelectBinding.t)
       ->
      (VgSelectBinding.to_yojson
      x : Yojson.Safe.json)))
      v
    | `VgRadio
      v ->
      ((fun
      (x :
VgRadioBinding.t)
       ->
      (VgRadioBinding.to_yojson
      x : Yojson.Safe.json)))
      v
    | `VgCheckbox
      v ->
      ((fun
      (x :
VgCheckboxBinding.t)
       ->
      (VgCheckboxBinding.to_yojson
      x : Yojson.Safe.json)))
v                                                                   
end and
VgAxisConfig:
                                                                   sig
 type nonrec t =
 {
 titleY:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleX:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titlePadding:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleMaxLength:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleLimit:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleFontWeight:
 [
 `Float of
 float 
 | `Int of
 int 
 | `String
 of string ]
 option ;
 titleFontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleFont:
 string
 option ;
 titleColor:
 string
 option ;
 titleBaseline:
 string
 option ;
 titleAngle:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleAlign:
 string
 option ;
 ticks:
 bool
 option ;
 tickWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 tickSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 tickRound:
 bool
 option ;
 tickColor:
 string
 option ;
 minExtent:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 maxExtent:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labels:
 bool
 option ;
 labelPadding:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labelOverlap:
 [
 `Greedy 
 | `Parity 
 | `Bool
 of bool ]
 option ;
 labelLimit:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labelFontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labelFont:
 string
 option ;
 labelColor:
 string
 option ;
 labelAngle:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 gridWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 gridOpacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 gridDash:
 [
 `Int of
 int 
 | `Float
 of float ]
 list
 option ;
 gridColor:
 string
 option ;
 grid:
 bool
 option ;
 domainWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 domainColor:
 string
 option ;
 domain:
 bool
 option ;
 bandPosition:
 [
 `Int of
 int 
 | `Float
 of float ]
 option }
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
 val make
 :
 ?bandPosition:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?domain:bool
 ->
 ?domainColor:string
 ->
 ?domainWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?grid:bool
 ->
 ?gridColor:string
 ->
 ?gridDash:
 [
 `Int of
 int 
 | `Float
 of float ]
 list ->
 ?gridOpacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?gridWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?labelAngle:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?labelColor:string
 ->
 ?labelFont:string
 ->
 ?labelFontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?labelLimit:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?labelOverlap:
 [
 `Greedy 
 | `Parity 
 | `Bool
 of bool ]
 ->
 ?labelPadding:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?labels:bool
 ->
 ?maxExtent:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?minExtent:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?tickColor:string
 ->
 ?tickRound:bool
 ->
 ?tickSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?tickWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?ticks:bool
 ->
 ?titleAlign:string
 ->
 ?titleAngle:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?titleBaseline:string
 ->
 ?titleColor:string
 ->
 ?titleFont:string
 ->
 ?titleFontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?titleFontWeight:
 [
 `Float of
 float 
 | `Int of
 int 
 | `String
 of string ]
 ->
 ?titleLimit:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?titleMaxLength:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?titlePadding:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?titleX:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?titleY:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 unit -> t
 val
 withBandPosition
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withDomain
 :
 bool ->
 t -> t
 val
 withDomainColor
 :
 string ->
 t -> t
 val
 withDomainWidth
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withGrid
 :
 bool ->
 t -> t
 val
 withGridColor
 :
 string ->
 t -> t
 val
 withGridDash
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 list ->
 t -> t
 val
 withGridOpacity
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withGridWidth
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withLabelAngle
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withLabelColor
 :
 string ->
 t -> t
 val
 withLabelFont
 :
 string ->
 t -> t
 val
 withLabelFontSize
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withLabelLimit
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withLabelOverlap
 :
 [
 `Greedy 
 | `Parity 
 | `Bool
 of bool ]
 -> 
 t -> t
 val
 withLabelPadding
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withLabels
 :
 bool ->
 t -> t
 val
 withMaxExtent
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withMinExtent
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTickColor
 :
 string ->
 t -> t
 val
 withTickRound
 :
 bool ->
 t -> t
 val
 withTickSize
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTickWidth
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTicks
 :
 bool ->
 t -> t
 val
 withTitleAlign
 :
 string ->
 t -> t
 val
 withTitleAngle
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTitleBaseline
 :
 string ->
 t -> t
 val
 withTitleColor
 :
 string ->
 t -> t
 val
 withTitleFont
 :
 string ->
 t -> t
 val
 withTitleFontSize
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTitleFontWeight
 :
 [
 `Float of
 float 
 | `Int of
 int 
 | `String
 of string ]
 -> 
 t -> t
 val
 withTitleLimit
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTitleMaxLength
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTitlePadding
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTitleX
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTitleY
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
end =
struct
 type nonrec t =
 {
 titleY:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleX:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titlePadding:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleMaxLength:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleLimit:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleFontWeight:
 [
 `Float of
 float 
 | `Int of
 int 
 | `String
 of string ]
 option ;
 titleFontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleFont:
 string
 option ;
 titleColor:
 string
 option ;
 titleBaseline:
 string
 option ;
 titleAngle:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleAlign:
 string
 option ;
 ticks:
 bool
 option ;
 tickWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 tickSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 tickRound:
 bool
 option ;
 tickColor:
 string
 option ;
 minExtent:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 maxExtent:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labels:
 bool
 option ;
 labelPadding:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labelOverlap:
 [
 `Greedy 
 | `Parity 
 | `Bool
 of bool ]
 option ;
 labelLimit:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labelFontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labelFont:
 string
 option ;
 labelColor:
 string
 option ;
 labelAngle:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 gridWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 gridOpacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 gridDash:
 [
 `Int of
 int 
 | `Float
 of float ]
 list
 option ;
 gridColor:
 string
 option ;
 grid:
 bool
 option ;
 domainWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 domainColor:
 string
 option ;
 domain:
 bool
 option ;
 bandPosition:
 [
 `Int of
 int 
 | `Float
 of float ]
 option }

  (** Fields
  
    titleY:
      Y-coordinate of the axis title relative to the axis group.
  
    titleX:
      X-coordinate of the axis title relative to the axis group.
  
    titlePadding:
      The padding, in pixels, between title and axis.
  
    titleMaxLength:
      Max length for axis title if the title is automatically generated from the field's description.
  
    titleLimit:
      Maximum allowed pixel width of axis titles.
  
    titleFontWeight:
      Font weight of the title. (e.g., `"bold"`).
  
    titleFontSize:
      Font size of the title.
  
    titleFont:
      Font of the title. (e.g., `"Helvetica Neue"`).
  
    titleColor:
      Color of the title, can be in hex color code or regular color name.
  
    titleBaseline:
      Vertical text baseline for axis titles.
  
    titleAngle:
      Angle in degrees of axis titles.
  
    titleAlign:
      Horizontal text alignment of axis titles.
  
    ticks:
      Boolean value that determines whether the axis should include ticks.
  
    tickWidth:
      The width, in pixels, of ticks.
  
    tickSize:
      The size in pixels of axis ticks.
  
    tickRound:
      Boolean flag indicating if pixel position values should be rounded to the nearest integer.
  
    tickColor:
      The color of the axis's tick.
  
    minExtent:
      The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.
      
      __Default value:__ `30` for y-axis; `undefined` for x-axis.
  
    maxExtent:
      The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.
      
      __Default value:__ `undefined`.
  
    labels:
      A boolean flag indicating if labels should be included as part of the axis.
      
      __Default value:__  `true`.
  
    labelPadding:
      The padding, in pixels, between axis and text labels.
  
    labelOverlap:
      The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).
      
      __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log scales; otherwise `false`.
  
    labelLimit:
      Maximum allowed pixel width of axis tick labels.
  
    labelFontSize:
      The font size of the label, in pixels.
  
    labelFont:
      The font of the tick label.
  
    labelColor:
      The color of the tick label, can be in hex color code or regular color name.
  
    labelAngle:
      The rotation angle of the axis labels.
      
      __Default value:__ `-90` for nominal, ordinal, temporal, and binned fields; `0` otherwise.
  
    gridWidth:
      The grid width, in pixels.
  
    gridOpacity:
      The stroke opacity of grid (value between [0,1])
      
      __Default value:__ (`1` by default)
  
    gridDash:
      The offset (in pixels) into which to begin drawing with the grid dash array.
  
    gridColor:
      Color of gridlines.
  
    grid:
      A boolean flag indicating if grid lines should be included as part of the axis
      
      __Default value:__ `true` for [continuous scales](scale.html#continuous) that are not binned; otherwise, `false`.
  
    domainWidth:
      Stroke width of axis domain line
      
      __Default value:__  (none, using Vega default).
  
    domainColor:
      Color of axis domain line.
      
      __Default value:__  (none, using Vega default).
  
    domain:
      A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis.
      
      __Default value:__ `true`
  
    bandPosition:
      An interpolation fraction indicating where, for `band` scales, axis ticks should be positioned. A value of `0` places ticks at the left edge of their bands. A value of `0.5` places ticks in the middle of their bands.
  *)
 let to_yojson
 x =
 `Assoc
 (List.filter
 (fun
 (k,v)  ->
 match v
 with
 | 
 `Null ->
 false
 | 
 _ -> true)
 [
 ("bandPosition",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.bandPosition));
 ("domain",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.domain));
 ("domainColor",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.domainColor));
 ("domainWidth",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.domainWidth));
 ("grid",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.grid));
 ("gridColor",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.gridColor));
 ("gridDash",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (l :
 [
 `Int of
 int 
 | `Float
 of float ]
 list)  ->
 let yojson_of_el
 =
 function
 | 
 `Int i ->
 `Int i
 | 
 `Float f
 ->
 `Float f
  in
 (`List
 (List.map
 yojson_of_el
 l) : 
Yojson.Safe.json)))
 v))
 x.gridDash));
 ("gridOpacity",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.gridOpacity));
 ("gridWidth",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.gridWidth));
 ("labelAngle",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.labelAngle));
 ("labelColor",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.labelColor));
 ("labelFont",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.labelFont));
 ("labelFontSize",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.labelFontSize));
 ("labelLimit",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.labelLimit));
 ("labelOverlap",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Bool v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v
 | `Parity
 ->
 `String
 "parity"
 | `Greedy
 ->
 `String
 "greedy"))
 v))
 x.labelOverlap));
 ("labelPadding",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.labelPadding));
 ("labels",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.labels));
 ("maxExtent",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.maxExtent));
 ("minExtent",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.minExtent));
 ("tickColor",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.tickColor));
 ("tickRound",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.tickRound));
 ("tickSize",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.tickSize));
 ("tickWidth",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.tickWidth));
 ("ticks",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.ticks));
 ("titleAlign",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.titleAlign));
 ("titleAngle",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.titleAngle));
 ("titleBaseline",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.titleBaseline));
 ("titleColor",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.titleColor));
 ("titleFont",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.titleFont));
 ("titleFontSize",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.titleFontSize));
 ("titleFontWeight",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `String
 v ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v
 | `Int v
 ->
 ((fun
 (i : int)
  ->
 (`Int i : 
Yojson.Safe.json)))
 v
 | `Float
 v ->
 ((fun
 (f :
 float) 
 ->
 (`Float f : 
Yojson.Safe.json)))
 v)) v))
 x.titleFontWeight));
 ("titleLimit",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.titleLimit));
 ("titleMaxLength",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.titleMaxLength));
 ("titlePadding",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.titlePadding));
 ("titleX",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.titleX));
 ("titleY",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
x.titleY))])                                                                     
 let make
 ?bandPosition
  ?domain 
 ?domainColor
  ?domainWidth
  ?grid 
 ?gridColor
  ?gridDash
  ?gridOpacity
  ?gridWidth
  ?labelAngle
  ?labelColor
  ?labelFont
  ?labelFontSize
  ?labelLimit
  ?labelOverlap
  ?labelPadding
  ?labels 
 ?maxExtent
  ?minExtent
  ?tickColor
  ?tickRound
  ?tickSize
  ?tickWidth
  ?ticks 
 ?titleAlign
  ?titleAngle
  ?titleBaseline
  ?titleColor
  ?titleFont
  ?titleFontSize
  ?titleFontWeight
  ?titleLimit
  ?titleMaxLength
  ?titlePadding
  ?titleX 
 ?titleY 
 () =
 {
 titleY;
 titleX;
 titlePadding;
 titleMaxLength;
 titleLimit;
 titleFontWeight;
 titleFontSize;
 titleFont;
 titleColor;
 titleBaseline;
 titleAngle;
 titleAlign;
 ticks;
 tickWidth;
 tickSize;
 tickRound;
 tickColor;
 minExtent;
 maxExtent;
 labels;
 labelPadding;
 labelOverlap;
 labelLimit;
 labelFontSize;
 labelFont;
 labelColor;
 labelAngle;
 gridWidth;
 gridOpacity;
 gridDash;
 gridColor;
 grid;
 domainWidth;
 domainColor;
 domain;
 bandPosition
 } 
 let withBandPosition
 v x =
 {
 x with
 bandPosition
 =
 (Some v)
 } 
 let withDomain
 v x =
 {
 x with
 domain =
 (Some v)
 } 
 let withDomainColor
 v x =
 {
 x with
 domainColor
 =
 (Some v)
 } 
 let withDomainWidth
 v x =
 {
 x with
 domainWidth
 =
 (Some v)
 } 
 let withGrid
 v x =
 {
 x with
 grid =
 (Some v)
 } 
 let withGridColor
 v x =
 {
 x with
 gridColor
 =
 (Some v)
 } 
 let withGridDash
 v x =
 {
 x with
 gridDash
 =
 (Some v)
 } 
 let withGridOpacity
 v x =
 {
 x with
 gridOpacity
 =
 (Some v)
 } 
 let withGridWidth
 v x =
 {
 x with
 gridWidth
 =
 (Some v)
 } 
 let withLabelAngle
 v x =
 {
 x with
 labelAngle
 =
 (Some v)
 } 
 let withLabelColor
 v x =
 {
 x with
 labelColor
 =
 (Some v)
 } 
 let withLabelFont
 v x =
 {
 x with
 labelFont
 =
 (Some v)
 } 
 let withLabelFontSize
 v x =
 {
 x with
 labelFontSize
 =
 (Some v)
 } 
 let withLabelLimit
 v x =
 {
 x with
 labelLimit
 =
 (Some v)
 } 
 let withLabelOverlap
 v x =
 {
 x with
 labelOverlap
 =
 (Some v)
 } 
 let withLabelPadding
 v x =
 {
 x with
 labelPadding
 =
 (Some v)
 } 
 let withLabels
 v x =
 {
 x with
 labels =
 (Some v)
 } 
 let withMaxExtent
 v x =
 {
 x with
 maxExtent
 =
 (Some v)
 } 
 let withMinExtent
 v x =
 {
 x with
 minExtent
 =
 (Some v)
 } 
 let withTickColor
 v x =
 {
 x with
 tickColor
 =
 (Some v)
 } 
 let withTickRound
 v x =
 {
 x with
 tickRound
 =
 (Some v)
 } 
 let withTickSize
 v x =
 {
 x with
 tickSize
 =
 (Some v)
 } 
 let withTickWidth
 v x =
 {
 x with
 tickWidth
 =
 (Some v)
 } 
 let withTicks
 v x =
 {
 x with
 ticks =
 (Some v)
 } 
 let withTitleAlign
 v x =
 {
 x with
 titleAlign
 =
 (Some v)
 } 
 let withTitleAngle
 v x =
 {
 x with
 titleAngle
 =
 (Some v)
 } 
 let withTitleBaseline
 v x =
 {
 x with
 titleBaseline
 =
 (Some v)
 } 
 let withTitleColor
 v x =
 {
 x with
 titleColor
 =
 (Some v)
 } 
 let withTitleFont
 v x =
 {
 x with
 titleFont
 =
 (Some v)
 } 
 let withTitleFontSize
 v x =
 {
 x with
 titleFontSize
 =
 (Some v)
 } 
 let withTitleFontWeight
 v x =
 {
 x with
 titleFontWeight
 =
 (Some v)
 } 
 let withTitleLimit
 v x =
 {
 x with
 titleLimit
 =
 (Some v)
 } 
 let withTitleMaxLength
 v x =
 {
 x with
 titleMaxLength
 =
 (Some v)
 } 
 let withTitlePadding
 v x =
 {
 x with
 titlePadding
 =
 (Some v)
 } 
 let withTitleX
 v x =
 {
 x with
 titleX =
 (Some v)
 } 
 let withTitleY
 v x =
 {
 x with
 titleY =
 (Some v)
 } 
end
and
VgAxisBase:sig
  type nonrec t =
    {
    titlePadding: [ `Int of int  | `Float of float ] option ;
    titleMaxLength: [ `Int of int  | `Float of float ] option ;
    titleAngle: [ `Int of int  | `Float of float ] option ;
    titleAlign: string option ;
    ticks: bool option ;
    tickSize: [ `Int of int  | `Float of float ] option ;
    minExtent: [ `Int of int  | `Float of float ] option ;
    maxExtent: [ `Int of int  | `Float of float ] option ;
    labels: bool option ;
    labelPadding: [ `Int of int  | `Float of float ] option ;
    labelOverlap: [ `Greedy  | `Parity  | `Bool of bool ] option ;
    labelAngle: [ `Int of int  | `Float of float ] option ;
    grid: bool option ;
    domain: bool option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?domain:bool ->
      ?grid:bool ->
        ?labelAngle:[ `Int of int  | `Float of float ] ->
          ?labelOverlap:[ `Greedy  | `Parity  | `Bool of bool ]
            ->
            ?labelPadding:[ `Int of int  | `Float of float ] ->
              ?labels:bool ->
                ?maxExtent:[ `Int of int  | `Float of float ] ->
                  ?minExtent:[ `Int of int  | `Float of float ]
                    ->
                    ?tickSize:[ `Int of int  | `Float of float ]
                      ->
                      ?ticks:bool ->
                        ?titleAlign:string ->
                          ?titleAngle:[ `Int of int 
                                      | `Float of float ]
                            ->
                            ?titleMaxLength:[ `Int of int 
                                            | `Float of float ]
                              ->
                              ?titlePadding:[ `Int of int 
                                            | `Float of float ]
                                -> unit -> t
  val withDomain : bool -> t -> t
  val withGrid : bool -> t -> t
  val withLabelAngle :
    [ `Int of int  | `Float of float ] -> t -> t
  val withLabelOverlap :
    [ `Greedy  | `Parity  | `Bool of bool ] -> t -> t
  val withLabelPadding :
    [ `Int of int  | `Float of float ] -> t -> t
  val withLabels : bool -> t -> t
  val withMaxExtent :
    [ `Int of int  | `Float of float ] -> t -> t
  val withMinExtent :
    [ `Int of int  | `Float of float ] -> t -> t
  val withTickSize :
    [ `Int of int  | `Float of float ] -> t -> t
  val withTicks : bool -> t -> t
  val withTitleAlign : string -> t -> t
  val withTitleAngle :
    [ `Int of int  | `Float of float ] -> t -> t
  val withTitleMaxLength :
    [ `Int of int  | `Float of float ] -> t -> t
  val withTitlePadding :
    [ `Int of int  | `Float of float ] -> t -> t
end =
struct
  type nonrec t =
    {
    titlePadding: [ `Int of int  | `Float of float ] option ;
    titleMaxLength: [ `Int of int  | `Float of float ] option ;
    titleAngle: [ `Int of int  | `Float of float ] option ;
    titleAlign: string option ;
    ticks: bool option ;
    tickSize: [ `Int of int  | `Float of float ] option ;
    minExtent: [ `Int of int  | `Float of float ] option ;
    maxExtent: [ `Int of int  | `Float of float ] option ;
    labels: bool option ;
    labelPadding: [ `Int of int  | `Float of float ] option ;
    labelOverlap: [ `Greedy  | `Parity  | `Bool of bool ] option ;
    labelAngle: [ `Int of int  | `Float of float ] option ;
    grid: bool option ;
    domain: bool option }

  (** Base object for Vega's Axis and Axis Config.
  All of these properties are both properties of Vega's Axis and Axis Config.
  
  
  Fields:
  
    titlePadding:
      The padding, in pixels, between title and axis.
  
    titleMaxLength:
      Max length for axis title if the title is automatically generated from the field's description.
  
    titleAngle:
      Angle in degrees of axis titles.
  
    titleAlign:
      Horizontal text alignment of axis titles.
  
    ticks:
      Boolean value that determines whether the axis should include ticks.
  
    tickSize:
      The size in pixels of axis ticks.
  
    minExtent:
      The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.
      
      __Default value:__ `30` for y-axis; `undefined` for x-axis.
  
    maxExtent:
      The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.
      
      __Default value:__ `undefined`.
  
    labels:
      A boolean flag indicating if labels should be included as part of the axis.
      
      __Default value:__  `true`.
  
    labelPadding:
      The padding, in pixels, between axis and text labels.
  
    labelOverlap:
      The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).
      
      __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log scales; otherwise `false`.
  
    labelAngle:
      The rotation angle of the axis labels.
      
      __Default value:__ `-90` for nominal, ordinal, temporal, and binned fields; `0` otherwise.
  
    grid:
      A boolean flag indicating if grid lines should be included as part of the axis
      
      __Default value:__ `true` for [continuous scales](scale.html#continuous) that are not binned; otherwise, `false`.
  
    domain:
      A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis.
      
      __Default value:__ `true`
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("domain",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) v))
               x.domain));
         ("grid",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) v))
              x.grid));
         ("labelAngle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.labelAngle));
         ("labelOverlap",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Bool v ->
                        ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json)))
                          v
                    | `Parity -> `String "parity"
                    | `Greedy -> `String "greedy")) v)) x.labelOverlap));
         ("labelPadding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.labelPadding));
         ("labels",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) v))
              x.labels));
         ("maxExtent",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.maxExtent));
         ("minExtent",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.minExtent));
         ("tickSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.tickSize));
         ("ticks",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) v))
              x.ticks));
         ("titleAlign",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  -> (`String s : Yojson.Safe.json))) v))
              x.titleAlign));
         ("titleAngle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.titleAngle));
         ("titleMaxLength",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.titleMaxLength));
         ("titlePadding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
x.titlePadding))])       
  let make ?domain  ?grid  ?labelAngle  ?labelOverlap  ?labelPadding 
    ?labels  ?maxExtent  ?minExtent  ?tickSize  ?ticks  ?titleAlign 
    ?titleAngle  ?titleMaxLength  ?titlePadding  () =
    {
      titlePadding;
      titleMaxLength;
      titleAngle;
      titleAlign;
      ticks;
      tickSize;
      minExtent;
      maxExtent;
      labels;
      labelPadding;
      labelOverlap;
      labelAngle;
      grid;
      domain
    } 
  let withDomain v x = { x with domain = (Some v) } 
  let withGrid v x = { x with grid = (Some v) } 
  let withLabelAngle v x = { x with labelAngle = (Some v) } 
  let withLabelOverlap v x = { x with labelOverlap = (Some v) } 
  let withLabelPadding v x = { x with labelPadding = (Some v) } 
  let withLabels v x = { x with labels = (Some v) } 
  let withMaxExtent v x = { x with maxExtent = (Some v) } 
  let withMinExtent v x = { x with minExtent = (Some v) } 
  let withTickSize v x = { x with tickSize = (Some v) } 
  let withTicks v x = { x with ticks = (Some v) } 
  let withTitleAlign v x = { x with titleAlign = (Some v) } 
  let withTitleAngle v x = { x with titleAngle = (Some v) } 
  let withTitleMaxLength v x = { x with titleMaxLength = (Some v) } 
  let withTitlePadding v x = { x with titlePadding = (Some v) } 
end and
VerticalAlign:sig
  type t = [ `Top  | `Middle  | `Bottom ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = [ `Top  | `Middle  | `Bottom ]

  let to_yojson =
    function
    | `Bottom -> `String "bottom"
    | `Middle -> `String "middle"
    | `Top -> `String "top" 
end and
ValueDef:sig
  type t =
    [ `Bool of bool  | `String of string 
    | `Float of float  | `Int of int ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Bool of bool  | `String of string  | `Float of float 
    | `Int of int ]

  (** Definition object for a constant value of an encoding channel.
  
  
  Fields:
  
    value:
      A constant value in visual domain.
  *)
  let to_yojson x =
    `Assoc
      [("value",
         (((function
            | `Int v ->
                ((fun (i : int)  -> (`Int i : Yojson.Safe.json)))
                  v
            | `Float v ->
                ((fun (f : float)  ->
                    (`Float f : Yojson.Safe.json))) v
            | `String v ->
                ((fun (s : string)  ->
                    (`String s : Yojson.Safe.json))) v
            | `Bool v ->
                ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json)))
v)) x))]                 
end and
VLOnlyConfig:sig
  type nonrec t =
    {
    view: ViewConfig.t option ;
    timeFormat: string option ;
    stack: StackOffset.t option ;
    selection: SelectionConfig.t option ;
    scale: ScaleConfig.t option ;
    numberFormat: string option ;
    invalidValues: [ `Filter ] option ;
    countTitle: string option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?countTitle:string ->
      ?invalidValues:[ `Filter ] ->
        ?numberFormat:string ->
          ?scale:ScaleConfig.t ->
            ?selection:SelectionConfig.t ->
              ?stack:StackOffset.t ->
                ?timeFormat:string ->
                  ?view:ViewConfig.t ->
                    unit -> t
  val withCountTitle : string -> t -> t
  val withInvalidValues : [ `Filter ] -> t -> t
  val withNumberFormat : string -> t -> t
  val withScale : ScaleConfig.t -> t -> t
  val withSelection :
SelectionConfig.t -> t -> t
  val withStack : StackOffset.t -> t -> t
  val withTimeFormat : string -> t -> t
  val withView : ViewConfig.t -> t -> t
end =
struct
  type nonrec t =
    {
    view: ViewConfig.t option ;
    timeFormat: string option ;
    stack: StackOffset.t option ;
    selection: SelectionConfig.t option ;
    scale: ScaleConfig.t option ;
    numberFormat: string option ;
    invalidValues: [ `Filter ] option ;
    countTitle: string option }

  (** Fields
  
    view:
      Default properties for [single view plots](spec.html#single). 
  
    timeFormat:
      Default datetime format for axis and legend labels. The format can be set directly on each axis and legend. Use [D3's time format pattern](https://github.com/d3/d3-time-format#locale_format).
      
      __Default value:__ `'%b %d, %Y'`.
  
    stack:
      Default stack offset for stackable mark. 
  
    selection:
      An object hash for defining default properties for each type of selections. 
  
    scale:
      Scale configuration determines default properties for all [scales](scale.html). For a full list of scale configuration options, please see the [corresponding section of the scale documentation](scale.html#config).
  
    numberFormat:
      D3 Number format for axis labels and text tables. For example "s" for SI units. Use [D3's number format pattern](https://github.com/d3/d3-format#locale_format).
  
    invalidValues:
      Defines how Vega-Lite should handle invalid values (`null` and `NaN`).
      - If set to `"filter"` (default), all data items with null values are filtered.
      - If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes.
  
    countTitle:
      Default axis and legend title for count fields.
      
      __Default value:__ `'Number of Records'`.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("countTitle",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (s : string)  ->
                       (`String s : Yojson.Safe.json))) v))
               x.countTitle));
         ("invalidValues",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Filter -> `String "filter"))
                    v)) x.invalidValues));
         ("numberFormat",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.numberFormat));
         ("scale",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : ScaleConfig.t)  ->
                      (ScaleConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.scale));
         ("selection",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : SelectionConfig.t)  ->
                      (SelectionConfig.to_yojson x : 
Yojson.Safe.json))) v)) x.selection));
         ("stack",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : StackOffset.t)  ->
                      (StackOffset.to_yojson x : Yojson.Safe.json)))
                    v)) x.stack));
         ("timeFormat",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.timeFormat));
         ("view",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : ViewConfig.t)  ->
                      (ViewConfig.to_yojson x : Yojson.Safe.json)))
v)) x.view))])                      
  let make ?countTitle  ?invalidValues  ?numberFormat 
    ?scale  ?selection  ?stack  ?timeFormat  ?view  () =
    {
      view;
      timeFormat;
      stack;
      selection;
      scale;
      numberFormat;
      invalidValues;
      countTitle
    } 
  let withCountTitle v x = { x with countTitle = (Some v) } 
  let withInvalidValues v x =
    { x with invalidValues = (Some v) } 
  let withNumberFormat v x =
    { x with numberFormat = (Some v) } 
  let withScale v x = { x with scale = (Some v) } 
  let withSelection v x = { x with selection = (Some v) } 
  let withStack v x = { x with stack = (Some v) } 
  let withTimeFormat v x = { x with timeFormat = (Some v) } 
  let withView v x = { x with view = (Some v) } 
end and
VConcatSpec:sig
  type nonrec t =
    {
    vconcat: Spec.t list ;
    transform: Transform.t list option ;
    title:
      [ `String of string 
      | `Params of TitleParams.t ] option ;
    resolve: Resolve.t option ;
    name: string option ;
    description: string option ;
    data: Data.t option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?data:Data.t ->
      ?description:string ->
        ?name:string ->
          ?resolve:Resolve.t ->
            ?title:[ `String of string 
                   | `Params of
TitleParams.t ]
              ->
              ?transform:Transform.t list
                ->
                vconcat:Spec.t list ->
                  unit -> t
  val withData : Data.t -> t -> t
  val withDescription : string -> t -> t
  val withName : string -> t -> t
  val withResolve : Resolve.t -> t -> t
  val withTitle :
    [ `String of string 
    | `Params of TitleParams.t ] -> 
      t -> t
  val withTransform :
Transform.t list -> t -> t
  val withVconcat : Spec.t list -> t -> t
end =
struct
  type nonrec t =
    {
    vconcat: Spec.t list ;
    transform: Transform.t list option ;
    title:
      [ `String of string  | `Params of TitleParams.t ]
        option
      ;
    resolve: Resolve.t option ;
    name: string option ;
    description: string option ;
    data: Data.t option }

  (** Fields
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    name:
      Name of the visualization for later reference.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("data",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : Data.t)  ->
                       (Data.to_yojson x : Yojson.Safe.json)))
                     v)) x.data));
         ("description",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.description));
         ("name",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.name));
         ("resolve",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Resolve.t)  ->
                      (Resolve.to_yojson x : Yojson.Safe.json)))
                    v)) x.resolve));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : TitleParams.t)  ->
                            (TitleParams.to_yojson x : 
Yojson.Safe.json))) v
                    | `String v ->
                        ((fun (s : string)  ->
                            (`String s : Yojson.Safe.json)))
                          v)) v)) x.title));
         ("transform",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : Transform.t list)  ->
                      let yojson_of_el
                        (x : Transform.t) =
                        (Transform.to_yojson x : 
Yojson.Safe.json)  in
                      (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v))
              x.transform));
         ("vconcat",
           (((fun (l : Spec.t list)  ->
                let yojson_of_el (x : Spec.t) =
                  (Spec.to_yojson x : Yojson.Safe.json)
                   in
                (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) x.vconcat))])                           
  let make ?data  ?description  ?name  ?resolve  ?title
     ?transform  ~vconcat  () =
    {
      vconcat;
      transform;
      title;
      resolve;
      name;
      description;
      data
    } 
  let withData v x = { x with data = (Some v) } 
  let withDescription v x =
    { x with description = (Some v) } 
  let withName v x = { x with name = (Some v) } 
  let withResolve v x = { x with resolve = (Some v) } 
  let withTitle v x = { x with title = (Some v) } 
  let withTransform v x =
    { x with transform = (Some v) } 
  let withVconcat v x = { x with vconcat = v } 
end and
UtcSingleTimeUnit:sig
  type t =
    [ `Utcyear  | `Utcquarter 
    | `Utcmonth  | `Utcday 
    | `Utcdate  | `Utchours 
    | `Utcminutes 
    | `Utcseconds 
    | `Utcmilliseconds ]
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Utcyear  | `Utcquarter  | `Utcmonth 
    | `Utcday  | `Utcdate  | `Utchours 
    | `Utcminutes  | `Utcseconds 
    | `Utcmilliseconds ]

  let to_yojson =
    function
    | `Utcmilliseconds ->
        `String "utcmilliseconds"
    | `Utcseconds -> `String "utcseconds"
    | `Utcminutes -> `String "utcminutes"
    | `Utchours -> `String "utchours"
    | `Utcdate -> `String "utcdate"
    | `Utcday -> `String "utcday"
    | `Utcmonth -> `String "utcmonth"
    | `Utcquarter -> `String "utcquarter"
    | `Utcyear -> `String "utcyear" 
end and
UtcMultiTimeUnit:sig
  type t =
    [ `Utcyearquarter 
    | `Utcyearquartermonth 
    | `Utcyearmonth 
    | `Utcyearmonthdate 
    | `Utcyearmonthdatehours 
    | `Utcyearmonthdatehoursminutes
         | `Utcyearmonthdatehoursminutesseconds
              | `Utcquartermonth
                   | 
      `Utcmonthdate 
    | `Utchoursminutes 
    | `Utchoursminutesseconds
         | `Utcminutesseconds
              | `Utcsecondsmilliseconds
                  ]
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Utcyearquarter 
    | `Utcyearquartermonth  | `Utcyearmonth 
    | `Utcyearmonthdate 
    | `Utcyearmonthdatehours 
    | `Utcyearmonthdatehoursminutes 
    | `Utcyearmonthdatehoursminutesseconds 
    | `Utcquartermonth  | `Utcmonthdate 
    | `Utchoursminutes 
    | `Utchoursminutesseconds 
    | `Utcminutesseconds 
    | `Utcsecondsmilliseconds ]

  let to_yojson =
    function
    | `Utcsecondsmilliseconds ->
        `String "utcsecondsmilliseconds"
    | `Utcminutesseconds ->
        `String "utcminutesseconds"
    | `Utchoursminutesseconds ->
        `String "utchoursminutesseconds"
    | `Utchoursminutes ->
        `String "utchoursminutes"
    | `Utcmonthdate -> `String "utcmonthdate"
    | `Utcquartermonth ->
        `String "utcquartermonth"
    | `Utcyearmonthdatehoursminutesseconds ->
        `String
          "utcyearmonthdatehoursminutesseconds"
    | `Utcyearmonthdatehoursminutes ->
        `String
          "utcyearmonthdatehoursminutes"
    | `Utcyearmonthdatehours ->
        `String "utcyearmonthdatehours"
    | `Utcyearmonthdate ->
        `String "utcyearmonthdate"
    | `Utcyearmonth -> `String "utcyearmonth"
    | `Utcyearquartermonth ->
        `String "utcyearquartermonth"
    | `Utcyearquarter ->
`String "utcyearquarter"                                     
end and
UrlData:sig
  type nonrec t =
    {
    url: string ;
    format: DataFormat.t option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?format:DataFormat.t ->
      url:string -> unit -> t
  val withFormat :
DataFormat.t -> t -> t
  val withUrl : string -> t -> t
end =
struct
  type nonrec t =
    {
    url: string ;
    format: DataFormat.t option }

  (** Fields
  
    url:
      An URL from which to load the data set. Use the `format.type` property
      to ensure the loaded data is correctly parsed.
  
    format:
      An object that specifies the format for parsing the data file.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("format",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun
                       (x :
DataFormat.t)
                        ->
                       (DataFormat.to_yojson
                          x : Yojson.Safe.json)))
                     v)) x.format));
         ("url",
           (((fun (s : string)  ->
                (`String s : Yojson.Safe.json)))
x.url))])                                          
  let make ?format  ~url  () =
    { url; format } 
  let withFormat v x =
    { x with format = (Some v) } 
  let withUrl v x = { x with url = v } 
end and
Type:sig
  type t =
    [ `Quantitative 
    | `Ordinal  | `Temporal 
    | `Nominal ]
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Quantitative  | `Ordinal 
    | `Temporal  | `Nominal ]

  (** Constants and utilities for data type  
   Data type based on level of measurement 
  *)
  let to_yojson =
    function
    | `Nominal -> `String "nominal"
    | `Temporal ->
        `String "temporal"
    | `Ordinal -> `String "ordinal"
    | `Quantitative ->
`String "quantitative"                                               
end and
Transform:sig
  type t =
    [
      `Filter of
FilterTransform.t
         | `Calculate
           of
CalculateTransform.t
            | 
      `Lookup of
LookupTransform.t
         | `Bin of
BinTransform.t
            | 
      `TimeUnit of
TimeUnitTransform.t
         | `Summarize
           of
SummarizeTransform.t
           ]
  val to_yojson :
    t ->
Yojson.Safe.json
end =
struct
  type t =
    [
      `Filter of
FilterTransform.t 
    | `Calculate of
CalculateTransform.t 
    | `Lookup of
LookupTransform.t 
    | `Bin of BinTransform.t 
    | `TimeUnit of
TimeUnitTransform.t 
    | `Summarize of
SummarizeTransform.t ]

  let to_yojson =
    function
    | `Summarize v ->
        ((fun
            (x :
SummarizeTransform.t)
             ->
            (SummarizeTransform.to_yojson
               x : Yojson.Safe.json)))
          v
    | `TimeUnit v ->
        ((fun
            (x :
TimeUnitTransform.t)
             ->
            (TimeUnitTransform.to_yojson
               x : Yojson.Safe.json)))
          v
    | `Bin v ->
        ((fun
            (x :
BinTransform.t)
             ->
            (BinTransform.to_yojson
               x : Yojson.Safe.json)))
          v
    | `Lookup v ->
        ((fun
            (x :
LookupTransform.t)
             ->
            (LookupTransform.to_yojson
               x : Yojson.Safe.json)))
          v
    | `Calculate v ->
        ((fun
            (x :
CalculateTransform.t)
             ->
            (CalculateTransform.to_yojson
               x : Yojson.Safe.json)))
          v
    | `Filter v ->
        ((fun
            (x :
FilterTransform.t)
             ->
            (FilterTransform.to_yojson
               x : Yojson.Safe.json)))
v                                                    
end and
TopoDataFormat:sig
 type nonrec t =
 {
 typ:
 [
 `Topojson ]
 option ;
 parse:
 [ `Auto 
 | `Json
 of
Yojson.Safe.json
 ] option ;
 mesh:
 string
 option ;
 feature:
 string
 option }
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
 val make
 :
 ?feature:string
 ->
 ?mesh:string
 ->
 ?parse:
 [ `Auto 
 | `Json
 of
Yojson.Safe.json
 ] ->
 ?typ:
 [
 `Topojson ]
 ->
 unit -> t
 val
 withFeature
 :
 string ->
 t -> t
 val
 withMesh
 :
 string ->
 t -> t
 val
 withParse
 :
 [ `Auto 
 | `Json
 of
Yojson.Safe.json
 ] ->
 t -> t
 val
 withTyp :
 [
 `Topojson ]
 -> 
 t -> t
end =
struct
  type nonrec t =
    {
    typ:
      [ `Topojson ]
        option
      ;
    parse:
      [ `Auto 
      | `Json of
Yojson.Safe.json
          ]
        option
      ;
    mesh: string option ;
    feature:
      string option }

  (** Fields
  
    type:
      Type of input data: `"json"`, `"csv"`, `"tsv"`.
      The default format type is determined by the extension of the file URL.
      If no extension is detected, `"json"` will be used by default.
  
    parse:
      If set to auto (the default), perform automatic type inference to determine the desired data types.
      Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `"number"`, `"boolean"` or `"date"`).
      For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field in each input record a Date value.
      
      For `"date"`, we parse data based using Javascript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).
      For Specific date formats can be provided (e.g., `{foo: 'date:"%m%d%Y"'}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: 'utc:"%m%d%Y"'}`). See more about [UTC time](timeunit.html#utc)
  
    mesh:
      The name of the TopoJSON object set to convert to mesh.
      Similar to the `feature` option, `mesh` extracts a named TopoJSON object set.
        Unlike the `feature` option, the corresponding geo data is returned as a single, unified mesh instance, not as individual GeoJSON features.
      Extracting a mesh is useful for more efficiently drawing borders or other geographic elements that you do not need to associate with specific regions such as individual countries, states or counties.
  
    feature:
      The name of the TopoJSON object set to convert to a GeoJSON feature collection.
      For example, in a map of the world, there may be an object set named `"countries"`.
      Using the feature property, we can extract this set and generate a GeoJSON feature object for each country.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null ->
                false
            | _ -> true)
         [("feature",
            (((function
               | 
None  ->
                `Null
               | 
Some v ->
                ((fun
                (s :
                string) 
                ->
                (`String
                s : Yojson.Safe.json)))
                v))
               x.feature));
         ("mesh",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (s :
                string) 
                ->
                (`String
                s : Yojson.Safe.json)))
                v))
              x.mesh));
         ("parse",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((function
                | `Json v
                ->
                ((fun
                (j :
Yojson.Safe.json)
                 ->
                (j : 
Yojson.Safe.json)))
                v
                | `Auto
                ->
                `String
                "auto"))
                v))
              x.parse));
         ("type",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((function
                | `Topojson
                ->
                `String
                "topojson"))
v)) x.typ))])                                                         
  let make ?feature 
    ?mesh  ?parse  ?typ 
    () =
    {
      typ;
      parse;
      mesh;
      feature
    } 
  let withFeature v x =
    {
      x with
      feature = (Some v)
    } 
  let withMesh v x =
    {
      x with
      mesh = (Some v)
    } 
  let withParse v x =
    {
      x with
      parse = (Some v)
    } 
  let withTyp v x =
    {
      x with
      typ = (Some v)
    } 
end and
TopLevelVConcatSpec:
                                                         sig
  type nonrec t =
    {
    vconcat:
Spec.t list ;
    transform:
Transform.t
        list option
      ;
    title:
      [
        `String of
          string 
      | `Params of
TitleParams.t
          ]
        option
      ;
    resolve:
Resolve.t
        option
      ;
    padding:
Padding.t
        option
      ;
    name:
      string option ;
    description:
      string option ;
    data:
Data.t option ;
    config:
Config.t
        option
      ;
    background:
      string option ;
    autoResize:
      bool option ;
    schema: string }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?autoResize:bool
      ->
      ?background:string
        ->
        ?config:Config.t
          ->
          ?data:Data.t
           ->
           ?description:string
           ->
           ?name:string
           ->
           ?padding:Padding.t
           ->
           ?resolve:Resolve.t
           ->
           ?title:
           [
           `String
           of 
           string 
           | `Params
           of
TitleParams.t
           ] ->
           ?transform:Transform.t
           list ->
           vconcat:Spec.t
           list ->
           unit -> t
  val withSchema :
    string -> t -> t
  val withAutoResize
    : bool -> t -> t
  val withBackground
    :
    string -> t -> t
  val withConfig :
Config.t ->
      t -> t
  val withData :
Data.t -> t -> t
  val
    withDescription
    :
    string -> t -> t
  val withName :
    string -> t -> t
  val withPadding :
Padding.t ->
      t -> t
  val withResolve :
Resolve.t ->
      t -> t
  val withTitle :
    [
      `String of
        string 
    | `Params of
TitleParams.t
        ]
      -> t -> t
  val withTransform
    :
Transform.t list
      -> t -> t
  val withVconcat :
Spec.t list ->
      t -> t
end =
struct
  type nonrec t =
    {
    vconcat:
Spec.t list ;
    transform:
Transform.t
        list option
      ;
    title:
      [
        `String of
          string 
      | `Params of
TitleParams.t
          ]
        option
      ;
    resolve:
Resolve.t
        option
      ;
    padding:
Padding.t
        option
      ;
    name:
      string option ;
    description:
      string option ;
    data:
Data.t option ;
    config:
Config.t
        option
      ;
    background:
      string option ;
    autoResize:
      bool option ;
    schema: string }

  (** Fields
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    padding:
      The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.
      If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
      
      __Default value__: `5`
  
    name:
      Name of the visualization for later reference.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  
    config:
      Vega-Lite configuration object.  This property can only be defined at the top-level of a specification.
  
    background:
      CSS color property to use as the background of visualization.
      
      __Default value:__ none (transparent)
  
    autoResize:
      Resize is a boolean indicating if autosize layout should be re-calculated on every update.
      
      __Default value__: `false`
  
    $schema:
      URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun 
           (k,v)  ->
           match v
           with
           | 
           `Null ->
           false
           | 
           _ -> true)
         [("$schema",
           (((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           x.schema));
         ("autoResize",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (b :
           bool)  ->
           (`Bool b : 
Yojson.Safe.json)))
           v))
           x.autoResize));
         ("background",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.background));
         ("config",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
Config.t)
            ->
           (Config.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.config));
         ("data",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
Data.t) 
           ->
           (Data.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.data));
         ("description",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.description));
         ("name",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.name));
         ("padding",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
Padding.t)
            ->
           (Padding.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.padding));
         ("resolve",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
Resolve.t)
            ->
           (Resolve.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.resolve));
         ("title",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Params
           v ->
           ((fun
           (x :
TitleParams.t)
            ->
           (TitleParams.to_yojson
           x : Yojson.Safe.json)))
           v
           | `String
           v ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v)) v))
           x.title));
         ("transform",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (l :
Transform.t
           list)  ->
           let yojson_of_el
           (x :
Transform.t)
           =
           (Transform.to_yojson
           x : 
Yojson.Safe.json)
            in
           (`List
           (List.map
           yojson_of_el
           l) : 
Yojson.Safe.json)))
           v))
           x.transform));
         ("vconcat",
           (
           ((fun
           (l :
Spec.t
           list)  ->
           let yojson_of_el
           (x :
Spec.t) =
           (Spec.to_yojson
           x : 
Yojson.Safe.json)
            in
           (`List
           (List.map
           yojson_of_el
           l) : 
Yojson.Safe.json)))
x.vconcat))])                                                              
  let make
    ?autoResize 
    ?background 
    ?config  ?data 
    ?description 
    ?name  ?padding 
    ?resolve  ?title
     ?transform 
    ~vconcat  () =
    {
      vconcat;
      schema =
        "https://vega.github.io/schema/vega-lite/v2.json";
      transform;
      title;
      resolve;
      padding;
      name;
      description;
      data;
      config;
      background;
      autoResize
    } 
  let withSchema v x
    =
    {
      x with
      schema = v
    } 
  let withAutoResize
    v x =
    {
      x with
      autoResize =
        (Some v)
    } 
  let withBackground
    v x =
    {
      x with
      background =
        (Some v)
    } 
  let withConfig v x
    =
    {
      x with
      config =
        (Some v)
    } 
  let withData v x =
    {
      x with
      data =
        (Some v)
    } 
  let withDescription
    v x =
    {
      x with
      description =
        (Some v)
    } 
  let withName v x =
    {
      x with
      name =
        (Some v)
    } 
  let withPadding v
    x =
    {
      x with
      padding =
        (Some v)
    } 
  let withResolve v
    x =
    {
      x with
      resolve =
        (Some v)
    } 
  let withTitle v x
    =
    {
      x with
      title =
        (Some v)
    } 
  let withTransform
    v x =
    {
      x with
      transform =
        (Some v)
    } 
  let withVconcat v
    x =
    {
      x with
      vconcat = v
    } 
end and
TopLevelRepeatSpec:
                                                              sig
  type nonrec t =
    {
    transform:
Transform.t
      list
      option ;
    title:
      [
      `String
      of 
      string 
      | `Params
      of
TitleParams.t
      ] option ;
    spec:
Spec.t ;
    resolve:
Resolve.t
      option ;
    repeat:
Repeat.t ;
    padding:
Padding.t
      option ;
    name:
      string
      option ;
    description:
      string
      option ;
    data:
Data.t
      option ;
    config:
Config.t
      option ;
    background:
      string
      option ;
    autoResize:
      bool
      option ;
    schema:
      string }
  val to_yojson
    :
    t ->
Yojson.Safe.json
  val make :
    ?autoResize:bool
      ->
      ?background:string
      ->
      ?config:Config.t
      ->
      ?data:Data.t
      ->
      ?description:string
      ->
      ?name:string
      ->
      ?padding:Padding.t
      ->
      ?resolve:Resolve.t
      ->
      ?title:
      [
      `String
      of 
      string 
      | `Params
      of
TitleParams.t
      ] ->
      ?transform:Transform.t
      list ->
      repeat:Repeat.t
      ->
      spec:Spec.t
      ->
      unit -> t
  val
    withSchema
    :
    string ->
      t -> t
  val
    withAutoResize
    :
    bool ->
      t -> t
  val
    withBackground
    :
    string ->
      t -> t
  val
    withConfig
    :
Config.t ->
      t -> t
  val withData
    :
Data.t ->
      t -> t
  val
    withDescription
    :
    string ->
      t -> t
  val withName
    :
    string ->
      t -> t
  val
    withPadding
    :
Padding.t
      -> 
      t -> t
  val
    withRepeat
    :
Repeat.t ->
      t -> t
  val
    withResolve
    :
Resolve.t
      -> 
      t -> t
  val withSpec
    :
Spec.t ->
      t -> t
  val withTitle
    :
    [
      `String
      of 
      string 
    | `Params
      of
TitleParams.t
      ] ->
      t -> t
  val
    withTransform
    :
Transform.t
      list ->
      t -> t
end =
struct
  type nonrec t =
    {
    transform:
Transform.t
      list
      option ;
    title:
      [
      `String
      of 
      string 
      | `Params
      of
TitleParams.t
      ] option ;
    spec:
Spec.t ;
    resolve:
Resolve.t
      option ;
    repeat:
Repeat.t ;
    padding:
Padding.t
      option ;
    name:
      string
      option ;
    description:
      string
      option ;
    data:
Data.t
      option ;
    config:
Config.t
      option ;
    background:
      string
      option ;
    autoResize:
      bool
      option ;
    schema:
      string }

  (** Fields
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    padding:
      The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.
      If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
      
      __Default value__: `5`
  
    name:
      Name of the visualization for later reference.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  
    config:
      Vega-Lite configuration object.  This property can only be defined at the top-level of a specification.
  
    background:
      CSS color property to use as the background of visualization.
      
      __Default value:__ none (transparent)
  
    autoResize:
      Resize is a boolean indicating if autosize layout should be re-calculated on every update.
      
      __Default value__: `false`
  
    $schema:
      URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
  *)
  let to_yojson
    x =
    `Assoc
      (
List.filter
      (fun
      (k,v)  ->
      match v
      with
      | 
      `Null ->
      false
      | 
      _ -> true)
      [
      ("$schema",
      (((fun
      (s :
      string) 
      ->
      (`String
      s : Yojson.Safe.json)))
      x.schema));
      ("autoResize",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (b :
      bool)  ->
      (`Bool b : 
Yojson.Safe.json)))
      v))
      x.autoResize));
      ("background",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (s :
      string) 
      ->
      (`String
      s : Yojson.Safe.json)))
      v))
      x.background));
      ("config",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
Config.t)
       ->
      (Config.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.config));
      ("data",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
Data.t) 
      ->
      (Data.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.data));
      ("description",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (s :
      string) 
      ->
      (`String
      s : Yojson.Safe.json)))
      v))
      x.description));
      ("name",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (s :
      string) 
      ->
      (`String
      s : Yojson.Safe.json)))
      v))
      x.name));
      ("padding",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
Padding.t)
       ->
      (Padding.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.padding));
      ("repeat",
      (((fun
      (x :
Repeat.t)
       ->
      (Repeat.to_yojson
      x : Yojson.Safe.json)))
      x.repeat));
      ("resolve",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
Resolve.t)
       ->
      (Resolve.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.resolve));
      ("spec",
      (((fun
      (x :
Spec.t) 
      ->
      (Spec.to_yojson
      x : Yojson.Safe.json)))
      x.spec));
      ("title",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((function
      | `Params
      v ->
      ((fun
      (x :
TitleParams.t)
       ->
      (TitleParams.to_yojson
      x : Yojson.Safe.json)))
      v
      | `String
      v ->
      ((fun
      (s :
      string) 
      ->
      (`String
      s : Yojson.Safe.json)))
      v)) v))
      x.title));
      ("transform",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (l :
Transform.t
      list)  ->
      let yojson_of_el
      (x :
Transform.t)
      =
      (Transform.to_yojson
      x : 
Yojson.Safe.json)
       in
      (`List
      (List.map
      yojson_of_el
      l) : 
Yojson.Safe.json)))
      v))
x.transform))])                                                                   
  let make
    ?autoResize
     ?background
     ?config 
    ?data 
    ?description
     ?name 
    ?padding 
    ?resolve 
    ?title 
    ?transform 
    ~repeat 
    ~spec  () =
    {
      spec;
      repeat;
      schema =
      "https://vega.github.io/schema/vega-lite/v2.json";
      transform;
      title;
      resolve;
      padding;
      name;
      description;
      data;
      config;
      background;
      autoResize
    } 
  let withSchema
    v x =
    {
      x with
      schema =
      v
    } 
  let withAutoResize
    v x =
    {
      x with
      autoResize
      =
      (Some v)
    } 
  let withBackground
    v x =
    {
      x with
      background
      =
      (Some v)
    } 
  let withConfig
    v x =
    {
      x with
      config =
      (Some v)
    } 
  let withData
    v x =
    {
      x with
      data =
      (Some v)
    } 
  let withDescription
    v x =
    {
      x with
      description
      =
      (Some v)
    } 
  let withName
    v x =
    {
      x with
      name =
      (Some v)
    } 
  let withPadding
    v x =
    {
      x with
      padding =
      (Some v)
    } 
  let withRepeat
    v x =
    {
      x with
      repeat =
      v
    } 
  let withResolve
    v x =
    {
      x with
      resolve =
      (Some v)
    } 
  let withSpec
    v x =
    {
      x with
      spec = v
    } 
  let withTitle
    v x =
    {
      x with
      title =
      (Some v)
    } 
  let withTransform
    v x =
    {
      x with
      transform
      =
      (Some v)
    } 
end and
TopLevelProperties:
                                                                   sig
 type nonrec t =
 {
 padding:
Padding.t
 option ;
 background:
 string
 option ;
 autoResize:
 bool
 option }
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
 val make
 :
 ?autoResize:bool
 ->
 ?background:string
 ->
 ?padding:Padding.t
 ->
 unit -> t
 val
 withAutoResize
 :
 bool ->
 t -> t
 val
 withBackground
 :
 string ->
 t -> t
 val
 withPadding
 :
Padding.t
 -> 
 t -> t
end =
struct
 type nonrec t =
 {
 padding:
Padding.t
 option ;
 background:
 string
 option ;
 autoResize:
 bool
 option }

  (** Fields
  
    padding:
      The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.
      If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
      
      __Default value__: `5`
  
    background:
      CSS color property to use as the background of visualization.
      
      __Default value:__ none (transparent)
  
    autoResize:
      Resize is a boolean indicating if autosize layout should be re-calculated on every update.
      
      __Default value__: `false`
  *)
 let to_yojson
 x =
 `Assoc
 (List.filter
 (fun
 (k,v)  ->
 match v
 with
 | 
 `Null ->
 false
 | 
 _ -> true)
 [
 ("autoResize",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.autoResize));
 ("background",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.background));
 ("padding",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
Padding.t)
  ->
 (Padding.to_yojson
 x : Yojson.Safe.json)))
 v))
x.padding))])                                                                     
 let make
 ?autoResize
  ?background
  ?padding
  () =
 {
 padding;
 background;
 autoResize
 } 
 let withAutoResize
 v x =
 {
 x with
 autoResize
 =
 (Some v)
 } 
 let withBackground
 v x =
 {
 x with
 background
 =
 (Some v)
 } 
 let withPadding
 v x =
 {
 x with
 padding =
 (Some v)
 } 
end
and
TopLevelLayerSpec:sig
  type nonrec t =
    {
    width: [ `Int of int  | `Float of float ] option ;
    transform: Transform.t list option ;
    title:
      [ `String of string  | `Params of TitleParams.t ]
        option
      ;
    resolve: Resolve.t option ;
    padding: Padding.t option ;
    name: string option ;
    layer:
      [ `Unit of CompositeUnitSpec.t 
      | `Layer of LayerSpec.t ] list ;
    height: [ `Int of int  | `Float of float ] option ;
    description: string option ;
    data: Data.t option ;
    config: Config.t option ;
    background: string option ;
    autoResize: bool option ;
    schema: string }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?autoResize:bool ->
      ?background:string ->
        ?config:Config.t ->
          ?data:Data.t ->
            ?description:string ->
              ?height:[ `Int of int  | `Float of float ]
                ->
                ?name:string ->
                  ?padding:Padding.t ->
                    ?resolve:Resolve.t ->
                      ?title:[ `String of string 
                             | `Params of TitleParams.t ]
                        ->
                        ?transform:Transform.t list ->
                          ?width:[ `Int of int 
                                 | `Float of float ]
                            ->
                            layer:[
                                    `Unit of
CompositeUnitSpec.t 
                                  | `Layer of LayerSpec.t ]
                              list -> unit -> t
  val withSchema : string -> t -> t
  val withAutoResize : bool -> t -> t
  val withBackground : string -> t -> t
  val withConfig : Config.t -> t -> t
  val withData : Data.t -> t -> t
  val withDescription : string -> t -> t
  val withHeight :
    [ `Int of int  | `Float of float ] -> t -> t
  val withLayer :
    [ `Unit of CompositeUnitSpec.t 
    | `Layer of LayerSpec.t ] list -> t -> t
  val withName : string -> t -> t
  val withPadding : Padding.t -> t -> t
  val withResolve : Resolve.t -> t -> t
  val withTitle :
    [ `String of string  | `Params of TitleParams.t ] ->
      t -> t
  val withTransform : Transform.t list -> t -> t
  val withWidth :
    [ `Int of int  | `Float of float ] -> t -> t
end =
struct
  type nonrec t =
    {
    width: [ `Int of int  | `Float of float ] option ;
    transform: Transform.t list option ;
    title: [ `String of string  | `Params of TitleParams.t ] option ;
    resolve: Resolve.t option ;
    padding: Padding.t option ;
    name: string option ;
    layer: [ `Unit of CompositeUnitSpec.t  | `Layer of LayerSpec.t ] list ;
    height: [ `Int of int  | `Float of float ] option ;
    description: string option ;
    data: Data.t option ;
    config: Config.t option ;
    background: string option ;
    autoResize: bool option ;
    schema: string }

  (** Fields
  
    width:
      The width of a visualization.
      
      __Default value:__ This will be determined by the following rules:
      
      - For x-axis with a continuous (non-ordinal) scale, the width will be the value of [`config.view.width`](spec.html#config).
      - For x-axis with an ordinal scale: if [`rangeStep`](scale.html#ordinal) is a numeric value (default), the width is determined by the value of `rangeStep` and the cardinality of the field mapped to x-channel.   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](spec.html#config).
      - If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.
      
      __Note:__ For plot with `row` and `column` channels, this represents the width of a single view.
      
      __See also:__ The documentation for [width and height](size.html) contains more examples.
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    padding:
      The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.
      If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
      
      __Default value__: `5`
  
    name:
      Name of the visualization for later reference.
  
    layer:
      Layer or single view specifications to be layered.
      
      __Note__: Specifications inside `layer` cannot use `row` and `column` channels as layering facet specifications is not allowed.
  
    height:
      The height of a visualization.
      
      __Default value:__
      - For y-axis with a continuous (non-ordinal) scale, the height will be the value of [`config.view.height`](spec.html#config).
      - For y-axis with an ordinal scale: if [`rangeStep`](scale.html#ordinal) is a numeric value (default), the height is determined by the value of `rangeStep` and the cardinality of the field mapped to y-channel.   Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](spec.html#config).
      - If no field is mapped to `x` channel, the `height` will be the value of `rangeStep`.
      
      __Note__: For plot with `row` and `column` channels, this represents the height of a single view.
      
      __See also:__ The documentation for [width and height](size.html) contains more examples.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  
    config:
      Vega-Lite configuration object.  This property can only be defined at the top-level of a specification.
  
    background:
      CSS color property to use as the background of visualization.
      
      __Default value:__ none (transparent)
  
    autoResize:
      Resize is a boolean indicating if autosize layout should be re-calculated on every update.
      
      __Default value__: `false`
  
    $schema:
      URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("$schema",
            (((fun (s : string)  -> (`String s : Yojson.Safe.json)))
               x.schema));
         ("autoResize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) v))
              x.autoResize));
         ("background",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  -> (`String s : Yojson.Safe.json))) v))
              x.background));
         ("config",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Config.t)  ->
                      (Config.to_yojson x : Yojson.Safe.json))) v))
              x.config));
         ("data",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Data.t)  ->
                      (Data.to_yojson x : Yojson.Safe.json))) v)) x.data));
         ("description",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  -> (`String s : Yojson.Safe.json))) v))
              x.description));
         ("height",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.height));
         ("layer",
           (((fun
                (l :
                  [ `Unit of CompositeUnitSpec.t  | `Layer of LayerSpec.t ]
                    list)
                 ->
                let yojson_of_el =
                  function
                  | `Layer v ->
                      ((fun (x : LayerSpec.t)  ->
                          (LayerSpec.to_yojson x : Yojson.Safe.json))) v
                  | `Unit v ->
                      ((fun (x : CompositeUnitSpec.t)  ->
                          (CompositeUnitSpec.to_yojson x : Yojson.Safe.json)))
                        v
                   in
                (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
              x.layer));
         ("name",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  -> (`String s : Yojson.Safe.json))) v))
              x.name));
         ("padding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Padding.t)  ->
                      (Padding.to_yojson x : Yojson.Safe.json))) v))
              x.padding));
         ("resolve",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Resolve.t)  ->
                      (Resolve.to_yojson x : Yojson.Safe.json))) v))
              x.resolve));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : TitleParams.t)  ->
                            (TitleParams.to_yojson x : Yojson.Safe.json)))
                          v
                    | `String v ->
                        ((fun (s : string)  ->
                            (`String s : Yojson.Safe.json))) v)) v))
              x.title));
         ("transform",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : Transform.t list)  ->
                      let yojson_of_el (x : Transform.t) =
                        (Transform.to_yojson x : Yojson.Safe.json)  in
                      (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
                    v)) x.transform));
         ("width",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
x.width))])       
  let make ?autoResize  ?background  ?config  ?data  ?description  ?height 
    ?name  ?padding  ?resolve  ?title  ?transform  ?width  ~layer  () =
    {
      layer;
      schema = "https://vega.github.io/schema/vega-lite/v2.json";
      width;
      transform;
      title;
      resolve;
      padding;
      name;
      height;
      description;
      data;
      config;
      background;
      autoResize
    } 
  let withSchema v x = { x with schema = v } 
  let withAutoResize v x = { x with autoResize = (Some v) } 
  let withBackground v x = { x with background = (Some v) } 
  let withConfig v x = { x with config = (Some v) } 
  let withData v x = { x with data = (Some v) } 
  let withDescription v x = { x with description = (Some v) } 
  let withHeight v x = { x with height = (Some v) } 
  let withLayer v x = { x with layer = v } 
  let withName v x = { x with name = (Some v) } 
  let withPadding v x = { x with padding = (Some v) } 
  let withResolve v x = { x with resolve = (Some v) } 
  let withTitle v x = { x with title = (Some v) } 
  let withTransform v x = { x with transform = (Some v) } 
  let withWidth v x = { x with width = (Some v) } 
end and
TopLevelHConcatSpec:sig
  type nonrec t =
    {
    transform: Transform.t list option ;
    title:
      [ `String of string 
      | `Params of TitleParams.t ] option ;
    resolve: Resolve.t option ;
    padding: Padding.t option ;
    name: string option ;
    hconcat: Spec.t list ;
    description: string option ;
    data: Data.t option ;
    config: Config.t option ;
    background: string option ;
    autoResize: bool option ;
    schema: string }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?autoResize:bool ->
      ?background:string ->
        ?config:Config.t ->
          ?data:Data.t ->
            ?description:string ->
              ?name:string ->
                ?padding:Padding.t ->
                  ?resolve:Resolve.t ->
                    ?title:[ `String of string 
                           | `Params of
TitleParams.t ]
                      ->
                      ?transform:Transform.t list
                        ->
                        hconcat:Spec.t list ->
                          unit -> t
  val withSchema : string -> t -> t
  val withAutoResize : bool -> t -> t
  val withBackground : string -> t -> t
  val withConfig : Config.t -> t -> t
  val withData : Data.t -> t -> t
  val withDescription : string -> t -> t
  val withHconcat : Spec.t list -> t -> t
  val withName : string -> t -> t
  val withPadding : Padding.t -> t -> t
  val withResolve : Resolve.t -> t -> t
  val withTitle :
    [ `String of string 
    | `Params of TitleParams.t ] -> t -> t
  val withTransform : Transform.t list -> t -> t
end =
struct
  type nonrec t =
    {
    transform: Transform.t list option ;
    title: [ `String of string  | `Params of TitleParams.t ] option ;
    resolve: Resolve.t option ;
    padding: Padding.t option ;
    name: string option ;
    hconcat: Spec.t list ;
    description: string option ;
    data: Data.t option ;
    config: Config.t option ;
    background: string option ;
    autoResize: bool option ;
    schema: string }

  (** Fields
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    padding:
      The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.
      If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
      
      __Default value__: `5`
  
    name:
      Name of the visualization for later reference.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  
    config:
      Vega-Lite configuration object.  This property can only be defined at the top-level of a specification.
  
    background:
      CSS color property to use as the background of visualization.
      
      __Default value:__ none (transparent)
  
    autoResize:
      Resize is a boolean indicating if autosize layout should be re-calculated on every update.
      
      __Default value__: `false`
  
    $schema:
      URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("$schema",
            (((fun (s : string)  -> (`String s : Yojson.Safe.json)))
               x.schema));
         ("autoResize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json)))
                    v)) x.autoResize));
         ("background",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.background));
         ("config",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Config.t)  ->
                      (Config.to_yojson x : Yojson.Safe.json))) v))
              x.config));
         ("data",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Data.t)  ->
                      (Data.to_yojson x : Yojson.Safe.json))) v))
              x.data));
         ("description",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.description));
         ("hconcat",
           (((fun (l : Spec.t list)  ->
                let yojson_of_el (x : Spec.t) =
                  (Spec.to_yojson x : Yojson.Safe.json)  in
                (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
              x.hconcat));
         ("name",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v)) x.name));
         ("padding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Padding.t)  ->
                      (Padding.to_yojson x : Yojson.Safe.json))) v))
              x.padding));
         ("resolve",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Resolve.t)  ->
                      (Resolve.to_yojson x : Yojson.Safe.json))) v))
              x.resolve));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : TitleParams.t)  ->
                            (TitleParams.to_yojson x : Yojson.Safe.json)))
                          v
                    | `String v ->
                        ((fun (s : string)  ->
                            (`String s : Yojson.Safe.json))) v)) v))
              x.title));
         ("transform",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : Transform.t list)  ->
                      let yojson_of_el (x : Transform.t) =
                        (Transform.to_yojson x : Yojson.Safe.json)  in
                      (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
v)) x.transform))])            
  let make ?autoResize  ?background  ?config  ?data  ?description 
    ?name  ?padding  ?resolve  ?title  ?transform  ~hconcat  () =
    {
      hconcat;
      schema = "https://vega.github.io/schema/vega-lite/v2.json";
      transform;
      title;
      resolve;
      padding;
      name;
      description;
      data;
      config;
      background;
      autoResize
    } 
  let withSchema v x = { x with schema = v } 
  let withAutoResize v x = { x with autoResize = (Some v) } 
  let withBackground v x = { x with background = (Some v) } 
  let withConfig v x = { x with config = (Some v) } 
  let withData v x = { x with data = (Some v) } 
  let withDescription v x = { x with description = (Some v) } 
  let withHconcat v x = { x with hconcat = v } 
  let withName v x = { x with name = (Some v) } 
  let withPadding v x = { x with padding = (Some v) } 
  let withResolve v x = { x with resolve = (Some v) } 
  let withTitle v x = { x with title = (Some v) } 
  let withTransform v x = { x with transform = (Some v) } 
end and
TopLevelFacetedUnitSpec_Selection:sig
  type nonrec t =
    (string * SelectionDef.t)
      list
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type nonrec t = (string * SelectionDef.t) list

  let to_yojson x =
    let mapper (k,v) =
      (k,
        ((fun (x : SelectionDef.t)  ->
            (SelectionDef.to_yojson x : Yojson.Safe.json)) v))
       in
    `Assoc (List.map mapper x) 
end and
TopLevelFacetedUnitSpec:sig
  type nonrec t =
    {
    width:
      [ `Int of int 
      | `Float of float ] option ;
    transform:
Transform.t list option ;
    title:
      [ `String of string 
      | `Params of TitleParams.t ]
        option
      ;
    selection:
TopLevelFacetedUnitSpec_Selection.t
        option
      ;
    padding: Padding.t option ;
    name: string option ;
    mark: AnyMark.t ;
    height:
      [ `Int of int 
      | `Float of float ] option ;
    encoding: EncodingWithFacet.t ;
    description: string option ;
    data: Data.t option ;
    config: Config.t option ;
    background: string option ;
    autoResize: bool option ;
    schema: string }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?autoResize:bool ->
      ?background:string ->
        ?config:Config.t ->
          ?data:Data.t ->
            ?description:string ->
              ?height:[ `Int of int 
                      | `Float of
                          float ]
                ->
                ?name:string ->
                  ?padding:Padding.t
                    ->
                    ?selection:TopLevelFacetedUnitSpec_Selection.t
                      ->
                      ?title:
                        [
                          `String of
                           string 
                        | `Params of
TitleParams.t
                           ]
                        ->
                        ?transform:Transform.t
                          list ->
                          ?width:
                           [
                           `Int of
                           int 
                           | `Float
                           of float ]
                           ->
                           encoding:EncodingWithFacet.t
                           ->
                           mark:AnyMark.t
                           ->
                           unit -> t
  val withSchema : string -> t -> t
  val withAutoResize :
    bool -> t -> t
  val withBackground :
    string -> t -> t
  val withConfig :
Config.t -> t -> t
  val withData : Data.t -> t -> t
  val withDescription :
    string -> t -> t
  val withEncoding :
EncodingWithFacet.t -> t -> t
  val withHeight :
    [ `Int of int 
    | `Float of float ] -> t -> t
  val withMark : AnyMark.t -> t -> t
  val withName : string -> t -> t
  val withPadding :
Padding.t -> t -> t
  val withSelection :
TopLevelFacetedUnitSpec_Selection.t
      -> t -> t
  val withTitle :
    [ `String of string 
    | `Params of TitleParams.t ] ->
      t -> t
  val withTransform :
Transform.t list -> t -> t
  val withWidth :
    [ `Int of int 
    | `Float of float ] -> t -> t
end =
struct
  type nonrec t =
    {
    width: [ `Int of int  | `Float of float ] option ;
    transform: Transform.t list option ;
    title:
      [ `String of string  | `Params of TitleParams.t ]
        option
      ;
    selection: TopLevelFacetedUnitSpec_Selection.t option ;
    padding: Padding.t option ;
    name: string option ;
    mark: AnyMark.t ;
    height: [ `Int of int  | `Float of float ] option ;
    encoding: EncodingWithFacet.t ;
    description: string option ;
    data: Data.t option ;
    config: Config.t option ;
    background: string option ;
    autoResize: bool option ;
    schema: string }

  (** Fields
  
    width:
      The width of a visualization.
      
      __Default value:__ This will be determined by the following rules:
      
      - For x-axis with a continuous (non-ordinal) scale, the width will be the value of [`config.view.width`](spec.html#config).
      - For x-axis with an ordinal scale: if [`rangeStep`](scale.html#ordinal) is a numeric value (default), the width is determined by the value of `rangeStep` and the cardinality of the field mapped to x-channel.   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](spec.html#config).
      - If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.
      
      __Note:__ For plot with `row` and `column` channels, this represents the width of a single view.
      
      __See also:__ The documentation for [width and height](size.html) contains more examples.
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    selection:
      A key-value mapping between selection names and definitions.
  
    padding:
      The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.
      If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
      
      __Default value__: `5`
  
    name:
      Name of the visualization for later reference.
  
    mark:
      A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`,
      `"area"`, `"point"`, `"rule"`, and `"text"`) or a [mark definition object](mark.html#mark-def).
  
    height:
      The height of a visualization.
      
      __Default value:__
      - For y-axis with a continuous (non-ordinal) scale, the height will be the value of [`config.view.height`](spec.html#config).
      - For y-axis with an ordinal scale: if [`rangeStep`](scale.html#ordinal) is a numeric value (default), the height is determined by the value of `rangeStep` and the cardinality of the field mapped to y-channel.   Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](spec.html#config).
      - If no field is mapped to `x` channel, the `height` will be the value of `rangeStep`.
      
      __Note__: For plot with `row` and `column` channels, this represents the height of a single view.
      
      __See also:__ The documentation for [width and height](size.html) contains more examples.
  
    encoding:
      A key-value mapping between encoding channels and definition of fields.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  
    config:
      Vega-Lite configuration object.  This property can only be defined at the top-level of a specification.
  
    background:
      CSS color property to use as the background of visualization.
      
      __Default value:__ none (transparent)
  
    autoResize:
      Resize is a boolean indicating if autosize layout should be re-calculated on every update.
      
      __Default value__: `false`
  
    $schema:
      URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("$schema",
            (((fun (s : string)  ->
                 (`String s : Yojson.Safe.json))) x.schema));
         ("autoResize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  ->
                      (`Bool b : Yojson.Safe.json))) v))
              x.autoResize));
         ("background",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.background));
         ("config",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Config.t)  ->
                      (Config.to_yojson x : Yojson.Safe.json)))
                    v)) x.config));
         ("data",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Data.t)  ->
                      (Data.to_yojson x : Yojson.Safe.json)))
                    v)) x.data));
         ("description",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.description));
         ("encoding",
           (((fun (x : EncodingWithFacet.t)  ->
                (EncodingWithFacet.to_yojson x : Yojson.Safe.json)))
              x.encoding));
         ("height",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v)) x.height));
         ("mark",
           (((fun (x : AnyMark.t)  ->
                (AnyMark.to_yojson x : Yojson.Safe.json)))
              x.mark));
         ("name",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.name));
         ("padding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Padding.t)  ->
                      (Padding.to_yojson x : Yojson.Safe.json)))
                    v)) x.padding));
         ("selection",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
TopLevelFacetedUnitSpec_Selection.t)
                       ->
                      (TopLevelFacetedUnitSpec_Selection.to_yojson
                         x : Yojson.Safe.json))) v))
              x.selection));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : TitleParams.t)  ->
                            (TitleParams.to_yojson x : 
Yojson.Safe.json))) v
                    | `String v ->
                        ((fun (s : string)  ->
                            (`String s : Yojson.Safe.json)))
                          v)) v)) x.title));
         ("transform",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : Transform.t list)  ->
                      let yojson_of_el (x : Transform.t) =
                        (Transform.to_yojson x : Yojson.Safe.json)
                         in
                      (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v)) x.transform));
         ("width",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
| `Float f -> `Float f)) v)) x.width))])                      
  let make ?autoResize  ?background  ?config  ?data 
    ?description  ?height  ?name  ?padding  ?selection 
    ?title  ?transform  ?width  ~encoding  ~mark  () =
    {
      mark;
      encoding;
      schema =
        "https://vega.github.io/schema/vega-lite/v2.json";
      width;
      transform;
      title;
      selection;
      padding;
      name;
      height;
      description;
      data;
      config;
      background;
      autoResize
    } 
  let withSchema v x = { x with schema = v } 
  let withAutoResize v x = { x with autoResize = (Some v) } 
  let withBackground v x = { x with background = (Some v) } 
  let withConfig v x = { x with config = (Some v) } 
  let withData v x = { x with data = (Some v) } 
  let withDescription v x =
    { x with description = (Some v) } 
  let withEncoding v x = { x with encoding = v } 
  let withHeight v x = { x with height = (Some v) } 
  let withMark v x = { x with mark = v } 
  let withName v x = { x with name = (Some v) } 
  let withPadding v x = { x with padding = (Some v) } 
  let withSelection v x = { x with selection = (Some v) } 
  let withTitle v x = { x with title = (Some v) } 
  let withTransform v x = { x with transform = (Some v) } 
  let withWidth v x = { x with width = (Some v) } 
end and
TopLevelFacetedSpec:sig
  type nonrec t =
    {
    transform:
Transform.t list option ;
    title:
      [ `String of string 
      | `Params of TitleParams.t ]
        option
      ;
    spec:
      [ `Layer of LayerSpec.t 
      | `Unit of
CompositeUnitSpec.t ]
      ;
    resolve: Resolve.t option ;
    padding: Padding.t option ;
    name: string option ;
    facet: Facet.t ;
    description: string option ;
    data: Data.t option ;
    config: Config.t option ;
    background: string option ;
    autoResize: bool option ;
    schema: string }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?autoResize:bool ->
      ?background:string ->
        ?config:Config.t ->
          ?data:Data.t ->
            ?description:string ->
              ?name:string ->
                ?padding:Padding.t
                  ->
                  ?resolve:Resolve.t
                    ->
                    ?title:
                      [
                        `String of
                          string 
                      | `Params of
TitleParams.t
                          ]
                      ->
                      ?transform:Transform.t
                        list ->
                        facet:Facet.t
                          ->
                          spec:
                          [
                          `Layer of
LayerSpec.t
                           | 
                          `Unit of
CompositeUnitSpec.t
                          ] ->
                          unit -> t
  val withSchema : string -> t -> t
  val withAutoResize :
    bool -> t -> t
  val withBackground :
    string -> t -> t
  val withConfig :
Config.t -> t -> t
  val withData : Data.t -> t -> t
  val withDescription :
    string -> t -> t
  val withFacet : Facet.t -> t -> t
  val withName : string -> t -> t
  val withPadding :
Padding.t -> t -> t
  val withResolve :
Resolve.t -> t -> t
  val withSpec :
    [ `Layer of LayerSpec.t 
    | `Unit of CompositeUnitSpec.t ]
      -> t -> t
  val withTitle :
    [ `String of string 
    | `Params of TitleParams.t ] ->
      t -> t
  val withTransform :
Transform.t list -> t -> t
end =
struct
  type nonrec t =
    {
    transform: Transform.t list option ;
    title:
      [ `String of string  | `Params of TitleParams.t ]
        option
      ;
    spec:
      [ `Layer of LayerSpec.t 
      | `Unit of CompositeUnitSpec.t ] ;
    resolve: Resolve.t option ;
    padding: Padding.t option ;
    name: string option ;
    facet: Facet.t ;
    description: string option ;
    data: Data.t option ;
    config: Config.t option ;
    background: string option ;
    autoResize: bool option ;
    schema: string }

  (** Fields
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    padding:
      The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.
      If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
      
      __Default value__: `5`
  
    name:
      Name of the visualization for later reference.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  
    config:
      Vega-Lite configuration object.  This property can only be defined at the top-level of a specification.
  
    background:
      CSS color property to use as the background of visualization.
      
      __Default value:__ none (transparent)
  
    autoResize:
      Resize is a boolean indicating if autosize layout should be re-calculated on every update.
      
      __Default value__: `false`
  
    $schema:
      URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("$schema",
            (((fun (s : string)  ->
                 (`String s : Yojson.Safe.json)))
               x.schema));
         ("autoResize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  ->
                      (`Bool b : Yojson.Safe.json))) v))
              x.autoResize));
         ("background",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.background));
         ("config",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Config.t)  ->
                      (Config.to_yojson x : Yojson.Safe.json)))
                    v)) x.config));
         ("data",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Data.t)  ->
                      (Data.to_yojson x : Yojson.Safe.json)))
                    v)) x.data));
         ("description",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.description));
         ("facet",
           (((fun (x : Facet.t)  ->
                (Facet.to_yojson x : Yojson.Safe.json)))
              x.facet));
         ("name",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.name));
         ("padding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Padding.t)  ->
                      (Padding.to_yojson x : Yojson.Safe.json)))
                    v)) x.padding));
         ("resolve",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Resolve.t)  ->
                      (Resolve.to_yojson x : Yojson.Safe.json)))
                    v)) x.resolve));
         ("spec",
           (((function
              | `Unit v ->
                  ((fun (x : CompositeUnitSpec.t)  ->
                      (CompositeUnitSpec.to_yojson x : 
Yojson.Safe.json))) v
              | `Layer v ->
                  ((fun (x : LayerSpec.t)  ->
                      (LayerSpec.to_yojson x : 
Yojson.Safe.json))) v)) x.spec));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : TitleParams.t)  ->
                            (TitleParams.to_yojson x : 
Yojson.Safe.json))) v
                    | `String v ->
                        ((fun (s : string)  ->
                            (`String s : Yojson.Safe.json)))
                          v)) v)) x.title));
         ("transform",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : Transform.t list)  ->
                      let yojson_of_el
                        (x : Transform.t) =
                        (Transform.to_yojson x : 
Yojson.Safe.json)  in
                      (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v))
x.transform))])                           
  let make ?autoResize  ?background  ?config  ?data 
    ?description  ?name  ?padding  ?resolve  ?title 
    ?transform  ~facet  ~spec  () =
    {
      spec;
      facet;
      schema =
        "https://vega.github.io/schema/vega-lite/v2.json";
      transform;
      title;
      resolve;
      padding;
      name;
      description;
      data;
      config;
      background;
      autoResize
    } 
  let withSchema v x = { x with schema = v } 
  let withAutoResize v x =
    { x with autoResize = (Some v) } 
  let withBackground v x =
    { x with background = (Some v) } 
  let withConfig v x = { x with config = (Some v) } 
  let withData v x = { x with data = (Some v) } 
  let withDescription v x =
    { x with description = (Some v) } 
  let withFacet v x = { x with facet = v } 
  let withName v x = { x with name = (Some v) } 
  let withPadding v x = { x with padding = (Some v) } 
  let withResolve v x = { x with resolve = (Some v) } 
  let withSpec v x = { x with spec = v } 
  let withTitle v x = { x with title = (Some v) } 
  let withTransform v x =
    { x with transform = (Some v) } 
end and
TopLevelExtendedSpec:sig
  type t =
    [
      `Unit of
TopLevelFacetedUnitSpec.t
         | `Layer of
TopLevelLayerSpec.t
              | `Faceted of
TopLevelFacetedSpec.t
                   | 
      `Repeat of
TopLevelRepeatSpec.t 
    | `VConcat of
TopLevelVConcatSpec.t 
    | `HConcat of
TopLevelHConcatSpec.t ]
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Unit of TopLevelFacetedUnitSpec.t 
    | `Layer of TopLevelLayerSpec.t 
    | `Faceted of TopLevelFacetedSpec.t 
    | `Repeat of TopLevelRepeatSpec.t 
    | `VConcat of TopLevelVConcatSpec.t 
    | `HConcat of TopLevelHConcatSpec.t ]

  let to_yojson =
    function
    | `HConcat v ->
        ((fun (x : TopLevelHConcatSpec.t)  ->
            (TopLevelHConcatSpec.to_yojson x : 
Yojson.Safe.json))) v
    | `VConcat v ->
        ((fun (x : TopLevelVConcatSpec.t)  ->
            (TopLevelVConcatSpec.to_yojson x : 
Yojson.Safe.json))) v
    | `Repeat v ->
        ((fun (x : TopLevelRepeatSpec.t)  ->
            (TopLevelRepeatSpec.to_yojson x : 
Yojson.Safe.json))) v
    | `Faceted v ->
        ((fun (x : TopLevelFacetedSpec.t)  ->
            (TopLevelFacetedSpec.to_yojson x : 
Yojson.Safe.json))) v
    | `Layer v ->
        ((fun (x : TopLevelLayerSpec.t)  ->
            (TopLevelLayerSpec.to_yojson x : 
Yojson.Safe.json))) v
    | `Unit v ->
        ((fun (x : TopLevelFacetedUnitSpec.t)  ->
            (TopLevelFacetedUnitSpec.to_yojson x : 
Yojson.Safe.json))) v                                
end and
TitleParams:sig
  type nonrec t =
    {
    text: string ;
    style:
      [ `String of string 
      | `Strings of string list ]
        option
      ;
    orient: TitleOrient.t option ;
    offset:
      [ `Int of int 
      | `Float of float ] option ;
    anchor: Anchor.t option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?anchor:Anchor.t ->
      ?offset:[ `Int of int 
              | `Float of float ]
        ->
        ?orient:TitleOrient.t ->
          ?style:[
                   `String of
                     string 
                 | `Strings of
                     string list ]
            ->
            text:string ->
              unit -> t
  val withAnchor :
Anchor.t -> t -> t
  val withOffset :
    [ `Int of int 
    | `Float of float ] -> 
      t -> t
  val withOrient :
TitleOrient.t -> t -> t
  val withStyle :
    [ `String of string 
    | `Strings of string list ]
      -> t -> t
  val withText : string -> t -> t
end =
struct
  type nonrec t =
    {
    text: string ;
    style:
      [ `String of string 
      | `Strings of string list ] option ;
    orient: TitleOrient.t option ;
    offset:
      [ `Int of int  | `Float of float ]
        option
      ;
    anchor: Anchor.t option }

  (** Fields
  
    text:
      The title text.
  
    style:
      A [mark style property](config.html#style) to apply to the title text mark.
      
      __Default value:__ `"group-title"`.
  
    orient:
      The orientation of the title relative to the chart. One of `"top"` (the default), `"bottom"`, `"left"`, or `"right"`.
  
    offset:
      The orthogonal offset in pixels by which to displace the title from its position along the edge of the chart.
  
    anchor:
      The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.
      
      __Default value:__ `"middle"` for [single](spec.html) and [layered](layer.html) views.
      `"start"` for other composite views.
      
      __Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only customizable only for [single](spec.html) and [layered](layer.html) views.  For other composite views, `anchor` is always `"start"`.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("anchor",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : Anchor.t)  ->
                       (Anchor.to_yojson x : 
Yojson.Safe.json))) v))
               x.anchor));
         ("offset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.offset));
         ("orient",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : TitleOrient.t) 
                      ->
                      (TitleOrient.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.orient));
         ("style",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Strings v ->
                        ((fun
                            (l : string list)
                             ->
                            let yojson_of_el
                              (s : string) =
                              (`String s : 
Yojson.Safe.json)
                               in
                            (`List
                               (List.map
                                  yojson_of_el
                                  l) : 
Yojson.Safe.json)))
                          v
                    | `String v ->
                        ((fun (s : string) 
                            ->
                            (`String s : 
Yojson.Safe.json)))
                          v)) v)) x.style));
         ("text",
           (((fun (s : string)  ->
                (`String s : Yojson.Safe.json)))
x.text))])                                     
  let make ?anchor  ?offset  ?orient  ?style 
    ~text  () =
    { text; style; orient; offset; anchor } 
  let withAnchor v x =
    { x with anchor = (Some v) } 
  let withOffset v x =
    { x with offset = (Some v) } 
  let withOrient v x =
    { x with orient = (Some v) } 
  let withStyle v x =
    { x with style = (Some v) } 
  let withText v x = { x with text = v } 
end and
TitleOrient:sig
  type t =
    [ `Top  | `Bottom 
    | `Left  | `Right ]
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Top  | `Bottom  | `Left 
    | `Right ]

  let to_yojson =
    function
    | `Right -> `String "right"
    | `Left -> `String "left"
    | `Bottom -> `String "bottom"
    | `Top -> `String "top" 
end and
TitleBase:sig
  type nonrec t =
    {
    style:
      [
        `String of string 
      | `Strings of
          string list ]
        option
      ;
    orient:
TitleOrient.t
        option
      ;
    offset:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    anchor:
Anchor.t option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?anchor:Anchor.t ->
      ?offset:[
                `Int of
                int 
              | `Float of
                float ]
        ->
        ?orient:TitleOrient.t
          ->
          ?style:
            [
              `String of
                string 
            | `Strings of
                string
                list ]
            -> unit -> t
  val withAnchor :
Anchor.t -> t -> t
  val withOffset :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withOrient :
TitleOrient.t ->
      t -> t
  val withStyle :
    [ `String of string 
    | `Strings of
        string list ]
      -> t -> t
end =
struct
  type nonrec t =
    {
    style:
      [ `String of string 
      | `Strings of string list ]
        option
      ;
    orient: TitleOrient.t option ;
    offset:
      [ `Int of int 
      | `Float of float ] option ;
    anchor: Anchor.t option }

  (** Fields
  
    style:
      A [mark style property](config.html#style) to apply to the title text mark.
      
      __Default value:__ `"group-title"`.
  
    orient:
      The orientation of the title relative to the chart. One of `"top"` (the default), `"bottom"`, `"left"`, or `"right"`.
  
    offset:
      The orthogonal offset in pixels by which to displace the title from its position along the edge of the chart.
  
    anchor:
      The anchor position for placing the title. One of `"start"`, `"middle"`, or `"end"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.
      
      __Default value:__ `"middle"` for [single](spec.html) and [layered](layer.html) views.
      `"start"` for other composite views.
      
      __Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only customizable only for [single](spec.html) and [layered](layer.html) views.  For other composite views, `anchor` is always `"start"`.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("anchor",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun
                       (x :
Anchor.t)
                        ->
                       (Anchor.to_yojson
                          x : 
Yojson.Safe.json)))
                     v)) x.anchor));
         ("offset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i ->
                        `Int i
                    | `Float f ->
                        `Float f))
                    v)) x.offset));
         ("orient",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
TitleOrient.t)
                       ->
                      (TitleOrient.to_yojson
                         x : 
Yojson.Safe.json)))
                    v)) x.orient));
         ("style",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Strings v ->
                        ((fun
                          (l :
                          string
                          list)  ->
                          let yojson_of_el
                          (s :
                          string) =
                          (`String
                          s : 
Yojson.Safe.json)
                           in
                          (`List
                          (List.map
                          yojson_of_el
                          l) : 
Yojson.Safe.json)))
                          v
                    | `String v ->
                        ((fun
                          (s :
                          string) 
                          ->
                          (`String
                          s : 
Yojson.Safe.json)))
                          v)) v))
x.style))])                                               
  let make ?anchor  ?offset 
    ?orient  ?style  () =
    { style; orient; offset; anchor
    } 
  let withAnchor v x =
    { x with anchor = (Some v) } 
  let withOffset v x =
    { x with offset = (Some v) } 
  let withOrient v x =
    { x with orient = (Some v) } 
  let withStyle v x =
    { x with style = (Some v) } 
end and
TimeUnitTransform:sig
  type nonrec t =
   {
   timeUnit:
TimeUnit.t
   ;
   field:
   string ;
   nameAs:
   string }
  val
   to_yojson
   :
   t ->
Yojson.Safe.json
  val make :
   nameAs:string
   ->
   field:string
   ->
   timeUnit:TimeUnit.t
   ->
   unit -> t
  val
   withNameAs
   :
   string ->
   t -> t
  val
   withField
   :
   string ->
   t -> t
  val
   withTimeUnit
   :
TimeUnit.t
   -> 
   t -> t
end =
struct
  type nonrec t =
    {
    timeUnit: TimeUnit.t ;
    field: string ;
    nameAs: string }

  (** Fields
  
    timeUnit:
      The timeUnit.
  
    field:
      The data field to apply time unit.
  
    as:
      The output field to write the timeUnit value.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("as",
            (((fun
                 (s : string) 
                 ->
                 (`String s : 
Yojson.Safe.json)))
               x.nameAs));
         ("field",
           (((fun (s : string)
                 ->
                (`String s : 
Yojson.Safe.json)))
              x.field));
         ("timeUnit",
           (((fun
                (x :
TimeUnit.t)
                 ->
                (TimeUnit.to_yojson
                   x : 
Yojson.Safe.json)))
x.timeUnit))])                                                    
  let make ~nameAs  ~field 
    ~timeUnit  () =
    { timeUnit; field; nameAs
    } 
  let withNameAs v x =
    { x with nameAs = v } 
  let withField v x =
    { x with field = v } 
  let withTimeUnit v x =
    { x with timeUnit = v } 
end and
TimeUnit:sig
  type t =
    [
      `Single of
SingleTimeUnit.t
        | 
      `Multi of
MultiTimeUnit.t
       ]
  val to_yojson
    :
    t ->
Yojson.Safe.json
end =
struct
  type t =
    [
      `Single of
SingleTimeUnit.t 
    | `Multi of
MultiTimeUnit.t ]

  let to_yojson =
    function
    | `Multi v ->
        ((fun
            (x :
MultiTimeUnit.t)
             ->
            (MultiTimeUnit.to_yojson
               x : 
Yojson.Safe.json)))
          v
    | `Single v ->
        ((fun
            (x :
SingleTimeUnit.t)
             ->
            (SingleTimeUnit.to_yojson
               x : 
Yojson.Safe.json)))
v                                                         
end and
TickConfig:sig
                                                                    type nonrec t =
                                                                    {
                                                                    thickness:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    theta:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    text:
                                                                    string
                                                                    option ;
                                                                    tension:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    strokeWidth:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    strokeOpacity:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    strokeDashOffset:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    strokeDash:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    list
                                                                    option ;
                                                                    stroke:
                                                                    string
                                                                    option ;
                                                                    size:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    shape:
                                                                    string
                                                                    option ;
                                                                    radius:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    orient:
Orient.t
                                                                    option ;
                                                                    opacity:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    limit:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    interpolate:
Interpolate.t
                                                                    option ;
                                                                    fontWeight:
                                                                    [
                                                                    `FontWeight
                                                                    of
FontWeight.t
 | 
                                                                    `Num of
FontWeightNumber.t
                                                                    ] option ;
                                                                    fontStyle:
FontStyle.t
                                                                    option ;
                                                                    fontSize:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    font:
                                                                    string
                                                                    option ;
                                                                    filled:
                                                                    bool
                                                                    option ;
                                                                    fillOpacity:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    fill:
                                                                    string
                                                                    option ;
                                                                    dy:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    dx:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    color:
                                                                    string
                                                                    option ;
                                                                    baseline:
VerticalAlign.t
                                                                    option ;
                                                                    bandSize:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    angle:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    align:
HorizontalAlign.t
                                                                    option }
                                                                    val
                                                                    to_yojson
                                                                    :
                                                                    t ->
Yojson.Safe.json
                                                                    val make
                                                                    :
                                                                    ?align:HorizontalAlign.t
                                                                    ->
                                                                    ?angle:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?bandSize:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?baseline:VerticalAlign.t
                                                                    ->
                                                                    ?color:string
                                                                    ->
                                                                    ?dx:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?dy:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?fill:string
                                                                    ->
                                                                    ?fillOpacity:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?filled:bool
                                                                    ->
                                                                    ?font:string
                                                                    ->
                                                                    ?fontSize:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?fontStyle:FontStyle.t
                                                                    ->
                                                                    ?fontWeight:
                                                                    [
                                                                    `FontWeight
                                                                    of
FontWeight.t
 | 
                                                                    `Num of
FontWeightNumber.t
                                                                    ] ->
                                                                    ?interpolate:Interpolate.t
                                                                    ->
                                                                    ?limit:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?opacity:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?orient:Orient.t
                                                                    ->
                                                                    ?radius:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?shape:string
                                                                    ->
                                                                    ?size:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?stroke:string
                                                                    ->
                                                                    ?strokeDash:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    list ->
                                                                    ?strokeDashOffset:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?strokeOpacity:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?strokeWidth:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?tension:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?text:string
                                                                    ->
                                                                    ?theta:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?thickness:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    unit -> t
                                                                    val
                                                                    withAlign
                                                                    :
HorizontalAlign.t
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withAngle
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withBandSize
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withBaseline
                                                                    :
VerticalAlign.t
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withColor
                                                                    :
                                                                    string ->
                                                                    t -> t
                                                                    val
                                                                    withDx :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withDy :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withFill
                                                                    :
                                                                    string ->
                                                                    t -> t
                                                                    val
                                                                    withFillOpacity
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withFilled
                                                                    :
                                                                    bool ->
                                                                    t -> t
                                                                    val
                                                                    withFont
                                                                    :
                                                                    string ->
                                                                    t -> t
                                                                    val
                                                                    withFontSize
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withFontStyle
                                                                    :
FontStyle.t
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withFontWeight
                                                                    :
                                                                    [
                                                                    `FontWeight
                                                                    of
FontWeight.t
 | 
                                                                    `Num of
FontWeightNumber.t
                                                                    ] ->
                                                                    t -> t
                                                                    val
                                                                    withInterpolate
                                                                    :
Interpolate.t
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withLimit
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withOpacity
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withOrient
                                                                    :
Orient.t
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withRadius
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withShape
                                                                    :
                                                                    string ->
                                                                    t -> t
                                                                    val
                                                                    withSize
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withStroke
                                                                    :
                                                                    string ->
                                                                    t -> t
                                                                    val
                                                                    withStrokeDash
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    list ->
                                                                    t -> t
                                                                    val
                                                                    withStrokeDashOffset
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withStrokeOpacity
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withStrokeWidth
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withTension
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withText
                                                                    :
                                                                    string ->
                                                                    t -> t
                                                                    val
                                                                    withTheta
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withThickness
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
end =
struct
  type nonrec t =
    {
    thickness:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    theta:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    text:
      string option ;
    tension:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    strokeWidth:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    strokeOpacity:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    strokeDashOffset:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    strokeDash:
      [ `Int of int 
      | `Float of
          float ]
        list option
      ;
    stroke:
      string option ;
    size:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    shape:
      string option ;
    radius:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    orient:
Orient.t
        option
      ;
    opacity:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    limit:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    interpolate:
Interpolate.t
        option
      ;
    fontWeight:
      [
        `FontWeight
          of
FontWeight.t
           | 
        `Num of
FontWeightNumber.t
          ]
        option
      ;
    fontStyle:
FontStyle.t
        option
      ;
    fontSize:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    font:
      string option ;
    filled:
      bool option ;
    fillOpacity:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    fill:
      string option ;
    dy:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    dx:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    color:
      string option ;
    baseline:
VerticalAlign.t
        option
      ;
    bandSize:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    angle:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    align:
HorizontalAlign.t
        option
      }

  (** Fields
  
    thickness:
      Thickness of the tick mark.
      
      __Default value:__  `1`
  
    theta:
      Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating "north".
  
    text:
      Placeholder text if the `text` channel is not specified
  
    tension:
      Depending on the interpolation type, sets the tension parameter (for line and area marks).
  
    strokeWidth:
      The stroke width, in pixels.
  
    strokeOpacity:
      The stroke opacity (value between [0,1]).
      
      __Default value:__ `1`
  
    strokeDashOffset:
      The offset (in pixels) into which to begin drawing with the stroke dash array.
  
    strokeDash:
      An array of alternating stroke, space lengths for creating dashed or dotted lines.
  
    stroke:
      Default Stroke Color.  This has higher precedence than config.color
      
      __Default value:__ (None)
  
    size:
      The pixel area each the point/circle/square.
      For example: in the case of circles, the radius is determined in part by the square root of the size value.
      
      __Default value:__ `30`
  
    shape:
      The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
      
      __Default value:__ `"circle"`
  
    radius:
      Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.
  
    orient:
      The orientation of a non-stacked bar, tick, area, and line charts.
      The value is either horizontal (default) or vertical.
      - For bar, rule and tick, this determines whether the size of the bar and tick
      should be applied to x or y dimension.
      - For area, this property determines the orient property of the Vega output.
      - For line, this property determines the sort order of the points in the line
      if `config.sortLineBy` is not specified.
      For stacked charts, this is always determined by the orientation of the stack;
      therefore explicitly specified value will be ignored.
  
    opacity:
      The overall opacity (value between [0,1]).
      
      __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
  
    limit:
      The maximum length of the text mark in pixels (default 0, indicating no limit). The text value will be automatically truncated if the rendered size exceeds the limit.
  
    interpolate:
      The line interpolation method to use for line and area marks. One of the following:
      - `"linear"`: piecewise linear segments, as in a polyline.
      - `"linear-closed"`: close the linear segments to form a polygon.
      - `"step"`: alternate between horizontal and vertical segments, as in a step function.
      - `"step-before"`: alternate between vertical and horizontal segments, as in a step function.
      - `"step-after"`: alternate between horizontal and vertical segments, as in a step function.
      - `"basis"`: a B-spline, with control point duplication on the ends.
      - `"basis-open"`: an open B-spline; may not intersect the start or end.
      - `"basis-closed"`: a closed B-spline, as in a loop.
      - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
      - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
      - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
      - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the spline.
      - `"monotone"`: cubic interpolation that preserves monotonicity in y.
  
    fontWeight:
      The font weight (e.g., `"bold"`).
  
    fontStyle:
      The font style (e.g., `"italic"`).
  
    fontSize:
      The font size, in pixels.
  
    font:
      The typeface to set the text in (e.g., `"Helvetica Neue"`).
  
    filled:
      Whether the mark's color should be used as fill color instead of stroke color.
      
      __Default value:__ `true` for all marks except `point` and `false` for `point`.
      
      __Applicable for:__ `bar`, `point`, `circle`, `square`, and `area` marks.
  
    fillOpacity:
      The fill opacity (value between [0,1]).
      
      __Default value:__ `1`
  
    fill:
      Default Fill Color.  This has higher precedence than config.color
      
      __Default value:__ (None)
  
    dy:
      The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.
  
    dx:
      The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.
  
    color:
      Default color.  Note that `fill` and `stroke` have higher precedence than `color` and will override `color`.
      
      __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
  
    baseline:
      The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
      
      __Default value:__ `"middle"`
  
    bandSize:
      The width of the ticks.
      
      __Default value:__  2/3 of rangeStep.
  
    angle:
      The rotation angle of the text, in degrees.
  
    align:
      The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun 
           (k,v)  ->
           match v
           with
           | 
           `Null ->
           false
           | 
           _ -> true)
         [("align",
           (((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
HorizontalAlign.t)
            ->
           (HorizontalAlign.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.align));
         ("angle",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.angle));
         ("bandSize",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.bandSize));
         ("baseline",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
VerticalAlign.t)
            ->
           (VerticalAlign.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.baseline));
         ("color",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.color));
         ("dx",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v)) x.dx));
         ("dy",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v)) x.dy));
         ("fill",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.fill));
         ("fillOpacity",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.fillOpacity));
         ("filled",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (b :
           bool)  ->
           (`Bool b : 
Yojson.Safe.json)))
           v))
           x.filled));
         ("font",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.font));
         ("fontSize",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.fontSize));
         ("fontStyle",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
FontStyle.t)
            ->
           (FontStyle.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.fontStyle));
         ("fontWeight",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Num v
           ->
           ((fun
           (x :
FontWeightNumber.t)
            ->
           (FontWeightNumber.to_yojson
           x : Yojson.Safe.json)))
           v
           | `FontWeight
           v ->
           ((fun
           (x :
FontWeight.t)
            ->
           (FontWeight.to_yojson
           x : Yojson.Safe.json)))
           v)) v))
           x.fontWeight));
         ("interpolate",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
Interpolate.t)
            ->
           (Interpolate.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.interpolate));
         ("limit",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.limit));
         ("opacity",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.opacity));
         ("orient",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
Orient.t)
            ->
           (Orient.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.orient));
         ("radius",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.radius));
         ("shape",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.shape));
         ("size",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.size));
         ("stroke",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.stroke));
         ("strokeDash",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (l :
           [
           `Int of
           int 
           | `Float
           of float ]
           list)  ->
           let yojson_of_el
           =
           function
           | 
           `Int i ->
           `Int i
           | 
           `Float f
           ->
           `Float f
            in
           (`List
           (List.map
           yojson_of_el
           l) : 
Yojson.Safe.json)))
           v))
           x.strokeDash));
         ("strokeDashOffset",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.strokeDashOffset));
         ("strokeOpacity",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.strokeOpacity));
         ("strokeWidth",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.strokeWidth));
         ("tension",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.tension));
         ("text",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.text));
         ("theta",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.theta));
         ("thickness",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
x.thickness))])                                                              
  let make ?align 
    ?angle 
    ?bandSize 
    ?baseline 
    ?color  ?dx  ?dy
     ?fill 
    ?fillOpacity 
    ?filled  ?font 
    ?fontSize 
    ?fontStyle 
    ?fontWeight 
    ?interpolate 
    ?limit  ?opacity
     ?orient 
    ?radius  ?shape 
    ?size  ?stroke 
    ?strokeDash 
    ?strokeDashOffset
     ?strokeOpacity 
    ?strokeWidth 
    ?tension  ?text 
    ?theta 
    ?thickness  () =
    {
      thickness;
      theta;
      text;
      tension;
      strokeWidth;
      strokeOpacity;
      strokeDashOffset;
      strokeDash;
      stroke;
      size;
      shape;
      radius;
      orient;
      opacity;
      limit;
      interpolate;
      fontWeight;
      fontStyle;
      fontSize;
      font;
      filled;
      fillOpacity;
      fill;
      dy;
      dx;
      color;
      baseline;
      bandSize;
      angle;
      align
    } 
  let withAlign v x
    =
    {
      x with
      align =
        (Some v)
    } 
  let withAngle v x
    =
    {
      x with
      angle =
        (Some v)
    } 
  let withBandSize v
    x =
    {
      x with
      bandSize =
        (Some v)
    } 
  let withBaseline v
    x =
    {
      x with
      baseline =
        (Some v)
    } 
  let withColor v x
    =
    {
      x with
      color =
        (Some v)
    } 
  let withDx v x =
    {
      x with
      dx = (Some v)
    } 
  let withDy v x =
    {
      x with
      dy = (Some v)
    } 
  let withFill v x =
    {
      x with
      fill =
        (Some v)
    } 
  let withFillOpacity
    v x =
    {
      x with
      fillOpacity =
        (Some v)
    } 
  let withFilled v x
    =
    {
      x with
      filled =
        (Some v)
    } 
  let withFont v x =
    {
      x with
      font =
        (Some v)
    } 
  let withFontSize v
    x =
    {
      x with
      fontSize =
        (Some v)
    } 
  let withFontStyle
    v x =
    {
      x with
      fontStyle =
        (Some v)
    } 
  let withFontWeight
    v x =
    {
      x with
      fontWeight =
        (Some v)
    } 
  let withInterpolate
    v x =
    {
      x with
      interpolate =
        (Some v)
    } 
  let withLimit v x
    =
    {
      x with
      limit =
        (Some v)
    } 
  let withOpacity v
    x =
    {
      x with
      opacity =
        (Some v)
    } 
  let withOrient v x
    =
    {
      x with
      orient =
        (Some v)
    } 
  let withRadius v x
    =
    {
      x with
      radius =
        (Some v)
    } 
  let withShape v x
    =
    {
      x with
      shape =
        (Some v)
    } 
  let withSize v x =
    {
      x with
      size =
        (Some v)
    } 
  let withStroke v x
    =
    {
      x with
      stroke =
        (Some v)
    } 
  let withStrokeDash
    v x =
    {
      x with
      strokeDash =
        (Some v)
    } 
  let withStrokeDashOffset
    v x =
    {
      x with
      strokeDashOffset
        = (Some v)
    } 
  let withStrokeOpacity
    v x =
    {
      x with
      strokeOpacity
        = (Some v)
    } 
  let withStrokeWidth
    v x =
    {
      x with
      strokeWidth =
        (Some v)
    } 
  let withTension v
    x =
    {
      x with
      tension =
        (Some v)
    } 
  let withText v x =
    {
      x with
      text =
        (Some v)
    } 
  let withTheta v x
    =
    {
      x with
      theta =
        (Some v)
    } 
  let withThickness
    v x =
    {
      x with
      thickness =
        (Some v)
    } 
end and
TextFieldDef:
                                                              sig
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit:
TimeUnit.t
      option ;
    format:
      string
      option ;
    field:
Field.t
      option ;
    bin:
      [
      `Bool of
      bool 
      | `Params
      of
BinParams.t
      ] option ;
    aggregate:
Aggregate.t
      option }
  val to_yojson
    :
    t ->
Yojson.Safe.json
  val make :
    ?aggregate:Aggregate.t
      ->
      ?bin:
      [
      `Bool of
      bool 
      | `Params
      of
BinParams.t
      ] ->
      ?field:Field.t
      ->
      ?format:string
      ->
      ?timeUnit:TimeUnit.t
      ->
      typ:Type.t
      ->
      unit -> t
  val
    withAggregate
    :
Aggregate.t
      -> 
      t -> t
  val withBin :
    [
      `Bool of
      bool 
    | `Params
      of
BinParams.t
      ] ->
      t -> t
  val withField
    :
Field.t ->
      t -> t
  val
    withFormat
    :
    string ->
      t -> t
  val
    withTimeUnit
    :
TimeUnit.t
      -> 
      t -> t
  val withTyp :
Type.t ->
      t -> t
end =
struct
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit:
TimeUnit.t
      option ;
    format:
      string
      option ;
    field:
Field.t
      option ;
    bin:
      [
      `Bool of
      bool 
      | `Params
      of
BinParams.t
      ] option ;
    aggregate:
Aggregate.t
      option }

  (** Fields
  
    type:
      The encoded field's type of measurement. This can be either a full type
      name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and `"nominal"`).
  
    timeUnit:
      Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).
      
      __Default value:__ `undefined` (None)
  
    format:
      The [formatting pattern](format.html) for a text field. If not defined, this will be determined automatically.
  
    field:
      __Required.__ A string defining the name of the field from which to pull a data value
      or an object defining iterated values from the [`repeat`](repeat.html) operator.
      
      __Note:__ `field` is not required if `aggregate` is `count`.
  
    bin:
      A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).
      If `true`, default [binning parameters](bin.html) will be applied.
      
      __Default value:__ `false`
  
    aggregate:
      Aggregation function for the field
      (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
      
      __Default value:__ `undefined` (None)
  *)
  let to_yojson
    x =
    `Assoc
      (
List.filter
      (fun
      (k,v)  ->
      match v
      with
      | 
      `Null ->
      false
      | 
      _ -> true)
      [
      ("aggregate",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
Aggregate.t)
       ->
      (Aggregate.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.aggregate));
      ("bin",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((function
      | `Params
      v ->
      ((fun
      (x :
BinParams.t)
       ->
      (BinParams.to_yojson
      x : Yojson.Safe.json)))
      v
      | `Bool v
      ->
      ((fun
      (b :
      bool)  ->
      (`Bool b : 
Yojson.Safe.json)))
      v)) v))
      x.bin));
      ("field",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
Field.t) 
      ->
      (Field.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.field));
      ("format",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (s :
      string) 
      ->
      (`String
      s : Yojson.Safe.json)))
      v))
      x.format));
      ("timeUnit",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
TimeUnit.t)
       ->
      (TimeUnit.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.timeUnit));
      ("type",
      (((fun
      (x :
Type.t) 
      ->
      (Type.to_yojson
      x : Yojson.Safe.json)))
x.typ))])                                                                   
  let make
    ?aggregate 
    ?bin 
    ?field 
    ?format 
    ?timeUnit 
    ~typ  () =
    {
      typ;
      timeUnit;
      format;
      field;
      bin;
      aggregate
    } 
  let withAggregate
    v x =
    {
      x with
      aggregate
      =
      (Some v)
    } 
  let withBin v
    x =
    {
      x with
      bin =
      (Some v)
    } 
  let withField
    v x =
    {
      x with
      field =
      (Some v)
    } 
  let withFormat
    v x =
    {
      x with
      format =
      (Some v)
    } 
  let withTimeUnit
    v x =
    {
      x with
      timeUnit
      =
      (Some v)
    } 
  let withTyp v
    x =
    {
      x with
      typ = v
    } 
end and
TextConfig:
                                                                   sig
 type nonrec t =
 {
 theta:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 text:
 string
 option ;
 tension:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 strokeWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 strokeOpacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 strokeDashOffset:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 strokeDash:
 [
 `Int of
 int 
 | `Float
 of float ]
 list
 option ;
 stroke:
 string
 option ;
 size:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 shortTimeLabels:
 bool
 option ;
 shape:
 string
 option ;
 radius:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 orient:
Orient.t
 option ;
 opacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 limit:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 interpolate:
Interpolate.t
 option ;
 fontWeight:
 [
 `FontWeight
 of
FontWeight.t
  | 
 `Num of
FontWeightNumber.t
 ] option ;
 fontStyle:
FontStyle.t
 option ;
 fontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 font:
 string
 option ;
 filled:
 bool
 option ;
 fillOpacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 fill:
 string
 option ;
 dy:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 dx:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 color:
 string
 option ;
 baseline:
VerticalAlign.t
 option ;
 angle:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 align:
 [ `Left 
 | `Center 
 | `Right ]
 option }
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
 val make
 :
 ?align:
 [ `Left 
 | `Center 
 | `Right ]
 ->
 ?angle:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?baseline:VerticalAlign.t
 ->
 ?color:string
 ->
 ?dx:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?dy:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?fill:string
 ->
 ?fillOpacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?filled:bool
 ->
 ?font:string
 ->
 ?fontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?fontStyle:FontStyle.t
 ->
 ?fontWeight:
 [
 `FontWeight
 of
FontWeight.t
  | 
 `Num of
FontWeightNumber.t
 ] ->
 ?interpolate:Interpolate.t
 ->
 ?limit:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?opacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?orient:Orient.t
 ->
 ?radius:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?shape:string
 ->
 ?shortTimeLabels:bool
 ->
 ?size:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?stroke:string
 ->
 ?strokeDash:
 [
 `Int of
 int 
 | `Float
 of float ]
 list ->
 ?strokeDashOffset:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?strokeOpacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?strokeWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?tension:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?text:string
 ->
 ?theta:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 unit -> t
 val
 withAlign
 :
 [ `Left 
 | `Center 
 | `Right ]
 -> 
 t -> t
 val
 withAngle
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withBaseline
 :
VerticalAlign.t
 -> 
 t -> t
 val
 withColor
 :
 string ->
 t -> t
 val
 withDx :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withDy :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withFill
 :
 string ->
 t -> t
 val
 withFillOpacity
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withFilled
 :
 bool ->
 t -> t
 val
 withFont
 :
 string ->
 t -> t
 val
 withFontSize
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withFontStyle
 :
FontStyle.t
 -> 
 t -> t
 val
 withFontWeight
 :
 [
 `FontWeight
 of
FontWeight.t
  | 
 `Num of
FontWeightNumber.t
 ] ->
 t -> t
 val
 withInterpolate
 :
Interpolate.t
 -> 
 t -> t
 val
 withLimit
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withOpacity
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withOrient
 :
Orient.t
 -> 
 t -> t
 val
 withRadius
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withShape
 :
 string ->
 t -> t
 val
 withShortTimeLabels
 :
 bool ->
 t -> t
 val
 withSize
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withStroke
 :
 string ->
 t -> t
 val
 withStrokeDash
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 list ->
 t -> t
 val
 withStrokeDashOffset
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withStrokeOpacity
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withStrokeWidth
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTension
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withText
 :
 string ->
 t -> t
 val
 withTheta
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
end =
struct
 type nonrec t =
 {
 theta:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 text:
 string
 option ;
 tension:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 strokeWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 strokeOpacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 strokeDashOffset:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 strokeDash:
 [
 `Int of
 int 
 | `Float
 of float ]
 list
 option ;
 stroke:
 string
 option ;
 size:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 shortTimeLabels:
 bool
 option ;
 shape:
 string
 option ;
 radius:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 orient:
Orient.t
 option ;
 opacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 limit:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 interpolate:
Interpolate.t
 option ;
 fontWeight:
 [
 `FontWeight
 of
FontWeight.t
  | 
 `Num of
FontWeightNumber.t
 ] option ;
 fontStyle:
FontStyle.t
 option ;
 fontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 font:
 string
 option ;
 filled:
 bool
 option ;
 fillOpacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 fill:
 string
 option ;
 dy:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 dx:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 color:
 string
 option ;
 baseline:
VerticalAlign.t
 option ;
 angle:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 align:
 [ `Left 
 | `Center 
 | `Right ]
 option }

  (** Fields
  
    theta:
      Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating "north".
  
    text:
      Placeholder text if the `text` channel is not specified
  
    tension:
      Depending on the interpolation type, sets the tension parameter (for line and area marks).
  
    strokeWidth:
      The stroke width, in pixels.
  
    strokeOpacity:
      The stroke opacity (value between [0,1]).
      
      __Default value:__ `1`
  
    strokeDashOffset:
      The offset (in pixels) into which to begin drawing with the stroke dash array.
  
    strokeDash:
      An array of alternating stroke, space lengths for creating dashed or dotted lines.
  
    stroke:
      Default Stroke Color.  This has higher precedence than config.color
      
      __Default value:__ (None)
  
    size:
      The pixel area each the point/circle/square.
      For example: in the case of circles, the radius is determined in part by the square root of the size value.
      
      __Default value:__ `30`
  
    shortTimeLabels:
      Whether month names and weekday names should be abbreviated.
  
    shape:
      The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
      
      __Default value:__ `"circle"`
  
    radius:
      Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.
  
    orient:
      The orientation of a non-stacked bar, tick, area, and line charts.
      The value is either horizontal (default) or vertical.
      - For bar, rule and tick, this determines whether the size of the bar and tick
      should be applied to x or y dimension.
      - For area, this property determines the orient property of the Vega output.
      - For line, this property determines the sort order of the points in the line
      if `config.sortLineBy` is not specified.
      For stacked charts, this is always determined by the orientation of the stack;
      therefore explicitly specified value will be ignored.
  
    opacity:
      The overall opacity (value between [0,1]).
      
      __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
  
    limit:
      The maximum length of the text mark in pixels (default 0, indicating no limit). The text value will be automatically truncated if the rendered size exceeds the limit.
  
    interpolate:
      The line interpolation method to use for line and area marks. One of the following:
      - `"linear"`: piecewise linear segments, as in a polyline.
      - `"linear-closed"`: close the linear segments to form a polygon.
      - `"step"`: alternate between horizontal and vertical segments, as in a step function.
      - `"step-before"`: alternate between vertical and horizontal segments, as in a step function.
      - `"step-after"`: alternate between horizontal and vertical segments, as in a step function.
      - `"basis"`: a B-spline, with control point duplication on the ends.
      - `"basis-open"`: an open B-spline; may not intersect the start or end.
      - `"basis-closed"`: a closed B-spline, as in a loop.
      - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
      - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
      - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
      - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the spline.
      - `"monotone"`: cubic interpolation that preserves monotonicity in y.
  
    fontWeight:
      The font weight (e.g., `"bold"`).
  
    fontStyle:
      The font style (e.g., `"italic"`).
  
    fontSize:
      The font size, in pixels.
  
    font:
      The typeface to set the text in (e.g., `"Helvetica Neue"`).
  
    filled:
      Whether the mark's color should be used as fill color instead of stroke color.
      
      __Default value:__ `true` for all marks except `point` and `false` for `point`.
      
      __Applicable for:__ `bar`, `point`, `circle`, `square`, and `area` marks.
  
    fillOpacity:
      The fill opacity (value between [0,1]).
      
      __Default value:__ `1`
  
    fill:
      Default Fill Color.  This has higher precedence than config.color
      
      __Default value:__ (None)
  
    dy:
      The vertical offset in pixels (before rotation), between the text and anchor point.
  
    dx:
      The horizontal offset in pixels (before rotation), between the text and anchor point.
  
    color:
      Default color.  Note that `fill` and `stroke` have higher precedence than `color` and will override `color`.
      
      __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
  
    baseline:
      The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
      
      __Default value:__ `"middle"`
  
    angle:
      The rotation angle of the text, in degrees.
  
    align:
      The horizontal text alignment.
  *)
 let to_yojson
 x =
 `Assoc
 (List.filter
 (fun
 (k,v)  ->
 match v
 with
 | 
 `Null ->
 false
 | 
 _ -> true)
 [
 ("align",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Right
 ->
 `String
 "right"
 | `Center
 ->
 `String
 "center"
 | `Left
 ->
 `String
 "left"))
 v))
 x.align));
 ("angle",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.angle));
 ("baseline",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
VerticalAlign.t)
  ->
 (VerticalAlign.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.baseline));
 ("color",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.color));
 ("dx",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v)) x.dx));
 ("dy",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v)) x.dy));
 ("fill",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.fill));
 ("fillOpacity",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.fillOpacity));
 ("filled",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.filled));
 ("font",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.font));
 ("fontSize",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.fontSize));
 ("fontStyle",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
FontStyle.t)
  ->
 (FontStyle.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.fontStyle));
 ("fontWeight",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Num v
 ->
 ((fun
 (x :
FontWeightNumber.t)
  ->
 (FontWeightNumber.to_yojson
 x : Yojson.Safe.json)))
 v
 | `FontWeight
 v ->
 ((fun
 (x :
FontWeight.t)
  ->
 (FontWeight.to_yojson
 x : Yojson.Safe.json)))
 v)) v))
 x.fontWeight));
 ("interpolate",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
Interpolate.t)
  ->
 (Interpolate.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.interpolate));
 ("limit",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.limit));
 ("opacity",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.opacity));
 ("orient",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
Orient.t)
  ->
 (Orient.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.orient));
 ("radius",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.radius));
 ("shape",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.shape));
 ("shortTimeLabels",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.shortTimeLabels));
 ("size",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.size));
 ("stroke",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.stroke));
 ("strokeDash",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (l :
 [
 `Int of
 int 
 | `Float
 of float ]
 list)  ->
 let yojson_of_el
 =
 function
 | 
 `Int i ->
 `Int i
 | 
 `Float f
 ->
 `Float f
  in
 (`List
 (List.map
 yojson_of_el
 l) : 
Yojson.Safe.json)))
 v))
 x.strokeDash));
 ("strokeDashOffset",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.strokeDashOffset));
 ("strokeOpacity",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.strokeOpacity));
 ("strokeWidth",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.strokeWidth));
 ("tension",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.tension));
 ("text",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.text));
 ("theta",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
x.theta))])                                                                     
 let make
 ?align 
 ?angle 
 ?baseline
  ?color 
 ?dx  ?dy 
 ?fill 
 ?fillOpacity
  ?filled 
 ?font 
 ?fontSize
  ?fontStyle
  ?fontWeight
  ?interpolate
  ?limit 
 ?opacity 
 ?orient 
 ?radius 
 ?shape 
 ?shortTimeLabels
  ?size 
 ?stroke 
 ?strokeDash
  ?strokeDashOffset
  ?strokeOpacity
  ?strokeWidth
  ?tension
  ?text 
 ?theta 
 () =
 {
 theta;
 text;
 tension;
 strokeWidth;
 strokeOpacity;
 strokeDashOffset;
 strokeDash;
 stroke;
 size;
 shortTimeLabels;
 shape;
 radius;
 orient;
 opacity;
 limit;
 interpolate;
 fontWeight;
 fontStyle;
 fontSize;
 font;
 filled;
 fillOpacity;
 fill;
 dy;
 dx;
 color;
 baseline;
 angle;
 align
 } 
 let withAlign
 v x =
 {
 x with
 align =
 (Some v)
 } 
 let withAngle
 v x =
 {
 x with
 angle =
 (Some v)
 } 
 let withBaseline
 v x =
 {
 x with
 baseline
 =
 (Some v)
 } 
 let withColor
 v x =
 {
 x with
 color =
 (Some v)
 } 
 let withDx
 v x =
 {
 x with
 dx =
 (Some v)
 } 
 let withDy
 v x =
 {
 x with
 dy =
 (Some v)
 } 
 let withFill
 v x =
 {
 x with
 fill =
 (Some v)
 } 
 let withFillOpacity
 v x =
 {
 x with
 fillOpacity
 =
 (Some v)
 } 
 let withFilled
 v x =
 {
 x with
 filled =
 (Some v)
 } 
 let withFont
 v x =
 {
 x with
 font =
 (Some v)
 } 
 let withFontSize
 v x =
 {
 x with
 fontSize
 =
 (Some v)
 } 
 let withFontStyle
 v x =
 {
 x with
 fontStyle
 =
 (Some v)
 } 
 let withFontWeight
 v x =
 {
 x with
 fontWeight
 =
 (Some v)
 } 
 let withInterpolate
 v x =
 {
 x with
 interpolate
 =
 (Some v)
 } 
 let withLimit
 v x =
 {
 x with
 limit =
 (Some v)
 } 
 let withOpacity
 v x =
 {
 x with
 opacity =
 (Some v)
 } 
 let withOrient
 v x =
 {
 x with
 orient =
 (Some v)
 } 
 let withRadius
 v x =
 {
 x with
 radius =
 (Some v)
 } 
 let withShape
 v x =
 {
 x with
 shape =
 (Some v)
 } 
 let withShortTimeLabels
 v x =
 {
 x with
 shortTimeLabels
 =
 (Some v)
 } 
 let withSize
 v x =
 {
 x with
 size =
 (Some v)
 } 
 let withStroke
 v x =
 {
 x with
 stroke =
 (Some v)
 } 
 let withStrokeDash
 v x =
 {
 x with
 strokeDash
 =
 (Some v)
 } 
 let withStrokeDashOffset
 v x =
 {
 x with
 strokeDashOffset
 =
 (Some v)
 } 
 let withStrokeOpacity
 v x =
 {
 x with
 strokeOpacity
 =
 (Some v)
 } 
 let withStrokeWidth
 v x =
 {
 x with
 strokeWidth
 =
 (Some v)
 } 
 let withTension
 v x =
 {
 x with
 tension =
 (Some v)
 } 
 let withText
 v x =
 {
 x with
 text =
 (Some v)
 } 
 let withTheta
 v x =
 {
 x with
 theta =
 (Some v)
 } 
end
and
SummarizeTransform:sig
  type nonrec t =
    {
    summarize: Summarize.t list ;
    groupby: string list option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?groupby:string list ->
      summarize:Summarize.t list -> unit -> t
  val withGroupby : string list -> t -> t
  val withSummarize : Summarize.t list -> t -> t
end =
struct
  type nonrec t =
    {
    summarize: Summarize.t list ;
    groupby: string list option }

  (** Fields
  
    summarize:
      Array of objects that define aggregate fields.
  
    groupby:
      The data fields to group by. If not specified, a single group containing all data objects will be used.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("groupby",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (l : string list)  ->
                       let yojson_of_el (s : string) =
                         (`String s : Yojson.Safe.json)  in
                       (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
                     v)) x.groupby));
         ("summarize",
           (((fun (l : Summarize.t list)  ->
                let yojson_of_el (x : Summarize.t) =
                  (Summarize.to_yojson x : Yojson.Safe.json)  in
                (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
x.summarize))])       
  let make ?groupby  ~summarize  () = { summarize; groupby } 
  let withGroupby v x = { x with groupby = (Some v) } 
  let withSummarize v x = { x with summarize = v } 
end and
Summarize:sig
  type nonrec t =
    {
    field: string ;
    nameAs: string ;
    aggregate: AggregateOp.t }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    aggregate:AggregateOp.t ->
      nameAs:string -> field:string -> unit -> t
  val withAggregate : AggregateOp.t -> t -> t
  val withNameAs : string -> t -> t
  val withField : string -> t -> t
end =
struct
  type nonrec t =
    {
    field: string ;
    nameAs: string ;
    aggregate: AggregateOp.t }

  (** Fields
  
    field:
      The data field for which to compute aggregate function.
  
    as:
      The output field names to use for each aggregated field.
  
    aggregate:
      The aggregation operations to apply to the fields, such as sum, average or count.
      See the [full list of supported aggregation operations](https://vega.github.io/vega-lite/docs/aggregate.html#supported-aggregation-operations)
      for more information.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("aggregate",
            (((fun (x : AggregateOp.t)  ->
                 (AggregateOp.to_yojson x : Yojson.Safe.json)))
               x.aggregate));
         ("as",
           (((fun (s : string)  -> (`String s : Yojson.Safe.json)))
              x.nameAs));
         ("field",
           (((fun (s : string)  -> (`String s : Yojson.Safe.json)))
x.field))])            
  let make ~aggregate  ~nameAs  ~field  () =
    { field; nameAs; aggregate } 
  let withAggregate v x = { x with aggregate = v } 
  let withNameAs v x = { x with nameAs = v } 
  let withField v x = { x with field = v } 
end and
StyleConfigIndex:sig
  type nonrec t = (string * VgMarkConfig.t) list
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type nonrec t = (string * VgMarkConfig.t) list

  let to_yojson x =
    let mapper (k,v) =
      (k,
        ((fun (x : VgMarkConfig.t)  ->
            (VgMarkConfig.to_yojson x : Yojson.Safe.json)) v))
       in
    `Assoc (List.map mapper x) 
end and
StackOffset:sig
  type t =
    [ `Zero  | `Center  | `Normalize  | `None ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = [ `Zero  | `Center  | `Normalize  | `None ]

  let to_yojson =
    function
    | `None -> `String "none"
    | `Normalize -> `String "normalize"
    | `Center -> `String "center"
    | `Zero -> `String "zero" 
end and
Spec:sig
  type t =
    [ `Unit of CompositeUnitSpec.t 
    | `Layer of LayerSpec.t 
    | `Faceted of FacetedSpec.t 
    | `Repeat of RepeatSpec.t 
    | `VConcat of VConcatSpec.t 
    | `HConcat of HConcatSpec.t ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Unit of CompositeUnitSpec.t 
    | `Layer of LayerSpec.t 
    | `Faceted of FacetedSpec.t 
    | `Repeat of RepeatSpec.t 
    | `VConcat of VConcatSpec.t 
    | `HConcat of HConcatSpec.t ]

  let to_yojson =
    function
    | `HConcat v ->
        ((fun (x : HConcatSpec.t)  ->
            (HConcatSpec.to_yojson x : Yojson.Safe.json)))
          v
    | `VConcat v ->
        ((fun (x : VConcatSpec.t)  ->
            (VConcatSpec.to_yojson x : Yojson.Safe.json)))
          v
    | `Repeat v ->
        ((fun (x : RepeatSpec.t)  ->
            (RepeatSpec.to_yojson x : Yojson.Safe.json)))
          v
    | `Faceted v ->
        ((fun (x : FacetedSpec.t)  ->
            (FacetedSpec.to_yojson x : Yojson.Safe.json)))
          v
    | `Layer v ->
        ((fun (x : LayerSpec.t)  ->
            (LayerSpec.to_yojson x : Yojson.Safe.json)))
          v
    | `Unit v ->
        ((fun (x : CompositeUnitSpec.t)  ->
            (CompositeUnitSpec.to_yojson x : Yojson.Safe.json)))
v                           
end and
SortOrder:sig
  type t =
    [ `Descending  | `Ascending ] option
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = [ `Descending  | `Ascending ] option

  let to_yojson =
    function
    | None -> `Null
    | Some `Ascending -> `String "ascending"
    | Some `Descending -> `String "descending" 
end and
SortField:sig
  type nonrec t =
    {
    order: SortOrder.t option ;
    op: AggregateOp.t ;
    field: string option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?field:string ->
      ?order:SortOrder.t ->
        op:AggregateOp.t ->
          unit -> t
  val withField : string -> t -> t
  val withOp :
AggregateOp.t -> t -> t
  val withOrder :
SortOrder.t -> t -> t
end =
struct
  type nonrec t =
    {
    order: SortOrder.t option ;
    op: AggregateOp.t ;
    field: string option }

  (** Fields
  
    order:
      The sort order. One of `"ascending"` (default) or `"descending"`.
  
    op:
      An [aggregate operation](aggregate.html#ops) to perform on the field prior to sorting (e.g., `"count"`, `"mean"` and `"median"`).
      This property is required in cases where the sort field and the data reference field do not match.
      The input data objects will be aggregated, grouped by the encoded data field.
      
      For a full list of operations, please see the documentation for [aggregate](aggregate.html#ops).
  
    field:
      The data field to sort by.
      
      __Default value:__ If unspecified, defaults to the field specified in the outer data reference.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("field",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (s : string)  ->
                       (`String s : Yojson.Safe.json)))
                     v)) x.field));
         ("op",
           (((fun (x : AggregateOp.t)  ->
                (AggregateOp.to_yojson x : 
Yojson.Safe.json))) x.op));
         ("order",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : SortOrder.t)  ->
                      (SortOrder.to_yojson x : 
Yojson.Safe.json))) v))
x.order))])                                     
  let make ?field  ?order  ~op  () =
    { op; order; field } 
  let withField v x =
    { x with field = (Some v) } 
  let withOp v x = { x with op = v } 
  let withOrder v x =
    { x with order = (Some v) } 
end and
SingleTimeUnit:sig
  type t =
    [
      `Local of
LocalSingleTimeUnit.t
         | `USingle of
UtcSingleTimeUnit.t
             ]
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Local of LocalSingleTimeUnit.t 
    | `USingle of UtcSingleTimeUnit.t ]

  let to_yojson =
    function
    | `USingle v ->
        ((fun (x : UtcSingleTimeUnit.t) 
            ->
            (UtcSingleTimeUnit.to_yojson
               x : Yojson.Safe.json))) v
    | `Local v ->
        ((fun
            (x : LocalSingleTimeUnit.t) 
            ->
            (LocalSingleTimeUnit.to_yojson
x : Yojson.Safe.json))) v                                          
end and
SingleSelection_Bind:sig
  type nonrec t =
    (string *
VgBinding.t)
     list
  val
    to_yojson
    :
    t ->
Yojson.Safe.json
end =
struct
  type nonrec t =
    (string * VgBinding.t) list

  let to_yojson x =
    let mapper (k,v) =
      (k,
        ((fun (x : VgBinding.t)  ->
            (VgBinding.to_yojson x : 
Yojson.Safe.json)) v))
       in
    `Assoc (List.map mapper x) 
end and
SingleSelectionConfig_Bind:
                                               sig
  type nonrec t =
    (string * VgBinding.t)
      list
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type nonrec t =
    (string * VgBinding.t)
      list

  let to_yojson x =
    let mapper (k,v) =
      (k,
        ((fun
            (x : VgBinding.t) 
            ->
            (VgBinding.to_yojson
               x : Yojson.Safe.json))
           v))
       in
    `Assoc (List.map mapper x) 
end and
SingleSelectionConfig:
                                                    sig
  type nonrec t =
    {
    resolve:
SelectionResolution.t
        option
      ;
    on:
VgEventStream.t
        option
      ;
    nearest: bool option ;
    fields:
      string list option ;
    encodings:
SingleDefChannel.t
        list option
      ;
    bind:
      [
        `Vg of
VgBinding.t 
      | `Single of
SingleSelectionConfig_Bind.t
          ]
        option
      }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?bind:[
            `Vg of
VgBinding.t 
          | `Single of
SingleSelectionConfig_Bind.t
              ]
      ->
      ?encodings:SingleDefChannel.t
        list ->
        ?fields:string
          list ->
          ?nearest:bool
            ->
            ?on:VgEventStream.t
              ->
              ?resolve:SelectionResolution.t
                ->
                unit -> t
  val withBind :
    [ `Vg of VgBinding.t 
    | `Single of
SingleSelectionConfig_Bind.t
        ]
      -> t -> t
  val withEncodings :
SingleDefChannel.t
      list -> t -> t
  val withFields :
    string list -> t -> t
  val withNearest :
    bool -> t -> t
  val withOn :
VgEventStream.t ->
      t -> t
  val withResolve :
SelectionResolution.t
      -> t -> t
end =
struct
  type nonrec t =
    {
    resolve:
SelectionResolution.t
        option
      ;
    on:
VgEventStream.t
        option
      ;
    nearest: bool option ;
    fields:
      string list option ;
    encodings:
SingleDefChannel.t
        list option
      ;
    bind:
      [
        `Vg of
VgBinding.t 
      | `Single of
SingleSelectionConfig_Bind.t
          ]
        option
      }

  (** Fields
  
    resolve:
      With layered and multi-view displays, a strategy that determines how
      selections' data queries are resolved when applied in a filter transform,
      conditional encoding rule, or scale domain.
  
    on:
      A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.
      For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
  
    nearest:
      When true, an invisible voronoi diagram is computed to accelerate discrete
      selection. The data value _nearest_ the mouse cursor is added to the selection.
      
      See the [nearest transform](nearest.html) documentation for more information.
  
    fields:
      An array of field names whose values must match for a data tuple to
      fall within the selection.
  
    encodings:
      An array of encoding channels. The corresponding data field values
      must match for a data tuple to fall within the selection.
  
    bind:
      Establish a two-way binding between a single selection and input elements
      (also known as dynamic query widgets). A binding takes the form of
      Vega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind)
      or can be a mapping between projected field/encodings and binding definitions.
      
      See the [bind transform](bind.html) documentation for more information.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null ->
                false
            | _ -> true)
         [("bind",
            (((function
               | 
None  ->
                `Null
               | 
Some v ->
                ((function
                | `Single
                v ->
                ((fun
                (x :
SingleSelectionConfig_Bind.t)
                 ->
                (SingleSelectionConfig_Bind.to_yojson
                x : Yojson.Safe.json)))
                v
                | `Vg v
                ->
                ((fun
                (x :
VgBinding.t)
                 ->
                (VgBinding.to_yojson
                x : Yojson.Safe.json)))
                v)) v))
               x.bind));
         ("encodings",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (l :
SingleDefChannel.t
                list)  ->
                let yojson_of_el
                (x :
SingleDefChannel.t)
                =
                (SingleDefChannel.to_yojson
                x : 
Yojson.Safe.json)
                 in
                (`List
                (List.map
                yojson_of_el
                l) : 
Yojson.Safe.json)))
                v))
              x.encodings));
         ("fields",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (l :
                string
                list)  ->
                let yojson_of_el
                (s :
                string) =
                (`String
                s : 
Yojson.Safe.json)
                 in
                (`List
                (List.map
                yojson_of_el
                l) : 
Yojson.Safe.json)))
                v))
              x.fields));
         ("nearest",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (b :
                bool)  ->
                (`Bool b : 
Yojson.Safe.json)))
                v))
              x.nearest));
         ("on",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
VgEventStream.t)
                 ->
                (VgEventStream.to_yojson
                x : Yojson.Safe.json)))
                v)) x.on));
         ("resolve",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
SelectionResolution.t)
                 ->
                (SelectionResolution.to_yojson
                x : Yojson.Safe.json)))
                v))
x.resolve))])                                                         
  let make ?bind 
    ?encodings  ?fields 
    ?nearest  ?on 
    ?resolve  () =
    {
      resolve;
      on;
      nearest;
      fields;
      encodings;
      bind
    } 
  let withBind v x =
    {
      x with
      bind = (Some v)
    } 
  let withEncodings v x =
    {
      x with
      encodings =
        (Some v)
    } 
  let withFields v x =
    {
      x with
      fields = (Some v)
    } 
  let withNearest v x =
    {
      x with
      nearest = (Some v)
    } 
  let withOn v x =
    {
      x with
      on = (Some v)
    } 
  let withResolve v x =
    {
      x with
      resolve = (Some v)
    } 
end and
SingleSelection:
                                                         sig
  type nonrec t =
    {
    typ: [ `Single ] ;
    resolve:
SelectionResolution.t
        option
      ;
    on:
VgEventStream.t
        option
      ;
    nearest:
      bool option ;
    fields:
      string list
        option
      ;
    encodings:
SingleDefChannel.t
        list option
      ;
    bind:
      [
        `Vg of
VgBinding.t
           | 
        `Single of
SingleSelection_Bind.t
          ]
        option
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?bind:[
           `Vg of
VgBinding.t
            | 
           `Single
           of
SingleSelection_Bind.t
           ]
      ->
      ?encodings:SingleDefChannel.t
        list ->
        ?fields:string
          list ->
          ?nearest:bool
           ->
           ?on:VgEventStream.t
           ->
           ?resolve:SelectionResolution.t
           ->
           typ:
           [
           `Single ]
           ->
           unit -> t
  val withBind :
    [
      `Vg of
VgBinding.t 
    | `Single of
SingleSelection_Bind.t
        ]
      -> t -> t
  val withEncodings
    :
SingleDefChannel.t
      list -> 
      t -> t
  val withFields :
    string list ->
      t -> t
  val withNearest :
    bool -> t -> t
  val withOn :
VgEventStream.t
      -> t -> t
  val withResolve :
SelectionResolution.t
      -> t -> t
  val withTyp :
    [ `Single ] ->
      t -> t
end =
struct
  type nonrec t =
    {
    typ: [ `Single ] ;
    resolve:
SelectionResolution.t
        option
      ;
    on:
VgEventStream.t
        option
      ;
    nearest:
      bool option ;
    fields:
      string list
        option
      ;
    encodings:
SingleDefChannel.t
        list option
      ;
    bind:
      [
        `Vg of
VgBinding.t
           | 
        `Single of
SingleSelection_Bind.t
          ]
        option
      }

  (** Fields
  
    resolve:
      With layered and multi-view displays, a strategy that determines how
      selections' data queries are resolved when applied in a filter transform,
      conditional encoding rule, or scale domain.
  
    on:
      A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.
      For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
  
    nearest:
      When true, an invisible voronoi diagram is computed to accelerate discrete
      selection. The data value _nearest_ the mouse cursor is added to the selection.
      
      See the [nearest transform](nearest.html) documentation for more information.
  
    fields:
      An array of field names whose values must match for a data tuple to
      fall within the selection.
  
    encodings:
      An array of encoding channels. The corresponding data field values
      must match for a data tuple to fall within the selection.
  
    bind:
      Establish a two-way binding between a single selection and input elements
      (also known as dynamic query widgets). A binding takes the form of
      Vega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind)
      or can be a mapping between projected field/encodings and binding definitions.
      
      See the [bind transform](bind.html) documentation for more information.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun 
           (k,v)  ->
           match v
           with
           | 
           `Null ->
           false
           | 
           _ -> true)
         [("bind",
           (((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Single
           v ->
           ((fun
           (x :
SingleSelection_Bind.t)
            ->
           (SingleSelection_Bind.to_yojson
           x : Yojson.Safe.json)))
           v
           | `Vg v
           ->
           ((fun
           (x :
VgBinding.t)
            ->
           (VgBinding.to_yojson
           x : Yojson.Safe.json)))
           v)) v))
           x.bind));
         ("encodings",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (l :
SingleDefChannel.t
           list)  ->
           let yojson_of_el
           (x :
SingleDefChannel.t)
           =
           (SingleDefChannel.to_yojson
           x : 
Yojson.Safe.json)
            in
           (`List
           (List.map
           yojson_of_el
           l) : 
Yojson.Safe.json)))
           v))
           x.encodings));
         ("fields",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (l :
           string
           list)  ->
           let yojson_of_el
           (s :
           string) =
           (`String
           s : 
Yojson.Safe.json)
            in
           (`List
           (List.map
           yojson_of_el
           l) : 
Yojson.Safe.json)))
           v))
           x.fields));
         ("nearest",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (b :
           bool)  ->
           (`Bool b : 
Yojson.Safe.json)))
           v))
           x.nearest));
         ("on",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
VgEventStream.t)
            ->
           (VgEventStream.to_yojson
           x : Yojson.Safe.json)))
           v)) x.on));
         ("resolve",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
SelectionResolution.t)
            ->
           (SelectionResolution.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.resolve));
         ("type",
           (
           ((function
           | `Single
           ->
           `String
           "single"))
x.typ))])                                                              
  let make ?bind 
    ?encodings 
    ?fields 
    ?nearest  ?on 
    ?resolve  ~typ 
    () =
    {
      typ;
      resolve;
      on;
      nearest;
      fields;
      encodings;
      bind
    } 
  let withBind v x =
    {
      x with
      bind =
        (Some v)
    } 
  let withEncodings
    v x =
    {
      x with
      encodings =
        (Some v)
    } 
  let withFields v x
    =
    {
      x with
      fields =
        (Some v)
    } 
  let withNearest v
    x =
    {
      x with
      nearest =
        (Some v)
    } 
  let withOn v x =
    {
      x with
      on = (Some v)
    } 
  let withResolve v
    x =
    {
      x with
      resolve =
        (Some v)
    } 
  let withTyp v x =
    { x with typ = v
    } 
end and
SingleDefChannel:
                                                              sig
  type t =
    [ `X  | 
      `Y 
    | `X2 
    | `Y2 
    | `Row 
    | `Column 
    | `Size 
    | `Shape 
    | `Color 
    | `Opacity 
    | `Text 
    | `Tooltip ]
  val to_yojson
    :
    t ->
Yojson.Safe.json
end =
struct
  type t =
    [ `X  | 
      `Y 
    | `X2 
    | `Y2 
    | `Row 
    | `Column 
    | `Size 
    | `Shape 
    | `Color 
    | `Opacity 
    | `Text 
    | `Tooltip ]

  let to_yojson
    =
    function
    | `Tooltip
      ->
      `String
      "tooltip"
    | `Text ->
      `String
      "text"
    | `Opacity
      ->
      `String
      "opacity"
    | `Color ->
      `String
      "color"
    | `Shape ->
      `String
      "shape"
    | `Size ->
      `String
      "size"
    | `Column
      ->
      `String
      "column"
    | `Row ->
      `String
      "row"
    | `Y2 ->
      `String
      "y2"
    | `X2 ->
      `String
      "x2"
    | `Y ->
      `String
      "y"
    | `X ->
      `String
"x"                                                                   
end and
SelectionResolution:
                                                                   sig
 type t =
 [
 `Global 
 | `Union 
 | `Intersect
 ]
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
end =
struct
 type t =
 [
 `Global 
 | `Union 
 | `Intersect
 ]

 let to_yojson
 =
 function
 | 
 `Intersect
 ->
 `String
 "intersect"
 | 
 `Union ->
 `String
 "union"
 | 
 `Global
 ->
 `String
 "global" 
end
and
SelectionOr:sig
  type t = SelectionOperand.t list
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = SelectionOperand.t list

  let to_yojson x =
    `Assoc
      [("or",
         (((fun (l : SelectionOperand.t list)  ->
              let yojson_of_el (x : SelectionOperand.t) =
                (SelectionOperand.to_yojson x : Yojson.Safe.json)  in
(`List (List.map yojson_of_el l) : Yojson.Safe.json))) x))]       
end and
SelectionOperand:sig
  type t =
    [ `Not of SelectionNot.t 
    | `And of SelectionAnd.t  | `Or of SelectionOr.t 
    | `String of string ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Not of SelectionNot.t  | `And of SelectionAnd.t 
    | `Or of SelectionOr.t  | `String of string ]

  let to_yojson =
    function
    | `String v ->
        ((fun (s : string)  -> (`String s : Yojson.Safe.json))) v
    | `Or v ->
        ((fun (x : SelectionOr.t)  ->
            (SelectionOr.to_yojson x : Yojson.Safe.json))) v
    | `And v ->
        ((fun (x : SelectionAnd.t)  ->
            (SelectionAnd.to_yojson x : Yojson.Safe.json))) v
    | `Not v ->
        ((fun (x : SelectionNot.t)  ->
(SelectionNot.to_yojson x : Yojson.Safe.json))) v            
end and
SelectionNot:sig
  type t = SelectionOperand.t
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = SelectionOperand.t

  let to_yojson x =
    `Assoc
      [("not",
         (((fun (x : SelectionOperand.t)  ->
              (SelectionOperand.to_yojson x : Yojson.Safe.json)))
x))]                 
end and
SelectionFilter:sig
  type t = SelectionOperand.t
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = SelectionOperand.t

  (** Fields
  
    selection:
      Filter using a selection name.
  *)
  let to_yojson x =
    `Assoc
      [("selection",
         (((fun (x : SelectionOperand.t)  ->
              (SelectionOperand.to_yojson x : Yojson.Safe.json)))
x))]                      
end and
SelectionDomain_1:sig
  type nonrec t =
    {
    selection: string ;
    encoding: string option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?encoding:string ->
      selection:string -> unit -> t
  val withEncoding : string -> t -> t
  val withSelection :
    string -> t -> t
end =
struct
  type nonrec t =
    {
    selection: string ;
    encoding: string option }

  (** Fields
  
    selection:
      The name of a selection.
  
    encoding:
      The encoding channel to extract selected values for, when a selection is [projected](project.html)
      over multiple fields or encodings.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("encoding",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (s : string)  ->
                       (`String s : Yojson.Safe.json)))
                     v)) x.encoding));
         ("selection",
           (((fun (s : string)  ->
                (`String s : Yojson.Safe.json)))
x.selection))])                           
  let make ?encoding  ~selection  () =
    { selection; encoding } 
  let withEncoding v x = { x with encoding = (Some v) } 
  let withSelection v x = { x with selection = v } 
end and
SelectionDomain:sig
  type t =
    [
      `Domain of SelectionDomain.t 
    | `Domain_1 of
SelectionDomain_1.t ]
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Domain of SelectionDomain.t 
    | `Domain_1 of SelectionDomain_1.t ]

  let to_yojson =
    function
    | `Domain_1 v ->
        ((fun (x : SelectionDomain_1.t)  ->
            (SelectionDomain_1.to_yojson x : 
Yojson.Safe.json))) v
    | `Domain v ->
        ((fun (x : SelectionDomain.t)  ->
            (SelectionDomain.to_yojson x : 
Yojson.Safe.json))) v                                
end and
SelectionDef:sig
  type t =
    [
      `Single of
SingleSelection.t 
    | `Multi of MultiSelection.t 
    | `Interval of
IntervalSelection.t ]
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Single of SingleSelection.t 
    | `Multi of MultiSelection.t 
    | `Interval of IntervalSelection.t ]

  let to_yojson =
    function
    | `Interval v ->
        ((fun (x : IntervalSelection.t)  ->
            (IntervalSelection.to_yojson x : 
Yojson.Safe.json))) v
    | `Multi v ->
        ((fun (x : MultiSelection.t)  ->
            (MultiSelection.to_yojson x : 
Yojson.Safe.json))) v
    | `Single v ->
        ((fun (x : SingleSelection.t)  ->
            (SingleSelection.to_yojson x : 
Yojson.Safe.json))) v                                     
end and
SelectionConfig:sig
  type nonrec t =
    {
    single:
SingleSelectionConfig.t
        option
      ;
    multi:
MultiSelectionConfig.t
        option
      ;
    interval:
IntervalSelectionConfig.t
        option
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?interval:IntervalSelectionConfig.t
      ->
      ?multi:MultiSelectionConfig.t
        ->
        ?single:SingleSelectionConfig.t
          -> unit -> t
  val withInterval :
IntervalSelectionConfig.t
      -> t -> t
  val withMulti :
MultiSelectionConfig.t
      -> t -> t
  val withSingle :
SingleSelectionConfig.t
      -> t -> t
end =
struct
  type nonrec t =
    {
    single:
SingleSelectionConfig.t option ;
    multi: MultiSelectionConfig.t option ;
    interval:
IntervalSelectionConfig.t option }

  (** Fields
  
    single:
      The default definition for a [`single`](selection.html#type) selection. All properties and transformations
        for a single selection definition (except `type`) may be specified here.
      
      For instance, setting `single` to `{"on": "dblclick"}` populates single selections on double-click by default.
  
    multi:
      The default definition for a [`multi`](selection.html#type) selection. All properties and transformations
      for a multi selection definition (except `type`) may be specified here.
      
      For instance, setting `multi` to `{"toggle": "event.altKey"}` adds additional values to
      multi selections when clicking with the alt-key pressed by default.
  
    interval:
      The default definition for an [`interval`](selection.html#type) selection. All properties and transformations
      for an interval selection definition (except `type`) may be specified here.
      
      For instance, setting `interval` to `{"translate": false}` disables the ability to move
      interval selections by default.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("interval",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun
                       (x :
IntervalSelectionConfig.t)
                        ->
                       (IntervalSelectionConfig.to_yojson
                          x : Yojson.Safe.json)))
                     v)) x.interval));
         ("multi",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
MultiSelectionConfig.t)
                       ->
                      (MultiSelectionConfig.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.multi));
         ("single",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
SingleSelectionConfig.t)
                       ->
                      (SingleSelectionConfig.to_yojson
                         x : Yojson.Safe.json)))
v)) x.single))])                                          
  let make ?interval  ?multi  ?single 
    () = { single; multi; interval } 
  let withInterval v x =
    { x with interval = (Some v) } 
  let withMulti v x =
    { x with multi = (Some v) } 
  let withSingle v x =
    { x with single = (Some v) } 
end and
SelectionAnd:sig
  type t =
SelectionOperand.t
      list
  val to_yojson :
    t ->
Yojson.Safe.json
end =
struct
  type t = SelectionOperand.t list

  let to_yojson x =
    `Assoc
      [("and",
         (((fun
              (l :
SelectionOperand.t
                  list)
               ->
              let yojson_of_el
                (x :
SelectionOperand.t)
                =
                (SelectionOperand.to_yojson
                   x : Yojson.Safe.json)
                 in
              (`List
                 (List.map
                    yojson_of_el l) : 
Yojson.Safe.json)))
x))]                                               
end and
SchemeParams:sig
  type nonrec t =
    {
    name: string ;
    extent:
      [
        `Int of
        int 
      | `Float of
        float ]
        list
        option
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?extent:
      [
        `Int of
        int 
      | `Float of
        float ]
      list ->
      name:string
        ->
        unit -> t
  val withExtent
    :
    [
      `Int of int 
    | `Float of
        float ]
      list ->
      t -> t
  val withName :
    string ->
      t -> t
end =
struct
  type nonrec t =
    {
    name: string ;
    extent:
      [ `Int of int 
      | `Float of float ] list
        option
      }

  (** Fields
  
    name:
      A color scheme name for sequential/ordinal scales (e.g., `"category10"` or `"viridis"`).
      
      For the full list of supported scheme, please refer to the [Vega Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.
  
    extent:
      For sequential and diverging schemes only, determines the extent of the color range to use. For example `[0.2, 1]` will rescale the color scheme such that color values in the range _[0, 0.2)_ are excluded from the scheme.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("extent",
            (((function
               | None  ->
                   `Null
               | Some v ->
                   ((fun
                     (l :
                     [
                     `Int of
                     int 
                     | `Float
                     of float ]
                     list)  ->
                     let yojson_of_el
                     =
                     function
                     | 
                     `Int i ->
                     `Int i
                     | 
                     `Float f
                     ->
                     `Float f
                      in
                     (`List
                     (List.map
                     yojson_of_el
                     l) : 
Yojson.Safe.json)))
                     v))
               x.extent));
         ("name",
           (((fun (s : string)
                 ->
                (`String s : 
Yojson.Safe.json)))
x.name))])                                                    
  let make ?extent  ~name  ()
    = { name; extent } 
  let withExtent v x =
    { x with extent = (Some v)
    } 
  let withName v x =
    { x with name = v } 
end and
Scale_Nice:sig
  type nonrec t =
    {
    step:
     [
     `Int of
     int 
     | `Float
     of float ]
     ;
    interval:
     string }
  val
    to_yojson
    :
    t ->
Yojson.Safe.json
  val make :
    interval:string
     ->
     step:
     [
     `Int of
     int 
     | `Float
     of float ]
     ->
     unit -> t
  val
    withInterval
    :
    string ->
     t -> t
  val withStep
    :
    [
     `Int of
     int 
    | `Float
     of float ]
     -> 
     t -> t
end =
struct
  type nonrec t =
    {
    step:
      [ `Int of int 
      | `Float of float ] ;
    interval: string }

  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null ->
                false
            | _ -> true)
         [("interval",
            (((fun
                (s :
                string) 
                ->
                (`String
                s : 
Yojson.Safe.json)))
               x.interval));
         ("step",
           (((function
              | `Int i ->
                `Int i
              | `Float f
                ->
                `Float f))
x.step))])                                                         
  let make ~interval 
    ~step  () =
    { step; interval } 
  let withInterval v x =
    { x with interval = v
    } 
  let withStep v x =
    { x with step = v } 
end and
ScaleType:sig
 type t =
 [
 `Linear 
 | `Bin_linear
  | 
 `Log 
 | `Pow 
 | `Sqrt 
 | `Time 
 | `Utc 
 | `Sequential
  | 
 `Ordinal 
 | `Bin_ordinal
  | 
 `Point 
 | `Band ]
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
end =
struct
  type t =
    [ `Linear 
    | `Bin_linear 
    | `Log  | 
      `Pow 
    | `Sqrt 
    | `Time  | 
      `Utc 
    | `Sequential 
    | `Ordinal 
    | `Bin_ordinal 
    | `Point 
    | `Band ]

  let to_yojson =
    function
    | `Band ->
        `String
          "band"
    | `Point ->
        `String
          "point"
    | `Bin_ordinal
        ->
        `String
          "bin_ordinal"
    | `Ordinal ->
        `String
          "ordinal"
    | `Sequential ->
        `String
          "sequential"
    | `Utc ->
        `String
          "utc"
    | `Time ->
        `String
          "time"
    | `Sqrt ->
        `String
          "sqrt"
    | `Pow ->
        `String
          "pow"
    | `Log ->
        `String
          "log"
    | `Bin_linear ->
        `String
          "bin_linear"
    | `Linear ->
        `String
"linear"                                                              
end and
ScaleResolveMap:
                                                              sig
  type nonrec t =
    {
    y:
ResolveMode.t
      option ;
    x:
ResolveMode.t
      option ;
    size:
ResolveMode.t
      option ;
    shape:
ResolveMode.t
      option ;
    opacity:
ResolveMode.t
      option ;
    color:
ResolveMode.t
      option }
  val to_yojson
    :
    t ->
Yojson.Safe.json
  val make :
    ?color:ResolveMode.t
      ->
      ?opacity:ResolveMode.t
      ->
      ?shape:ResolveMode.t
      ->
      ?size:ResolveMode.t
      ->
      ?x:ResolveMode.t
      ->
      ?y:ResolveMode.t
      ->
      unit -> t
  val withColor
    :
ResolveMode.t
      -> 
      t -> t
  val
    withOpacity
    :
ResolveMode.t
      -> 
      t -> t
  val withShape
    :
ResolveMode.t
      -> 
      t -> t
  val withSize
    :
ResolveMode.t
      -> 
      t -> t
  val withX :
ResolveMode.t
      -> 
      t -> t
  val withY :
ResolveMode.t
      -> 
      t -> t
end =
struct
  type nonrec t =
    {
    y:
ResolveMode.t
      option ;
    x:
ResolveMode.t
      option ;
    size:
ResolveMode.t
      option ;
    shape:
ResolveMode.t
      option ;
    opacity:
ResolveMode.t
      option ;
    color:
ResolveMode.t
      option }

  let to_yojson
    x =
    `Assoc
      (
List.filter
      (fun
      (k,v)  ->
      match v
      with
      | 
      `Null ->
      false
      | 
      _ -> true)
      [
      ("color",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
ResolveMode.t)
       ->
      (ResolveMode.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.color));
      ("opacity",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
ResolveMode.t)
       ->
      (ResolveMode.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.opacity));
      ("shape",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
ResolveMode.t)
       ->
      (ResolveMode.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.shape));
      ("size",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
ResolveMode.t)
       ->
      (ResolveMode.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.size));
      ("x",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
ResolveMode.t)
       ->
      (ResolveMode.to_yojson
      x : Yojson.Safe.json)))
      v)) x.x));
      ("y",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
ResolveMode.t)
       ->
      (ResolveMode.to_yojson
      x : Yojson.Safe.json)))
v)) x.y))])                                                                   
  let make
    ?color 
    ?opacity 
    ?shape 
    ?size  ?x 
    ?y  () =
    {
      y;
      x;
      size;
      shape;
      opacity;
      color
    } 
  let withColor
    v x =
    {
      x with
      color =
      (Some v)
    } 
  let withOpacity
    v x =
    {
      x with
      opacity =
      (Some v)
    } 
  let withShape
    v x =
    {
      x with
      shape =
      (Some v)
    } 
  let withSize
    v x =
    {
      x with
      size =
      (Some v)
    } 
  let withX v x
    =
    {
      x with
      x =
      (Some v)
    } 
  let withY v x
    =
    {
      x with
      y =
      (Some v)
    } 
end and
ScaleFieldDef:
                                                                   sig
 type nonrec t =
 {
 typ:
Type.t ;
 timeUnit:
TimeUnit.t
 option ;
 sort:
 [
 `Order of
SortOrder.t
  | 
 `Field of
SortField.t
 ] option ;
 scale:
Scale.t
 option ;
 field:
Field.t
 option ;
 bin:
 [
 `Bool of
 bool 
 | `Params
 of
BinParams.t
 ] option ;
 aggregate:
Aggregate.t
 option }
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
 val make
 :
 ?aggregate:Aggregate.t
 ->
 ?bin:
 [
 `Bool of
 bool 
 | `Params
 of
BinParams.t
 ] ->
 ?field:Field.t
 ->
 ?scale:Scale.t
 ->
 ?sort:
 [
 `Order of
SortOrder.t
  | 
 `Field of
SortField.t
 ] ->
 ?timeUnit:TimeUnit.t
 ->
 typ:Type.t
 ->
 unit -> t
 val
 withAggregate
 :
Aggregate.t
 -> 
 t -> t
 val
 withBin :
 [
 `Bool of
 bool 
 | `Params
 of
BinParams.t
 ] ->
 t -> t
 val
 withField
 :
Field.t
 -> 
 t -> t
 val
 withScale
 :
Scale.t
 -> 
 t -> t
 val
 withSort
 :
 [
 `Order of
SortOrder.t
  | 
 `Field of
SortField.t
 ] ->
 t -> t
 val
 withTimeUnit
 :
TimeUnit.t
 -> 
 t -> t
 val
 withTyp :
Type.t ->
 t -> t
end =
struct
 type nonrec t =
 {
 typ:
Type.t ;
 timeUnit:
TimeUnit.t
 option ;
 sort:
 [
 `Order of
SortOrder.t
  | 
 `Field of
SortField.t
 ] option ;
 scale:
Scale.t
 option ;
 field:
Field.t
 option ;
 bin:
 [
 `Bool of
 bool 
 | `Params
 of
BinParams.t
 ] option ;
 aggregate:
Aggregate.t
 option }

  (** Fields
  
    type:
      The encoded field's type of measurement. This can be either a full type
      name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and `"nominal"`).
  
    timeUnit:
      Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).
      
      __Default value:__ `undefined` (None)
  
    sort:
      Sort order for the encoded field.
      Supported `sort` values include `"ascending"`, `"descending"` and `null` (no sorting).
      For fields with discrete domains, `sort` can also be a [sort field definition object](sort.html#sort-field).
      
      __Default value:__ `"ascending"`
  
    scale:
      An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
      
      __Default value:__ If undefined, default [scale properties](scale.html) are applied.
  
    field:
      __Required.__ A string defining the name of the field from which to pull a data value
      or an object defining iterated values from the [`repeat`](repeat.html) operator.
      
      __Note:__ `field` is not required if `aggregate` is `count`.
  
    bin:
      A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).
      If `true`, default [binning parameters](bin.html) will be applied.
      
      __Default value:__ `false`
  
    aggregate:
      Aggregation function for the field
      (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
      
      __Default value:__ `undefined` (None)
  *)
 let to_yojson
 x =
 `Assoc
 (List.filter
 (fun
 (k,v)  ->
 match v
 with
 | 
 `Null ->
 false
 | 
 _ -> true)
 [
 ("aggregate",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
Aggregate.t)
  ->
 (Aggregate.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.aggregate));
 ("bin",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Params
 v ->
 ((fun
 (x :
BinParams.t)
  ->
 (BinParams.to_yojson
 x : Yojson.Safe.json)))
 v
 | `Bool v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v)) v))
 x.bin));
 ("field",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
Field.t) 
 ->
 (Field.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.field));
 ("scale",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
Scale.t) 
 ->
 (Scale.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.scale));
 ("sort",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Field
 v ->
 ((fun
 (x :
SortField.t)
  ->
 (SortField.to_yojson
 x : Yojson.Safe.json)))
 v
 | `Order
 v ->
 ((fun
 (x :
SortOrder.t)
  ->
 (SortOrder.to_yojson
 x : Yojson.Safe.json)))
 v)) v))
 x.sort));
 ("timeUnit",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
TimeUnit.t)
  ->
 (TimeUnit.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.timeUnit));
 ("type",
 (((fun
 (x :
Type.t) 
 ->
 (Type.to_yojson
 x : Yojson.Safe.json)))
 x.typ))]) 
 let make
 ?aggregate
  ?bin 
 ?field 
 ?scale 
 ?sort 
 ?timeUnit
  ~typ  ()
 =
 {
 typ;
 timeUnit;
 sort;
 scale;
 field;
 bin;
 aggregate
 } 
 let withAggregate
 v x =
 {
 x with
 aggregate
 =
 (Some v)
 } 
 let withBin
 v x =
 {
 x with
 bin =
 (Some v)
 } 
 let withField
 v x =
 {
 x with
 field =
 (Some v)
 } 
 let withScale
 v x =
 {
 x with
 scale =
 (Some v)
 } 
 let withSort
 v x =
 {
 x with
 sort =
 (Some v)
 } 
 let withTimeUnit
 v x =
 {
 x with
 timeUnit
 =
 (Some v)
 } 
 let withTyp
 v x =
 {
 x with
 typ = v
 } 
end
and
ScaleConfig:sig
  type nonrec t =
    {
    useUnaggregatedDomain: bool option ;
    textXRangeStep: [ `Int of int  | `Float of float ] option ;
    round: bool option ;
    rangeStep: [ `Int of int  | `Float of float ] option ;
    pointPadding: [ `Int of int  | `Float of float ] option ;
    minStrokeWidth: [ `Int of int  | `Float of float ] option ;
    minSize: [ `Int of int  | `Float of float ] option ;
    minOpacity: [ `Int of int  | `Float of float ] option ;
    minFontSize: [ `Int of int  | `Float of float ] option ;
    minBandSize: [ `Int of int  | `Float of float ] option ;
    maxStrokeWidth: [ `Int of int  | `Float of float ] option ;
    maxSize: [ `Int of int  | `Float of float ] option ;
    maxOpacity: [ `Int of int  | `Float of float ] option ;
    maxFontSize: [ `Int of int  | `Float of float ] option ;
    maxBandSize: [ `Int of int  | `Float of float ] option ;
    clamp: bool option ;
    bandPaddingOuter: [ `Int of int  | `Float of float ] option ;
    bandPaddingInner: [ `Int of int  | `Float of float ] option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?bandPaddingInner:[ `Int of int  | `Float of float ] ->
      ?bandPaddingOuter:[ `Int of int  | `Float of float ] ->
        ?clamp:bool ->
          ?maxBandSize:[ `Int of int  | `Float of float ] ->
            ?maxFontSize:[ `Int of int  | `Float of float ] ->
              ?maxOpacity:[ `Int of int  | `Float of float ] ->
                ?maxSize:[ `Int of int  | `Float of float ] ->
                  ?maxStrokeWidth:[ `Int of int 
                                  | `Float of float ]
                    ->
                    ?minBandSize:[ `Int of int 
                                 | `Float of float ]
                      ->
                      ?minFontSize:[ `Int of int 
                                   | `Float of float ]
                        ->
                        ?minOpacity:[ `Int of int 
                                    | `Float of float ]
                          ->
                          ?minSize:[ `Int of int 
                                   | `Float of float ]
                            ->
                            ?minStrokeWidth:[ `Int of int 
                                            | `Float of float ]
                              ->
                              ?pointPadding:[ `Int of int 
                                            | `Float of float ]
                                ->
                                ?rangeStep:[ `Int of int 
                                           | `Float of float ]
                                  ->
                                  ?round:bool ->
                                    ?textXRangeStep:[
                                                      `Int of
                                                      int 
                                                    | `Float of
                                                      float ]
                                      ->
                                      ?useUnaggregatedDomain:bool
                                        -> unit -> t
  val withBandPaddingInner :
    [ `Int of int  | `Float of float ] -> t -> t
  val withBandPaddingOuter :
    [ `Int of int  | `Float of float ] -> t -> t
  val withClamp : bool -> t -> t
  val withMaxBandSize :
    [ `Int of int  | `Float of float ] -> t -> t
  val withMaxFontSize :
    [ `Int of int  | `Float of float ] -> t -> t
  val withMaxOpacity :
    [ `Int of int  | `Float of float ] -> t -> t
  val withMaxSize :
    [ `Int of int  | `Float of float ] -> t -> t
  val withMaxStrokeWidth :
    [ `Int of int  | `Float of float ] -> t -> t
  val withMinBandSize :
    [ `Int of int  | `Float of float ] -> t -> t
  val withMinFontSize :
    [ `Int of int  | `Float of float ] -> t -> t
  val withMinOpacity :
    [ `Int of int  | `Float of float ] -> t -> t
  val withMinSize :
    [ `Int of int  | `Float of float ] -> t -> t
  val withMinStrokeWidth :
    [ `Int of int  | `Float of float ] -> t -> t
  val withPointPadding :
    [ `Int of int  | `Float of float ] -> t -> t
  val withRangeStep :
    [ `Int of int  | `Float of float ] -> t -> t
  val withRound : bool -> t -> t
  val withTextXRangeStep :
    [ `Int of int  | `Float of float ] -> t -> t
  val withUseUnaggregatedDomain : bool -> t -> t
end =
struct
  type nonrec t =
    {
    useUnaggregatedDomain: bool option ;
    textXRangeStep: [ `Int of int  | `Float of float ] option ;
    round: bool option ;
    rangeStep: [ `Int of int  | `Float of float ] option ;
    pointPadding: [ `Int of int  | `Float of float ] option ;
    minStrokeWidth: [ `Int of int  | `Float of float ] option ;
    minSize: [ `Int of int  | `Float of float ] option ;
    minOpacity: [ `Int of int  | `Float of float ] option ;
    minFontSize: [ `Int of int  | `Float of float ] option ;
    minBandSize: [ `Int of int  | `Float of float ] option ;
    maxStrokeWidth: [ `Int of int  | `Float of float ] option ;
    maxSize: [ `Int of int  | `Float of float ] option ;
    maxOpacity: [ `Int of int  | `Float of float ] option ;
    maxFontSize: [ `Int of int  | `Float of float ] option ;
    maxBandSize: [ `Int of int  | `Float of float ] option ;
    clamp: bool option ;
    bandPaddingOuter: [ `Int of int  | `Float of float ] option ;
    bandPaddingInner: [ `Int of int  | `Float of float ] option }

  (** Fields
  
    useUnaggregatedDomain:
      Use the source data range before aggregation as scale domain instead of aggregated data for aggregate axis.
      
      This is equivalent to setting `domain` to `"unaggregate"` for aggregated _quantitative_ fields by default.
      
      This property only works with aggregate functions that produce values within the raw data domain (`"mean"`, `"average"`, `"median"`, `"q1"`, `"q3"`, `"min"`, `"max"`). For other aggregations that produce values outside of the raw data domain (e.g. `"count"`, `"sum"`), this property is ignored.
      
      __Default value:__ `false`
  
    textXRangeStep:
      Default range step for `x` band and point scales of text marks.
      
      __Default value:__ `90`
  
    round:
      If true, rounds numeric output values to integers.
      This can be helpful for snapping to the pixel grid.
      (Only available for `x`, `y`, and `size` scales.)
  
    rangeStep:
      Default range step for band and point scales of (1) the `y` channel
      and (2) the `x` channel when the mark is not `text`.
      
      __Default value:__ `21`
  
    pointPadding:
      Default outer padding for `x` and `y` point-ordinal scales.
      
      __Default value:__ `0.5`
  
    minStrokeWidth:
      Default minimum strokeWidth for strokeWidth (or rule/line's size) scale with zero=false.
      
      __Default value:__ `1`
  
    minSize:
      Default minimum value for point size scale with zero=false.
      
      __Default value:__ `9`
  
    minOpacity:
      Default minimum opacity for mapping a field to opacity.
      
      __Default value:__ `0.3`
  
    minFontSize:
      The default min value for mapping quantitative fields to tick's size/fontSize scale with zero=false
      
      __Default value:__ `8`
  
    minBandSize:
      The default min value for mapping quantitative fields to bar and tick's size/bandSize scale with zero=false.
      
      __Default value:__ `2`
  
    maxStrokeWidth:
      Default max strokeWidth for strokeWidth  (or rule/line's size) scale.
      
      __Default value:__ `4`
  
    maxSize:
      Default max value for point size scale.
  
    maxOpacity:
      Default max opacity for mapping a field to opacity.
      
      __Default value:__ `0.8`
  
    maxFontSize:
      The default max value for mapping quantitative fields to text's size/fontSize.
      
      __Default value:__ `40`
  
    maxBandSize:
      The default max value for mapping quantitative fields to bar's size/bandSize.
      
      If undefined (default), we will use the scale's `rangeStep` - 1.
  
    clamp:
      If true, values that exceed the data domain are clamped to either the minimum or maximum range value
  
    bandPaddingOuter:
      Default outer padding for `x` and `y` band-ordinal scales.
      If not specified, by default, band scale's paddingOuter is paddingInner/2.
  
    bandPaddingInner:
      Default inner padding for `x` and `y` band-ordinal scales.
      
      __Default value:__ `0.1`
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("bandPaddingInner",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
               x.bandPaddingInner));
         ("bandPaddingOuter",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.bandPaddingOuter));
         ("clamp",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) v))
              x.clamp));
         ("maxBandSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.maxBandSize));
         ("maxFontSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.maxFontSize));
         ("maxOpacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.maxOpacity));
         ("maxSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.maxSize));
         ("maxStrokeWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.maxStrokeWidth));
         ("minBandSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.minBandSize));
         ("minFontSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.minFontSize));
         ("minOpacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.minOpacity));
         ("minSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.minSize));
         ("minStrokeWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.minStrokeWidth));
         ("pointPadding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.pointPadding));
         ("rangeStep",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.rangeStep));
         ("round",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) v))
              x.round));
         ("textXRangeStep",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.textXRangeStep));
         ("useUnaggregatedDomain",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) v))
x.useUnaggregatedDomain))])       
  let make ?bandPaddingInner  ?bandPaddingOuter  ?clamp  ?maxBandSize 
    ?maxFontSize  ?maxOpacity  ?maxSize  ?maxStrokeWidth  ?minBandSize 
    ?minFontSize  ?minOpacity  ?minSize  ?minStrokeWidth  ?pointPadding 
    ?rangeStep  ?round  ?textXRangeStep  ?useUnaggregatedDomain  () =
    {
      useUnaggregatedDomain;
      textXRangeStep;
      round;
      rangeStep;
      pointPadding;
      minStrokeWidth;
      minSize;
      minOpacity;
      minFontSize;
      minBandSize;
      maxStrokeWidth;
      maxSize;
      maxOpacity;
      maxFontSize;
      maxBandSize;
      clamp;
      bandPaddingOuter;
      bandPaddingInner
    } 
  let withBandPaddingInner v x = { x with bandPaddingInner = (Some v) } 
  let withBandPaddingOuter v x = { x with bandPaddingOuter = (Some v) } 
  let withClamp v x = { x with clamp = (Some v) } 
  let withMaxBandSize v x = { x with maxBandSize = (Some v) } 
  let withMaxFontSize v x = { x with maxFontSize = (Some v) } 
  let withMaxOpacity v x = { x with maxOpacity = (Some v) } 
  let withMaxSize v x = { x with maxSize = (Some v) } 
  let withMaxStrokeWidth v x = { x with maxStrokeWidth = (Some v) } 
  let withMinBandSize v x = { x with minBandSize = (Some v) } 
  let withMinFontSize v x = { x with minFontSize = (Some v) } 
  let withMinOpacity v x = { x with minOpacity = (Some v) } 
  let withMinSize v x = { x with minSize = (Some v) } 
  let withMinStrokeWidth v x = { x with minStrokeWidth = (Some v) } 
  let withPointPadding v x = { x with pointPadding = (Some v) } 
  let withRangeStep v x = { x with rangeStep = (Some v) } 
  let withRound v x = { x with round = (Some v) } 
  let withTextXRangeStep v x = { x with textXRangeStep = (Some v) } 
  let withUseUnaggregatedDomain v x =
    { x with useUnaggregatedDomain = (Some v) } 
end and
Scale:sig
  type nonrec t =
    {
    zero: bool option ;
    typ: ScaleType.t option ;
    scheme:
      [ `String of string  | `Params of SchemeParams.t ] option ;
    round: bool option ;
    rangeStep: [ `Int of int  | `Float of float ] option ;
    range:
      [ `Nums of [ `Int of int  | `Float of float ] list 
      | `Strings of string list  | `String of string ] option ;
    paddingOuter: [ `Int of int  | `Float of float ] option ;
    paddingInner: [ `Int of int  | `Float of float ] option ;
    padding: [ `Int of int  | `Float of float ] option ;
    nice:
      [ `Bool of bool  | `Float of float  | `Int of int 
      | `NiceTime of NiceTime.t  | `Scale_Nice of Scale_Nice.t ]
        option
      ;
    interpolate:
      [ `Interp of Interpolate.t 
      | `Params of InterpolateParams.t ] option ;
    exponent: [ `Int of int  | `Float of float ] option ;
    domain:
      [ `Unaggregated 
      | `Nums of [ `Int of int  | `Float of float ] list 
      | `Strings of string list 
      | `DateTimes of DateTime.t list 
      | `Domain of SelectionDomain.t ] option ;
    clamp: bool option ;
    base: [ `Int of int  | `Float of float ] option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?base:[ `Int of int  | `Float of float ] ->
      ?clamp:bool ->
        ?domain:[ `Unaggregated 
                | `Nums of
                    [ `Int of int  | `Float of float ] list 
                | `Strings of string list 
                | `DateTimes of DateTime.t list 
                | `Domain of SelectionDomain.t ]
          ->
          ?exponent:[ `Int of int  | `Float of float ] ->
            ?interpolate:[ `Interp of Interpolate.t 
                         | `Params of InterpolateParams.t ]
              ->
              ?nice:[ `Bool of bool  | `Float of float 
                    | `Int of int  | `NiceTime of NiceTime.t 
                    | `Scale_Nice of Scale_Nice.t ]
                ->
                ?padding:[ `Int of int  | `Float of float ] ->
                  ?paddingInner:[ `Int of int 
                                | `Float of float ]
                    ->
                    ?paddingOuter:[ `Int of int 
                                  | `Float of float ]
                      ->
                      ?range:[
                               `Nums of
                                 [ `Int of int 
                                 | `Float of float ] list 
                             | `Strings of string list 
                             | `String of string ]
                        ->
                        ?rangeStep:[ `Int of int 
                                   | `Float of float ]
                          ->
                          ?round:bool ->
                            ?scheme:[ `String of string 
                                    | `Params of SchemeParams.t ]
                              ->
                              ?typ:ScaleType.t ->
                                ?zero:bool -> unit -> t
  val withBase : [ `Int of int  | `Float of float ] -> t -> t
  val withClamp : bool -> t -> t
  val withDomain :
    [ `Unaggregated 
    | `Nums of [ `Int of int  | `Float of float ] list 
    | `Strings of string list  | `DateTimes of DateTime.t list 
    | `Domain of SelectionDomain.t ] -> t -> t
  val withExponent :
    [ `Int of int  | `Float of float ] -> t -> t
  val withInterpolate :
    [ `Interp of Interpolate.t 
    | `Params of InterpolateParams.t ] -> t -> t
  val withNice :
    [ `Bool of bool  | `Float of float  | `Int of int 
    | `NiceTime of NiceTime.t  | `Scale_Nice of Scale_Nice.t ]
      -> t -> t
  val withPadding : [ `Int of int  | `Float of float ] -> t -> t
  val withPaddingInner :
    [ `Int of int  | `Float of float ] -> t -> t
  val withPaddingOuter :
    [ `Int of int  | `Float of float ] -> t -> t
  val withRange :
    [ `Nums of [ `Int of int  | `Float of float ] list 
    | `Strings of string list  | `String of string ] -> 
      t -> t
  val withRangeStep :
    [ `Int of int  | `Float of float ] -> t -> t
  val withRound : bool -> t -> t
  val withScheme :
    [ `String of string  | `Params of SchemeParams.t ] -> t -> t
  val withTyp : ScaleType.t -> t -> t
  val withZero : bool -> t -> t
end =
struct
  type nonrec t =
    {
    zero: bool option ;
    typ: ScaleType.t option ;
    scheme: [ `String of string  | `Params of SchemeParams.t ] option ;
    round: bool option ;
    rangeStep: [ `Int of int  | `Float of float ] option ;
    range:
      [ `Nums of [ `Int of int  | `Float of float ] list 
      | `Strings of string list  | `String of string ] option ;
    paddingOuter: [ `Int of int  | `Float of float ] option ;
    paddingInner: [ `Int of int  | `Float of float ] option ;
    padding: [ `Int of int  | `Float of float ] option ;
    nice:
      [ `Bool of bool  | `Float of float  | `Int of int 
      | `NiceTime of NiceTime.t  | `Scale_Nice of Scale_Nice.t ]
        option
      ;
    interpolate:
      [ `Interp of Interpolate.t  | `Params of InterpolateParams.t ]
        option
      ;
    exponent: [ `Int of int  | `Float of float ] option ;
    domain:
      [ `Unaggregated 
      | `Nums of [ `Int of int  | `Float of float ] list 
      | `Strings of string list  | `DateTimes of DateTime.t list 
      | `Domain of SelectionDomain.t ] option ;
    clamp: bool option ;
    base: [ `Int of int  | `Float of float ] option }

  (** Fields
  
    zero:
      If `true`, ensures that a zero baseline value is included in the scale domain.
      
      __Default value:__ `true` for x and y channels if the quantitative field is not binned and no custom `domain` is provided; `false` otherwise.
      
      __Note:__ Log, time, and utc scales do not support `zero`.
  
    type:
      The type of scale.  Vega-Lite supports the following categories of scale types:
      
      1) [**Continuous Scales**](scale.html#continuous) -- mapping continuous domains to continuous output ranges ([`"linear"`](scale.html#linear), [`"pow"`](scale.html#pow), [`"sqrt"`](scale.html#sqrt), [`"log"`](scale.html#log), [`"time"`](scale.html#time), [`"utc"`](scale.html#utc), [`"sequential"`](scale.html#sequential)).
      
      2) [**Discrete Scales**](scale.html#discrete) -- mapping discrete domains to discrete ([`"ordinal"`](scale.html#ordinal)) or continuous ([`"band"`](scale.html#band) and [`"point"`](scale.html#point)) output ranges.
      
      3) [**Discretizing Scales**](scale.html#discretizing) -- mapping continuous domains to discrete output ranges ([`"bin-linear"`](scale.html#bin-linear) and [`"bin-ordinal"`](scale.html#bin-ordinal)).
      
      __Default value:__ please see the [scale type table](scale.html#type).
  
    scheme:
      A string indicating a color [scheme](scale.html#scheme) name (e.g., `"category10"` or `"viridis"`) or a [scheme parameter object](scale.html#scheme-params).
      
      Discrete color schemes may be used with [discrete](scale.html#discrete) or [discretizing](scale.html#discretizing) scales. Continuous color schemes are intended for use with [sequential](scales.html#sequential) scales.
      
      For the full list of supported scheme, please refer to the [Vega Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.
  
    round:
      If `true`, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.
      
      __Default value:__ `false`.
  
    rangeStep:
      The distance between the starts of adjacent bands or points in [band](scale.html#band) and [point](scale.html#point) scales.
      
      If `rangeStep` is `null` or if the view contains the scale's corresponding [size](size.html) (`width` for `x` scales and `height` for `y` scales), `rangeStep` will be automatically determined to fit the size of the view.
      
      __Default value:__  derived the [scale config](config.html#scale-config)'s `textXRangeStep` (`90` by default) for x-scales of `text` marks and `rangeStep` (`21` by default) for x-scales of other marks and y-scales.
      
      __Warning__: If `rangeStep` is `null` and the cardinality of the scale's domain is higher than `width` or `height`, the rangeStep might become less than one pixel and the mark might not appear correctly.
  
    range:
      The range of the scale. One of:
      
      - A string indicating a [pre-defined named scale range](scale.html#range-config) (e.g., example, `"symbol"`, or `"diverging"`).
      
      - For [continuous scales](scale.html#continuous), two-element array indicating  minimum and maximum values, or an array with more than two entries for specifying a [piecewise scale](scale.html#piecewise).
      
      - For [discrete](scale.html#discrete) and [discretizing](scale.html#discretizing) scales, an array of desired output values.
      
      __Notes:__
      
      1) For [sequential](scale.html#sequential), [ordinal](scale.html#ordinal), and discretizing color scales, you can also specify a color [`scheme`](scale.html#scheme) instead of `range`.
      
      2) Any directly specified `range` for `x` and `y` channels will be ignored. Range can be customized via the view's corresponding [size](size.html) (`width` and `height`) or via [range steps and paddings properties](#range-step) for [band](#band) and [point](#point) scales.
  
    paddingOuter:
      The outer padding (spacing) at the ends of the range of band and point scales,
      as a fraction of the step size. This value must lie in the range [0,1].
      
      __Default value:__ derived from the [scale config](scale.html#config)'s `bandPaddingOuter` for band scales and `pointPadding` for point scales.
  
    paddingInner:
      The inner padding (spacing) within each band step of band scales, as a fraction of the step size. This value must lie in the range [0,1].
      
      For point scale, this property is invalid as point scales do not have internal band widths (only step sizes between bands).
      
      __Default value:__ derived from the [scale config](scale.html#config)'s `bandPaddingInner`.
  
    padding:
      Shortcut for setting `paddingInner` and `paddingOuter` to the same value.  For point scales, this property only affects `paddingOuter`.
      
      __Default value:__ see `paddingInner` and `paddingOuter`.
  
    nice:
      Extending the domain so that it starts and ends on nice round values. This method typically modifies the scales domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of _[0.201479, 0.996679]_, a nice domain might be _[0.2, 1.0]_.
      
      For quantitative scales such as linear, `nice` can be either a boolean flag or a number. If `nice` is a number, it will represent a desired tick count. This allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.
      
      For temporal fields with time and utc scales, the `nice` value can be a string indicating the desired time interval. Legal values are `"millisecond"`, `"second"`, `"minute"`, `"hour"`, `"day"`, `"week"`, `"month"`, and `"year"`. Alternatively, `time` and `utc` scales can accept an object-valued interval specifier of the form `{"interval": "month", "step": 3}`, which includes a desired number of interval steps. Here, the domain would snap to quarter (Jan, Apr, Jul, Oct) boundaries.
      
      __Default value:__ `true` for unbinned _quantitative_ fields; automatically determined based on the time unit for _temporal_ fields.
  
    interpolate:
      The interpolation method for range values. By default, a general interpolator for numbers, dates, strings and colors (in RGB space) is used. For color ranges, this property allows interpolation in alternative color spaces. Legal values include `rgb`, `hsl`, `hsl-long`, `lab`, `hcl`, `hcl-long`, `cubehelix` and `cubehelix-long` ('-long' variants use longer paths in polar coordinate spaces). If object-valued, this property accepts an object with a string-valued _type_ property and an optional numeric _gamma_ property applicable to rgb and cubehelix interpolators. For more, see the [d3-interpolate documentation](https://github.com/d3/d3-interpolate).
  
    exponent:
      The exponent of the `pow` scale.
  
    domain:
      Customized domain values.
      
      For _quantitative_ fields, `domain` can take the form of a two-element array with minimum and maximum values.  [Piecewise scales](scale.html#piecewise) can be created by providing a `domain` with more than two entries.
      If the input field is aggregated, `domain` can also be a string value `"unaggregated"`, indicating that the domain should include the raw data values prior to the aggregation.
      
      For _temporal_ fields, `domain` can be a two-element array minimum and maximum values, in the form of either timestamps or the [DateTime definition objects](types.html#datetime).
      
      For _ordinal_ and _nominal_ fields, `domain` can be an array that lists valid input values.
      
      The `selection` property can be used to [interactively determine](selection.html#scale-domains) the scale domain.
  
    clamp:
      If `true`, values that exceed the data domain are clamped to either the minimum or maximum range value
      
      __Default value:__ derived from the [scale config](config.html#scale-config)'s `clamp` (`true` by default).
  
    base:
      The logarithm base of the `log` scale (default `10`).
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("base",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function
                     | `Int i -> `Int i
                     | `Float f -> `Float f)) v)) x.base));
         ("clamp",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json)))
                    v)) x.clamp));
         ("domain",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Domain v ->
                        ((fun (x : SelectionDomain.t)  ->
                            (SelectionDomain.to_yojson x : Yojson.Safe.json)))
                          v
                    | `DateTimes v ->
                        ((fun (l : DateTime.t list)  ->
                            let yojson_of_el (x : DateTime.t) =
                              (DateTime.to_yojson x : Yojson.Safe.json)
                               in
                            (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v
                    | `Strings v ->
                        ((fun (l : string list)  ->
                            let yojson_of_el (s : string) =
                              (`String s : Yojson.Safe.json)  in
                            (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v
                    | `Nums v ->
                        ((fun
                            (l :
                              [ `Int of int  | `Float of float ] list)
                             ->
                            let yojson_of_el =
                              function
                              | `Int i -> `Int i
                              | `Float f -> `Float f  in
                            (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v
                    | `Unaggregated -> `String "unaggregated")) v))
              x.domain));
         ("exponent",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f))
                    v)) x.exponent));
         ("interpolate",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : InterpolateParams.t)  ->
                            (InterpolateParams.to_yojson x : Yojson.Safe.json)))
                          v
                    | `Interp v ->
                        ((fun (x : Interpolate.t)  ->
                            (Interpolate.to_yojson x : Yojson.Safe.json)))
                          v)) v)) x.interpolate));
         ("nice",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Scale_Nice v ->
                        ((fun (x : Scale_Nice.t)  ->
                            (Scale_Nice.to_yojson x : Yojson.Safe.json)))
                          v
                    | `NiceTime v ->
                        ((fun (x : NiceTime.t)  ->
                            (NiceTime.to_yojson x : Yojson.Safe.json)))
                          v
                    | `Int v ->
                        ((fun (i : int)  ->
                            (`Int i : Yojson.Safe.json))) v
                    | `Float v ->
                        ((fun (f : float)  ->
                            (`Float f : Yojson.Safe.json))) v
                    | `Bool v ->
                        ((fun (b : bool)  ->
                            (`Bool b : Yojson.Safe.json))) v)) v))
              x.nice));
         ("padding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f))
                    v)) x.padding));
         ("paddingInner",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f))
                    v)) x.paddingInner));
         ("paddingOuter",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f))
                    v)) x.paddingOuter));
         ("range",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `String v ->
                        ((fun (s : string)  ->
                            (`String s : Yojson.Safe.json))) v
                    | `Strings v ->
                        ((fun (l : string list)  ->
                            let yojson_of_el (s : string) =
                              (`String s : Yojson.Safe.json)  in
                            (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v
                    | `Nums v ->
                        ((fun
                            (l :
                              [ `Int of int  | `Float of float ] list)
                             ->
                            let yojson_of_el =
                              function
                              | `Int i -> `Int i
                              | `Float f -> `Float f  in
                            (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v)) v)) x.range));
         ("rangeStep",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f))
                    v)) x.rangeStep));
         ("round",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json)))
                    v)) x.round));
         ("scheme",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : SchemeParams.t)  ->
                            (SchemeParams.to_yojson x : Yojson.Safe.json)))
                          v
                    | `String v ->
                        ((fun (s : string)  ->
                            (`String s : Yojson.Safe.json))) v)) v))
              x.scheme));
         ("type",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : ScaleType.t)  ->
                      (ScaleType.to_yojson x : Yojson.Safe.json))) v))
              x.typ));
         ("zero",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json)))
v)) x.zero))])            
  let make ?base  ?clamp  ?domain  ?exponent  ?interpolate  ?nice 
    ?padding  ?paddingInner  ?paddingOuter  ?range  ?rangeStep  ?round
     ?scheme  ?typ  ?zero  () =
    {
      zero;
      typ;
      scheme;
      round;
      rangeStep;
      range;
      paddingOuter;
      paddingInner;
      padding;
      nice;
      interpolate;
      exponent;
      domain;
      clamp;
      base
    } 
  let withBase v x = { x with base = (Some v) } 
  let withClamp v x = { x with clamp = (Some v) } 
  let withDomain v x = { x with domain = (Some v) } 
  let withExponent v x = { x with exponent = (Some v) } 
  let withInterpolate v x = { x with interpolate = (Some v) } 
  let withNice v x = { x with nice = (Some v) } 
  let withPadding v x = { x with padding = (Some v) } 
  let withPaddingInner v x = { x with paddingInner = (Some v) } 
  let withPaddingOuter v x = { x with paddingOuter = (Some v) } 
  let withRange v x = { x with range = (Some v) } 
  let withRangeStep v x = { x with rangeStep = (Some v) } 
  let withRound v x = { x with round = (Some v) } 
  let withScheme v x = { x with scheme = (Some v) } 
  let withTyp v x = { x with typ = (Some v) } 
  let withZero v x = { x with zero = (Some v) } 
end and
ResolveMode:sig
  type t = [ `Independent  | `Shared ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = [ `Independent  | `Shared ]

  let to_yojson =
    function
    | `Shared -> `String "shared"
    | `Independent -> `String "independent" 
end and
Resolve:sig
  type nonrec t =
    {
    scale: ScaleResolveMap.t option ;
    legend: LegendResolveMap.t option ;
    axis: AxisResolveMap.t option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?axis:AxisResolveMap.t ->
      ?legend:LegendResolveMap.t ->
        ?scale:ScaleResolveMap.t -> unit -> t
  val withAxis : AxisResolveMap.t -> t -> t
  val withLegend : LegendResolveMap.t -> t -> t
  val withScale : ScaleResolveMap.t -> t -> t
end =
struct
  type nonrec t =
    {
    scale: ScaleResolveMap.t option ;
    legend: LegendResolveMap.t option ;
    axis: AxisResolveMap.t option }

  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("axis",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : AxisResolveMap.t)  ->
                       (AxisResolveMap.to_yojson x : 
Yojson.Safe.json))) v)) x.axis));
         ("legend",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : LegendResolveMap.t)  ->
                      (LegendResolveMap.to_yojson x : 
Yojson.Safe.json))) v)) x.legend));
         ("scale",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : ScaleResolveMap.t)  ->
                      (ScaleResolveMap.to_yojson x : 
Yojson.Safe.json))) v)) x.scale))])                      
  let make ?axis  ?legend  ?scale  () =
    { scale; legend; axis } 
  let withAxis v x = { x with axis = (Some v) } 
  let withLegend v x = { x with legend = (Some v) } 
  let withScale v x = { x with scale = (Some v) } 
end and
RepeatSpec:sig
  type nonrec t =
    {
    transform: Transform.t list option ;
    title:
      [ `String of string 
      | `Params of TitleParams.t ] option ;
    spec: Spec.t ;
    resolve: Resolve.t option ;
    repeat: Repeat.t ;
    name: string option ;
    description: string option ;
    data: Data.t option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?data:Data.t ->
      ?description:string ->
        ?name:string ->
          ?resolve:Resolve.t ->
            ?title:[ `String of string 
                   | `Params of
TitleParams.t ]
              ->
              ?transform:Transform.t list ->
                repeat:Repeat.t ->
                  spec:Spec.t -> unit -> t
  val withData : Data.t -> t -> t
  val withDescription : string -> t -> t
  val withName : string -> t -> t
  val withRepeat : Repeat.t -> t -> t
  val withResolve : Resolve.t -> t -> t
  val withSpec : Spec.t -> t -> t
  val withTitle :
    [ `String of string 
    | `Params of TitleParams.t ] -> 
      t -> t
  val withTransform :
Transform.t list -> t -> t
end =
struct
  type nonrec t =
    {
    transform: Transform.t list option ;
    title:
      [ `String of string  | `Params of TitleParams.t ]
        option
      ;
    spec: Spec.t ;
    resolve: Resolve.t option ;
    repeat: Repeat.t ;
    name: string option ;
    description: string option ;
    data: Data.t option }

  (** Fields
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    name:
      Name of the visualization for later reference.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("data",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : Data.t)  ->
                       (Data.to_yojson x : Yojson.Safe.json)))
                     v)) x.data));
         ("description",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.description));
         ("name",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.name));
         ("repeat",
           (((fun (x : Repeat.t)  ->
                (Repeat.to_yojson x : Yojson.Safe.json)))
              x.repeat));
         ("resolve",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Resolve.t)  ->
                      (Resolve.to_yojson x : Yojson.Safe.json)))
                    v)) x.resolve));
         ("spec",
           (((fun (x : Spec.t)  ->
                (Spec.to_yojson x : Yojson.Safe.json)))
              x.spec));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : TitleParams.t)  ->
                            (TitleParams.to_yojson x : 
Yojson.Safe.json))) v
                    | `String v ->
                        ((fun (s : string)  ->
                            (`String s : Yojson.Safe.json)))
                          v)) v)) x.title));
         ("transform",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : Transform.t list)  ->
                      let yojson_of_el
                        (x : Transform.t) =
                        (Transform.to_yojson x : 
Yojson.Safe.json)  in
                      (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v))
x.transform))])                           
  let make ?data  ?description  ?name  ?resolve  ?title
     ?transform  ~repeat  ~spec  () =
    {
      spec;
      repeat;
      transform;
      title;
      resolve;
      name;
      description;
      data
    } 
  let withData v x = { x with data = (Some v) } 
  let withDescription v x =
    { x with description = (Some v) } 
  let withName v x = { x with name = (Some v) } 
  let withRepeat v x = { x with repeat = v } 
  let withResolve v x = { x with resolve = (Some v) } 
  let withSpec v x = { x with spec = v } 
  let withTitle v x = { x with title = (Some v) } 
  let withTransform v x =
    { x with transform = (Some v) } 
end and
RepeatRef:sig
  type t = [ `Row  | `Column ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = [ `Row  | `Column ]

  (** Reference to a repeated value.
  *)
  let to_yojson x =
    `Assoc
      [("repeat",
         (((function
            | `Column -> `String "column"
| `Row -> `String "row")) x))]                                
end and
Repeat:sig
  type nonrec t =
    {
    row: string list option ;
    column: string list option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?column:string list ->
      ?row:string list -> unit -> t
  val withColumn :
    string list -> t -> t
  val withRow : string list -> t -> t
end =
struct
  type nonrec t =
    {
    row: string list option ;
    column: string list option }

  (** Fields
  
    row:
      Vertical repeated views.
  
    column:
      Horizontal repeated views.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("column",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (l : string list) 
                       ->
                       let yojson_of_el
                         (s : string) =
                         (`String s : 
Yojson.Safe.json)
                          in
                       (`List
                          (List.map
                             yojson_of_el l) : 
Yojson.Safe.json)))
                     v)) x.column));
         ("row",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : string list)  ->
                      let yojson_of_el
                        (s : string) =
                        (`String s : 
Yojson.Safe.json)  in
                      (`List
                         (List.map
                            yojson_of_el l) : 
Yojson.Safe.json))) v))
x.row))])                                     
  let make ?column  ?row  () =
    { row; column } 
  let withColumn v x =
    { x with column = (Some v) } 
  let withRow v x = { x with row = (Some v) } 
end and
RangeFilter:sig
  type nonrec t =
    {
    timeUnit:
TimeUnit.t option ;
    range:
      [
        `DateTime of
DateTime.t 
      | `Num of
          [ `Int of int 
          | `Float of float ]
          ]
        list
      ;
    field: string }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?timeUnit:TimeUnit.t ->
      field:string ->
        range:[
                `DateTime of
DateTime.t 
              | `Num of
                  [
                   `Int of
                   int 
                  | `Float
                   of float ]
                  ]
          list -> unit -> t
  val withField :
    string -> t -> t
  val withRange :
    [
      `DateTime of
DateTime.t 
    | `Num of
        [ `Int of int 
        | `Float of float ] ]
      list -> t -> t
  val withTimeUnit :
TimeUnit.t -> t -> t
end =
struct
  type nonrec t =
    {
    timeUnit: TimeUnit.t option ;
    range:
      [ `DateTime of DateTime.t 
      | `Num of
          [ `Int of int 
          | `Float of float ] ]
        list
      ;
    field: string }

  (** Fields
  
    timeUnit:
      time unit for the field to be filtered.
  
    range:
      An array of inclusive minimum and maximum values
      for a field value of a data item to be included in the filtered data.
  
    field:
      Field to be filtered
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("field",
            (((fun (s : string)  ->
                 (`String s : Yojson.Safe.json)))
               x.field));
         ("range",
           (((fun
                (l :
                  [
                    `DateTime of
DateTime.t 
                  | `Num of
                      [ `Int of int 
                      | `Float of float ]
                      ]
                    list)
                 ->
                let yojson_of_el =
                  function
                  | `Num v ->
                      ((function
                        | `Int i ->
                            `Int i
                        | `Float f ->
                            `Float f)) v
                  | `DateTime v ->
                      ((fun
                          (x :
DateTime.t)
                           ->
                          (DateTime.to_yojson
                             x : 
Yojson.Safe.json)))
                        v
                   in
                (`List
                   (List.map
                      yojson_of_el l) : 
Yojson.Safe.json)))
              x.range));
         ("timeUnit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : TimeUnit.t)
                       ->
                      (TimeUnit.to_yojson
                         x : Yojson.Safe.json)))
v)) x.timeUnit))])                                          
  let make ?timeUnit  ~field  ~range  ()
    = { range; field; timeUnit } 
  let withField v x =
    { x with field = v } 
  let withRange v x =
    { x with range = v } 
  let withTimeUnit v x =
    { x with timeUnit = (Some v) } 
end and
RangeConfigValue:sig
  type t =
    [
      `Variants of
        [
         `Num of
         [
         `Int of
         int 
         | `Float
         of float ]
          | 
         `String
         of 
         string ]
         list
         | 
      `VgScheme of
VgScheme.t 
    | `Value of
RangeConfigValue.t
        ]
  val to_yojson :
    t ->
Yojson.Safe.json
end =
struct
  type t =
    [
      `Variants of
        [
          `Num of
            [ `Int of int 
            | `Float of float ] 
        | `String of string ] list 
    | `VgScheme of VgScheme.t 
    | `Value of RangeConfigValue.t ]

  let to_yojson =
    function
    | `Value v ->
        ((fun
            (x :
RangeConfigValue.t)
             ->
            (RangeConfigValue.to_yojson
               x : Yojson.Safe.json)))
          v
    | `VgScheme v ->
        ((fun (x : VgScheme.t)  ->
            (VgScheme.to_yojson x : 
Yojson.Safe.json))) v
    | `Variants v ->
        ((fun
            (l :
              [
                `Num of
                  [ `Int of int 
                  | `Float of float ]
                   | `String of
                       string ]
                list)
             ->
            let yojson_of_el =
              function
              | `String v ->
                  ((fun
                      (s : string) 
                      ->
                      (`String s : 
Yojson.Safe.json)))
                    v
              | `Num v ->
                  ((function
                    | `Int i ->
                        `Int i
                    | `Float f ->
                        `Float f))
                    v
               in
            (`List
               (List.map
                  yojson_of_el l) : 
Yojson.Safe.json))) v                                               
end and
RangeConfig:sig
  type nonrec t =
    {
    additional:
      (string *
RangeConfigValue.t)
        list
      ;
    symbol:
      string list
        option
      ;
    ramp:
      [
        `Strings
         of
         string
         list 
      | `VgScheme
         of
VgScheme.t
         ]
        option
      ;
    ordinal:
      [
        `Strings
         of
         string
         list 
      | `VgScheme
         of
VgScheme.t
         ]
        option
      ;
    heatmap:
      [
        `Strings
         of
         string
         list 
      | `VgScheme
         of
VgScheme.t
         ]
        option
      ;
    diverging:
      [
        `Strings
         of
         string
         list 
      | `VgScheme
         of
VgScheme.t
         ]
        option
      ;
    category:
      [
        `Strings
         of
         string
         list 
      | `VgScheme
         of
VgScheme.t
         ]
        option
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?additional:(string
      *
RangeConfigValue.t)
      list ->
      ?category:
        [
         `Strings
         of
         string
         list 
        | `VgScheme
         of
VgScheme.t
         ]
        ->
        ?diverging:
         [
         `Strings
         of
         string
         list 
         | `VgScheme
         of
VgScheme.t
         ] ->
         ?heatmap:
         [
         `Strings
         of
         string
         list 
         | `VgScheme
         of
VgScheme.t
         ] ->
         ?ordinal:
         [
         `Strings
         of
         string
         list 
         | `VgScheme
         of
VgScheme.t
         ] ->
         ?ramp:
         [
         `Strings
         of
         string
         list 
         | `VgScheme
         of
VgScheme.t
         ] ->
         ?symbol:string
         list ->
         unit -> t
  val additional :
    (string *
RangeConfigValue.t)
      list ->
      t -> t
  val withCategory
    :
    [
      `Strings of
        string
         list
         | 
      `VgScheme of
VgScheme.t ]
      -> t -> t
  val
    withDiverging
    :
    [
      `Strings of
        string
         list
         | 
      `VgScheme of
VgScheme.t ]
      -> t -> t
  val withHeatmap
    :
    [
      `Strings of
        string
         list
         | 
      `VgScheme of
VgScheme.t ]
      -> t -> t
  val withOrdinal
    :
    [
      `Strings of
        string
         list
         | 
      `VgScheme of
VgScheme.t ]
      -> t -> t
  val withRamp :
    [
      `Strings of
        string
         list
         | 
      `VgScheme of
VgScheme.t ]
      -> t -> t
  val withSymbol :
    string list ->
      t -> t
end =
struct
  type nonrec t =
    {
    additional:
      (string *
RangeConfigValue.t)
        list
      ;
    symbol: string list option ;
    ramp:
      [
        `Strings of
          string list 
      | `VgScheme of
VgScheme.t ]
        option
      ;
    ordinal:
      [
        `Strings of
          string list 
      | `VgScheme of
VgScheme.t ]
        option
      ;
    heatmap:
      [
        `Strings of
          string list 
      | `VgScheme of
VgScheme.t ]
        option
      ;
    diverging:
      [
        `Strings of
          string list 
      | `VgScheme of
VgScheme.t ]
        option
      ;
    category:
      [
        `Strings of
          string list 
      | `VgScheme of
VgScheme.t ]
        option
      }

  (** Fields
  
    symbol:
      Default range palette for the `shape` channel.
  
    ramp:
      Default range for _quantitative_ and _temporal_ fields.
  
    ordinal:
      Default range for _ordinal_ fields.
  
    heatmap:
      Default range for _quantitative_ heatmaps.
  
    diverging:
      Default range for diverging _quantitative_ fields.
  
    category:
      Default range for _nominal_ (categorical) fields.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("category",
            (((function
               | None  ->
                   `Null
               | Some v ->
                   ((function
                     | 
                     `VgScheme
                     v ->
                     ((fun
                     (x :
VgScheme.t)
                      ->
                     (VgScheme.to_yojson
                     x : Yojson.Safe.json)))
                     v
                     | 
                     `Strings
                     v ->
                     ((fun
                     (l :
                     string
                     list)  ->
                     let yojson_of_el
                     (s :
                     string) =
                     (`String
                     s : 
Yojson.Safe.json)
                      in
                     (`List
                     (List.map
                     yojson_of_el
                     l) : 
Yojson.Safe.json)))
                     v)) v))
               x.category));
         ("diverging",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `VgScheme
                     v ->
                     ((fun
                     (x :
VgScheme.t)
                      ->
                     (VgScheme.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Strings v
                     ->
                     ((fun
                     (l :
                     string
                     list)  ->
                     let yojson_of_el
                     (s :
                     string) =
                     (`String
                     s : 
Yojson.Safe.json)
                      in
                     (`List
                     (List.map
                     yojson_of_el
                     l) : 
Yojson.Safe.json)))
                     v)) v))
              x.diverging));
         ("heatmap",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `VgScheme
                     v ->
                     ((fun
                     (x :
VgScheme.t)
                      ->
                     (VgScheme.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Strings v
                     ->
                     ((fun
                     (l :
                     string
                     list)  ->
                     let yojson_of_el
                     (s :
                     string) =
                     (`String
                     s : 
Yojson.Safe.json)
                      in
                     (`List
                     (List.map
                     yojson_of_el
                     l) : 
Yojson.Safe.json)))
                     v)) v))
              x.heatmap));
         ("ordinal",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `VgScheme
                     v ->
                     ((fun
                     (x :
VgScheme.t)
                      ->
                     (VgScheme.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Strings v
                     ->
                     ((fun
                     (l :
                     string
                     list)  ->
                     let yojson_of_el
                     (s :
                     string) =
                     (`String
                     s : 
Yojson.Safe.json)
                      in
                     (`List
                     (List.map
                     yojson_of_el
                     l) : 
Yojson.Safe.json)))
                     v)) v))
              x.ordinal));
         ("ramp",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `VgScheme
                     v ->
                     ((fun
                     (x :
VgScheme.t)
                      ->
                     (VgScheme.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Strings v
                     ->
                     ((fun
                     (l :
                     string
                     list)  ->
                     let yojson_of_el
                     (s :
                     string) =
                     (`String
                     s : 
Yojson.Safe.json)
                      in
                     (`List
                     (List.map
                     yojson_of_el
                     l) : 
Yojson.Safe.json)))
                     v)) v))
              x.ramp));
         ("symbol",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (l :
                     string
                     list)  ->
                     let yojson_of_el
                     (s :
                     string) =
                     (`String
                     s : 
Yojson.Safe.json)
                      in
                     (`List
                     (List.map
                     yojson_of_el
                     l) : 
Yojson.Safe.json)))
                    v))
x.symbol))])                                                    
  let make ?(additional= []) 
    ?category  ?diverging 
    ?heatmap  ?ordinal  ?ramp 
    ?symbol  () =
    {
      additional;
      symbol;
      ramp;
      ordinal;
      heatmap;
      diverging;
      category
    } 
  let additional v x =
    { x with additional = v } 
  let withCategory v x =
    {
      x with
      category = (Some v)
    } 
  let withDiverging v x =
    {
      x with
      diverging = (Some v)
    } 
  let withHeatmap v x =
    {
      x with
      heatmap = (Some v)
    } 
  let withOrdinal v x =
    {
      x with
      ordinal = (Some v)
    } 
  let withRamp v x =
    { x with ramp = (Some v) } 
  let withSymbol v x =
    { x with symbol = (Some v)
    } 
end and
PositionFieldDef:
                                                    sig
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit:
TimeUnit.t option ;
    stack:
StackOffset.t
        option
      ;
    sort:
      [
        `Order of
SortOrder.t 
      | `Field of
SortField.t ]
        option
      ;
    scale: Scale.t option ;
    field: Field.t option ;
    bin:
      [ `Bool of bool 
      | `Params of
BinParams.t ]
        option
      ;
    axis: Axis.t option ;
    aggregate:
Aggregate.t option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?aggregate:Aggregate.t
      ->
      ?axis:Axis.t ->
        ?bin:[
               `Bool of
                bool 
             | `Params of
BinParams.t
                ]
          ->
          ?field:Field.t
            ->
            ?scale:Scale.t
              ->
              ?sort:
                [
                `Order of
SortOrder.t
                 | 
                `Field of
SortField.t
                ] ->
                ?stack:StackOffset.t
                ->
                ?timeUnit:TimeUnit.t
                ->
                typ:Type.t
                ->
                unit -> t
  val withAggregate :
Aggregate.t -> t -> t
  val withAxis :
Axis.t -> t -> t
  val withBin :
    [ `Bool of bool 
    | `Params of
BinParams.t ]
      -> t -> t
  val withField :
Field.t -> t -> t
  val withScale :
Scale.t -> t -> t
  val withSort :
    [
      `Order of
SortOrder.t 
    | `Field of
SortField.t ]
      -> t -> t
  val withStack :
StackOffset.t ->
      t -> t
  val withTimeUnit :
TimeUnit.t -> t -> t
  val withTyp :
Type.t -> t -> t
end =
struct
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit:
TimeUnit.t option ;
    stack:
StackOffset.t
        option
      ;
    sort:
      [
        `Order of
SortOrder.t 
      | `Field of
SortField.t ]
        option
      ;
    scale: Scale.t option ;
    field: Field.t option ;
    bin:
      [ `Bool of bool 
      | `Params of
BinParams.t ]
        option
      ;
    axis: Axis.t option ;
    aggregate:
Aggregate.t option }

  (** Fields
  
    type:
      The encoded field's type of measurement. This can be either a full type
      name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and `"nominal"`).
  
    timeUnit:
      Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).
      
      __Default value:__ `undefined` (None)
  
    stack:
      Type of stacking offset if the field should be stacked.
      `stack` is only applicable for `x` and `y` channels with continuous domains.
      For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.
      
      `stack` can be one of the following values:
      - `"zero"`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](stack.html#bar) and [area](stack.html#area) chart).
      - `"normalize"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](stack.html#normalized). <br/>
      -`"center"` - stacking with center baseline (for [streamgraph](stack.html#streamgraph)).
      - `"none"` - No-stacking. This will produce layered [bar](stack.html#layered-bar-chart) and area chart.
      
      __Default value:__ `zero` for plots with all of the following conditions are true: (1) `bar` or `area` marks (2) At least one of `color`, `opacity`, `size`, or `detail` channel mapped to a group-by field (3) one position channel has a linear scale and summative aggregation function (e.g., `sum`, `count`) and (4) the other position channel either has discrete domain or unmapped.  Otherwise `"none"` by default.
  
    sort:
      Sort order for the encoded field.
      Supported `sort` values include `"ascending"`, `"descending"` and `null` (no sorting).
      For fields with discrete domains, `sort` can also be a [sort field definition object](sort.html#sort-field).
      
      __Default value:__ `"ascending"`
  
    scale:
      An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
      
      __Default value:__ If undefined, default [scale properties](scale.html) are applied.
  
    field:
      __Required.__ A string defining the name of the field from which to pull a data value
      or an object defining iterated values from the [`repeat`](repeat.html) operator.
      
      __Note:__ `field` is not required if `aggregate` is `count`.
  
    bin:
      A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).
      If `true`, default [binning parameters](bin.html) will be applied.
      
      __Default value:__ `false`
  
    axis:
      An object defining properties of axis's gridlines, ticks and labels.
      If `null`, the axis for the encoding channel will be removed.
      
      __Default value:__ If undefined, default [axis properties](axis.html) are applied.
  
    aggregate:
      Aggregation function for the field
      (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
      
      __Default value:__ `undefined` (None)
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null ->
                false
            | _ -> true)
         [("aggregate",
            (((function
               | 
None  ->
                `Null
               | 
Some v ->
                ((fun
                (x :
Aggregate.t)
                 ->
                (Aggregate.to_yojson
                x : Yojson.Safe.json)))
                v))
               x.aggregate));
         ("axis",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
Axis.t) 
                ->
                (Axis.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.axis));
         ("bin",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((function
                | `Params
                v ->
                ((fun
                (x :
BinParams.t)
                 ->
                (BinParams.to_yojson
                x : Yojson.Safe.json)))
                v
                | `Bool v
                ->
                ((fun
                (b :
                bool)  ->
                (`Bool b : 
Yojson.Safe.json)))
                v)) v))
              x.bin));
         ("field",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
Field.t) 
                ->
                (Field.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.field));
         ("scale",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
Scale.t) 
                ->
                (Scale.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.scale));
         ("sort",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((function
                | `Field
                v ->
                ((fun
                (x :
SortField.t)
                 ->
                (SortField.to_yojson
                x : Yojson.Safe.json)))
                v
                | `Order
                v ->
                ((fun
                (x :
SortOrder.t)
                 ->
                (SortOrder.to_yojson
                x : Yojson.Safe.json)))
                v)) v))
              x.sort));
         ("stack",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
StackOffset.t)
                 ->
                (StackOffset.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.stack));
         ("timeUnit",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
TimeUnit.t)
                 ->
                (TimeUnit.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.timeUnit));
         ("type",
           (((fun
                (x :
Type.t) 
                ->
                (
Type.to_yojson
                x : 
Yojson.Safe.json)))
x.typ))])                                                         
  let make ?aggregate 
    ?axis  ?bin  ?field 
    ?scale  ?sort  ?stack
     ?timeUnit  ~typ  ()
    =
    {
      typ;
      timeUnit;
      stack;
      sort;
      scale;
      field;
      bin;
      axis;
      aggregate
    } 
  let withAggregate v x =
    {
      x with
      aggregate =
        (Some v)
    } 
  let withAxis v x =
    {
      x with
      axis = (Some v)
    } 
  let withBin v x =
    {
      x with
      bin = (Some v)
    } 
  let withField v x =
    {
      x with
      field = (Some v)
    } 
  let withScale v x =
    {
      x with
      scale = (Some v)
    } 
  let withSort v x =
    {
      x with
      sort = (Some v)
    } 
  let withStack v x =
    {
      x with
      stack = (Some v)
    } 
  let withTimeUnit v x =
    {
      x with
      timeUnit = (Some v)
    } 
  let withTyp v x =
    { x with typ = v } 
end and
Padding:sig
  type t =
   [
   `Float of
   float 
   | `Int of
   int 
   | `Padding
   of
Padding.t ]
  val
   to_yojson
   :
   t ->
Yojson.Safe.json
end =
struct
  type t =
    [
      `Float of
        float 
    | `Int of int 
    | `Padding of
Padding.t ]

  let to_yojson =
    function
    | `Padding v ->
        ((fun
           (x :
Padding.t)
            ->
           (Padding.to_yojson
           x : 
Yojson.Safe.json)))
          v
    | `Int v ->
        ((fun
           (i : int)
            ->
           (`Int i : 
Yojson.Safe.json)))
          v
    | `Float v ->
        ((fun
           (f :
           float) 
           ->
           (`Float f : 
Yojson.Safe.json)))
v                                                              
end and
Orient:
                                                              sig
  type t =
    [
      `Horizontal
       | 
      `Vertical ]
  val to_yojson
    :
    t ->
Yojson.Safe.json
end =
struct
  type t =
    [
      `Horizontal
       | 
      `Vertical ]

  let to_yojson
    =
    function
    | `Vertical
      ->
      `String
      "vertical"
    | `Horizontal
      ->
      `String
"horizontal"                                                                   
end and
OrderFieldDef:
                                                                   sig
 type nonrec t =
 {
 typ:
Type.t ;
 timeUnit:
TimeUnit.t
 option ;
 sort:
SortOrder.t
 option ;
 field:
Field.t
 option ;
 bin:
 [
 `Bool of
 bool 
 | `Params
 of
BinParams.t
 ] option ;
 aggregate:
Aggregate.t
 option }
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
 val make
 :
 ?aggregate:Aggregate.t
 ->
 ?bin:
 [
 `Bool of
 bool 
 | `Params
 of
BinParams.t
 ] ->
 ?field:Field.t
 ->
 ?sort:SortOrder.t
 ->
 ?timeUnit:TimeUnit.t
 ->
 typ:Type.t
 ->
 unit -> t
 val
 withAggregate
 :
Aggregate.t
 -> 
 t -> t
 val
 withBin :
 [
 `Bool of
 bool 
 | `Params
 of
BinParams.t
 ] ->
 t -> t
 val
 withField
 :
Field.t
 -> 
 t -> t
 val
 withSort
 :
SortOrder.t
 -> 
 t -> t
 val
 withTimeUnit
 :
TimeUnit.t
 -> 
 t -> t
 val
 withTyp :
Type.t ->
 t -> t
end =
struct
 type nonrec t =
 {
 typ:
Type.t ;
 timeUnit:
TimeUnit.t
 option ;
 sort:
SortOrder.t
 option ;
 field:
Field.t
 option ;
 bin:
 [
 `Bool of
 bool 
 | `Params
 of
BinParams.t
 ] option ;
 aggregate:
Aggregate.t
 option }

  (** Fields
  
    type:
      The encoded field's type of measurement. This can be either a full type
      name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and `"nominal"`).
  
    timeUnit:
      Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).
      
      __Default value:__ `undefined` (None)
  
    sort:
      The sort order. One of `"ascending"` (default) or `"descending"`.
  
    field:
      __Required.__ A string defining the name of the field from which to pull a data value
      or an object defining iterated values from the [`repeat`](repeat.html) operator.
      
      __Note:__ `field` is not required if `aggregate` is `count`.
  
    bin:
      A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).
      If `true`, default [binning parameters](bin.html) will be applied.
      
      __Default value:__ `false`
  
    aggregate:
      Aggregation function for the field
      (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
      
      __Default value:__ `undefined` (None)
  *)
 let to_yojson
 x =
 `Assoc
 (List.filter
 (fun
 (k,v)  ->
 match v
 with
 | 
 `Null ->
 false
 | 
 _ -> true)
 [
 ("aggregate",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
Aggregate.t)
  ->
 (Aggregate.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.aggregate));
 ("bin",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Params
 v ->
 ((fun
 (x :
BinParams.t)
  ->
 (BinParams.to_yojson
 x : Yojson.Safe.json)))
 v
 | `Bool v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v)) v))
 x.bin));
 ("field",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
Field.t) 
 ->
 (Field.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.field));
 ("sort",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
SortOrder.t)
  ->
 (SortOrder.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.sort));
 ("timeUnit",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
TimeUnit.t)
  ->
 (TimeUnit.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.timeUnit));
 ("type",
 (((fun
 (x :
Type.t) 
 ->
 (Type.to_yojson
 x : Yojson.Safe.json)))
 x.typ))]) 
 let make
 ?aggregate
  ?bin 
 ?field 
 ?sort 
 ?timeUnit
  ~typ  ()
 =
 {
 typ;
 timeUnit;
 sort;
 field;
 bin;
 aggregate
 } 
 let withAggregate
 v x =
 {
 x with
 aggregate
 =
 (Some v)
 } 
 let withBin
 v x =
 {
 x with
 bin =
 (Some v)
 } 
 let withField
 v x =
 {
 x with
 field =
 (Some v)
 } 
 let withSort
 v x =
 {
 x with
 sort =
 (Some v)
 } 
 let withTimeUnit
 v x =
 {
 x with
 timeUnit
 =
 (Some v)
 } 
 let withTyp
 v x =
 {
 x with
 typ = v
 } 
end
and
OrFilter:sig
  type t = FilterOperand.t list
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = FilterOperand.t list

  let to_yojson x =
    `Assoc
      [("or",
         (((fun (l : FilterOperand.t list)  ->
              let yojson_of_el (x : FilterOperand.t) =
                (FilterOperand.to_yojson x : Yojson.Safe.json)  in
(`List (List.map yojson_of_el l) : Yojson.Safe.json))) x))]       
end and
OneOfFilter:sig
  type nonrec t =
    {
    timeUnit: TimeUnit.t option ;
    oneOf:
      [ `Strings of string list 
      | `Nums of [ `Int of int  | `Float of float ] list 
      | `Bools of bool list 
      | `DateTimes of DateTime.t list ] ;
    field: string }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?timeUnit:TimeUnit.t ->
      field:string ->
        oneOf:[ `Strings of string list 
              | `Nums of
                  [ `Int of int  | `Float of float ] list 
              | `Bools of bool list 
              | `DateTimes of DateTime.t list ]
          -> unit -> t
  val withField : string -> t -> t
  val withOneOf :
    [ `Strings of string list 
    | `Nums of [ `Int of int  | `Float of float ] list 
    | `Bools of bool list 
    | `DateTimes of DateTime.t list ] -> t -> t
  val withTimeUnit : TimeUnit.t -> t -> t
end =
struct
  type nonrec t =
    {
    timeUnit: TimeUnit.t option ;
    oneOf:
      [ `Strings of string list 
      | `Nums of [ `Int of int  | `Float of float ] list 
      | `Bools of bool list  | `DateTimes of DateTime.t list ] ;
    field: string }

  (** Fields
  
    timeUnit:
      time unit for the field to be filtered.
  
    oneOf:
      A set of values that the `field`'s value should be a member of,
      for a data item included in the filtered data.
  
    field:
      Field to be filtered
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("field",
            (((fun (s : string)  -> (`String s : Yojson.Safe.json)))
               x.field));
         ("oneOf",
           (((function
              | `DateTimes v ->
                  ((fun (l : DateTime.t list)  ->
                      let yojson_of_el (x : DateTime.t) =
                        (DateTime.to_yojson x : Yojson.Safe.json)  in
                      (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
                    v
              | `Bools v ->
                  ((fun (l : bool list)  ->
                      let yojson_of_el (b : bool) =
                        (`Bool b : Yojson.Safe.json)  in
                      (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
                    v
              | `Nums v ->
                  ((fun (l : [ `Int of int  | `Float of float ] list) 
                      ->
                      let yojson_of_el =
                        function
                        | `Int i -> `Int i
                        | `Float f -> `Float f  in
                      (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
                    v
              | `Strings v ->
                  ((fun (l : string list)  ->
                      let yojson_of_el (s : string) =
                        (`String s : Yojson.Safe.json)  in
                      (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
                    v)) x.oneOf));
         ("timeUnit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : TimeUnit.t)  ->
                      (TimeUnit.to_yojson x : Yojson.Safe.json))) v))
x.timeUnit))])            
  let make ?timeUnit  ~field  ~oneOf  () = { oneOf; field; timeUnit } 
  let withField v x = { x with field = v } 
  let withOneOf v x = { x with oneOf = v } 
  let withTimeUnit v x = { x with timeUnit = (Some v) } 
end and
NotFilter:sig
  type t = FilterOperand.t
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = FilterOperand.t

  let to_yojson x =
    `Assoc
      [("not",
         (((fun (x : FilterOperand.t)  ->
(FilterOperand.to_yojson x : Yojson.Safe.json))) x))]                 
end and
NiceTime:sig
  type t =
    [ `Second  | `Minute  | `Hour  | `Day  | 
      `Week 
    | `Month  | `Year ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Second  | `Minute  | `Hour  | `Day  | `Week 
    | `Month  | `Year ]

  let to_yojson =
    function
    | `Year -> `String "year"
    | `Month -> `String "month"
    | `Week -> `String "week"
    | `Day -> `String "day"
    | `Hour -> `String "hour"
    | `Minute -> `String "minute"
    | `Second -> `String "second" 
end and
NamedData:sig
  type nonrec t =
    {
    name: string ;
    format: DataFormat.t option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?format:DataFormat.t ->
      name:string -> unit -> t
  val withFormat : DataFormat.t -> t -> t
  val withName : string -> t -> t
end =
struct
  type nonrec t =
    {
    name: string ;
    format: DataFormat.t option }

  (** Fields
  
    name:
      Provide a placeholder name and bind data at runtime.
  
    format:
      An object that specifies the format for parsing the data.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("format",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : DataFormat.t)  ->
                       (DataFormat.to_yojson x : 
Yojson.Safe.json))) v)) x.format));
         ("name",
           (((fun (s : string)  ->
(`String s : Yojson.Safe.json))) x.name))])                           
  let make ?format  ~name  () = { name; format } 
  let withFormat v x = { x with format = (Some v) } 
  let withName v x = { x with name = v } 
end and
MultiTimeUnit:sig
  type t =
    [
      `Local of LocalMultiTimeUnit.t 
    | `UMulti of UtcMultiTimeUnit.t ]
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Local of LocalMultiTimeUnit.t 
    | `UMulti of UtcMultiTimeUnit.t ]

  let to_yojson =
    function
    | `UMulti v ->
        ((fun (x : UtcMultiTimeUnit.t)  ->
            (UtcMultiTimeUnit.to_yojson x : 
Yojson.Safe.json))) v
    | `Local v ->
        ((fun (x : LocalMultiTimeUnit.t)  ->
            (LocalMultiTimeUnit.to_yojson x : 
Yojson.Safe.json))) v                                
end and
MultiSelectionConfig:sig
  type nonrec t =
    {
    toggle:
      [ `Bool of bool 
      | `String of
          string ]
        option
      ;
    resolve:
SelectionResolution.t
        option
      ;
    on:
VgEventStream.t
        option
      ;
    nearest: bool option ;
    fields:
      string list option ;
    encodings:
SingleDefChannel.t
        list option
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?encodings:SingleDefChannel.t
      list ->
      ?fields:string
        list ->
        ?nearest:bool ->
          ?on:VgEventStream.t
            ->
            ?resolve:SelectionResolution.t
              ->
              ?toggle:
               [
               `Bool of
               bool 
               | `String
               of string ]
               ->
               unit -> t
  val withEncodings :
SingleDefChannel.t
      list -> t -> t
  val withFields :
    string list ->
      t -> t
  val withNearest :
    bool -> t -> t
  val withOn :
VgEventStream.t ->
      t -> t
  val withResolve :
SelectionResolution.t
      -> t -> t
  val withToggle :
    [ `Bool of bool 
    | `String of string ]
      -> t -> t
end =
struct
  type nonrec t =
    {
    toggle:
      [ `Bool of bool  | `String of string ]
        option
      ;
    resolve: SelectionResolution.t option ;
    on: VgEventStream.t option ;
    nearest: bool option ;
    fields: string list option ;
    encodings: SingleDefChannel.t list option }

  (** Fields
  
    toggle:
      Controls whether data values should be toggled or only ever inserted into
      multi selections. Can be `true`, `false` (for insertion only), or a
      [Vega expression](https://vega.github.io/vega/docs/expressions/).
      
      __Default value:__ `true`, which corresponds to `event.shiftKey` (i.e.,
      data values are toggled when a user interacts with the shift-key pressed).
      
      See the [toggle transform](toggle.html) documentation for more information.
  
    resolve:
      With layered and multi-view displays, a strategy that determines how
      selections' data queries are resolved when applied in a filter transform,
      conditional encoding rule, or scale domain.
  
    on:
      A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.
      For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
  
    nearest:
      When true, an invisible voronoi diagram is computed to accelerate discrete
      selection. The data value _nearest_ the mouse cursor is added to the selection.
      
      See the [nearest transform](nearest.html) documentation for more information.
  
    fields:
      An array of field names whose values must match for a data tuple to
      fall within the selection.
  
    encodings:
      An array of encoding channels. The corresponding data field values
      must match for a data tuple to fall within the selection.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("encodings",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun
                       (l :
SingleDefChannel.t
                           list)
                        ->
                       let yojson_of_el
                         (x :
SingleDefChannel.t)
                         =
                         (SingleDefChannel.to_yojson
                            x : Yojson.Safe.json)
                          in
                       (`List
                          (List.map
                             yojson_of_el l) : 
Yojson.Safe.json)))
                     v)) x.encodings));
         ("fields",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : string list)  ->
                      let yojson_of_el
                        (s : string) =
                        (`String s : 
Yojson.Safe.json)  in
                      (`List
                         (List.map
                            yojson_of_el l) : 
Yojson.Safe.json))) v))
              x.fields));
         ("nearest",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  ->
                      (`Bool b : Yojson.Safe.json)))
                    v)) x.nearest));
         ("on",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : VgEventStream.t)
                       ->
                      (VgEventStream.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.on));
         ("resolve",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
SelectionResolution.t)
                       ->
                      (SelectionResolution.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.resolve));
         ("toggle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `String v ->
                        ((fun (s : string) 
                            ->
                            (`String s : 
Yojson.Safe.json)))
                          v
                    | `Bool v ->
                        ((fun (b : bool)  ->
                            (`Bool b : 
Yojson.Safe.json)))
v)) v)) x.toggle))])                                     
  let make ?encodings  ?fields  ?nearest  ?on
     ?resolve  ?toggle  () =
    {
      toggle;
      resolve;
      on;
      nearest;
      fields;
      encodings
    } 
  let withEncodings v x =
    { x with encodings = (Some v) } 
  let withFields v x =
    { x with fields = (Some v) } 
  let withNearest v x =
    { x with nearest = (Some v) } 
  let withOn v x = { x with on = (Some v) } 
  let withResolve v x =
    { x with resolve = (Some v) } 
  let withToggle v x =
    { x with toggle = (Some v) } 
end and
MultiSelection:sig
  type nonrec t =
    {
    typ: [ `Multi ] ;
    toggle:
      [ `Bool of bool 
      | `String of string ]
        option
      ;
    resolve:
SelectionResolution.t
        option
      ;
    on:
VgEventStream.t
        option
      ;
    nearest: bool option ;
    fields:
      string list option ;
    encodings:
SingleDefChannel.t
        list option
      }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?encodings:SingleDefChannel.t
      list ->
      ?fields:string list
        ->
        ?nearest:bool ->
          ?on:VgEventStream.t
            ->
            ?resolve:SelectionResolution.t
              ->
              ?toggle:
                [
                `Bool of
                bool 
                | `String
                of string ]
                ->
                typ:
                [
                `Multi ]
                ->
                unit -> t
  val withEncodings :
SingleDefChannel.t
      list -> t -> t
  val withFields :
    string list -> t -> t
  val withNearest :
    bool -> t -> t
  val withOn :
VgEventStream.t ->
      t -> t
  val withResolve :
SelectionResolution.t
      -> t -> t
  val withToggle :
    [ `Bool of bool 
    | `String of string ]
      -> t -> t
  val withTyp :
    [ `Multi ] -> t -> t
end =
struct
  type nonrec t =
    {
    typ: [ `Multi ] ;
    toggle:
      [ `Bool of bool 
      | `String of string ] option ;
    resolve:
SelectionResolution.t option ;
    on: VgEventStream.t option ;
    nearest: bool option ;
    fields: string list option ;
    encodings:
SingleDefChannel.t list option }

  (** Fields
  
    toggle:
      Controls whether data values should be toggled or only ever inserted into
      multi selections. Can be `true`, `false` (for insertion only), or a
      [Vega expression](https://vega.github.io/vega/docs/expressions/).
      
      __Default value:__ `true`, which corresponds to `event.shiftKey` (i.e.,
      data values are toggled when a user interacts with the shift-key pressed).
      
      See the [toggle transform](toggle.html) documentation for more information.
  
    resolve:
      With layered and multi-view displays, a strategy that determines how
      selections' data queries are resolved when applied in a filter transform,
      conditional encoding rule, or scale domain.
  
    on:
      A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.
      For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
  
    nearest:
      When true, an invisible voronoi diagram is computed to accelerate discrete
      selection. The data value _nearest_ the mouse cursor is added to the selection.
      
      See the [nearest transform](nearest.html) documentation for more information.
  
    fields:
      An array of field names whose values must match for a data tuple to
      fall within the selection.
  
    encodings:
      An array of encoding channels. The corresponding data field values
      must match for a data tuple to fall within the selection.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("encodings",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun
                       (l :
SingleDefChannel.t
                           list)
                        ->
                       let yojson_of_el
                         (x :
SingleDefChannel.t)
                         =
                         (SingleDefChannel.to_yojson
                            x : 
Yojson.Safe.json)
                          in
                       (`List
                          (List.map
                             yojson_of_el
                             l) : 
Yojson.Safe.json)))
                     v)) x.encodings));
         ("fields",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (l : string list) 
                      ->
                      let yojson_of_el
                        (s : string) =
                        (`String s : 
Yojson.Safe.json)
                         in
                      (`List
                         (List.map
                            yojson_of_el
                            l) : 
Yojson.Safe.json)))
                    v)) x.fields));
         ("nearest",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  ->
                      (`Bool b : 
Yojson.Safe.json)))
                    v)) x.nearest));
         ("on",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
VgEventStream.t)
                       ->
                      (VgEventStream.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.on));
         ("resolve",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
SelectionResolution.t)
                       ->
                      (SelectionResolution.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.resolve));
         ("toggle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `String v ->
                        ((fun
                            (s : string)
                             ->
                            (`String s : 
Yojson.Safe.json)))
                          v
                    | `Bool v ->
                        ((fun (b : bool)
                             ->
                            (`Bool b : 
Yojson.Safe.json)))
                          v)) v))
              x.toggle));
         ("type",
           (((function
              | `Multi ->
                  `String "multi"))
x.typ))])                                          
  let make ?encodings  ?fields  ?nearest
     ?on  ?resolve  ?toggle  ~typ  () =
    {
      typ;
      toggle;
      resolve;
      on;
      nearest;
      fields;
      encodings
    } 
  let withEncodings v x =
    { x with encodings = (Some v) } 
  let withFields v x =
    { x with fields = (Some v) } 
  let withNearest v x =
    { x with nearest = (Some v) } 
  let withOn v x =
    { x with on = (Some v) } 
  let withResolve v x =
    { x with resolve = (Some v) } 
  let withToggle v x =
    { x with toggle = (Some v) } 
  let withTyp v x = { x with typ = v } 
end and
Month:sig
  type t =
    [ `Int of int 
    | `Float of float ]
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Int of int 
    | `Float of float ]

  let to_yojson =
    function
    | `Int i -> `Int i
    | `Float f -> `Float f 
end and
MarkDef:sig
  type nonrec t =
    {
    typ: Mark.t ;
    tension:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    style:
      [
        `String of
          string 
      | `Strings of
          string list ]
        option
      ;
    orient:
Orient.t option ;
    interpolate:
Interpolate.t
        option
      ;
    filled:
      bool option ;
    clip: bool option }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?clip:bool ->
      ?filled:bool ->
        ?interpolate:Interpolate.t
          ->
          ?orient:Orient.t
            ->
            ?style:
             [
             `String
             of 
             string 
             | `Strings
             of
             string
             list ] ->
             ?tension:
             [
             `Int of
             int 
             | `Float
             of float ]
             ->
             typ:Mark.t
             ->
             unit -> t
  val withClip :
    bool -> t -> t
  val withFilled :
    bool -> t -> t
  val withInterpolate
    :
Interpolate.t ->
      t -> t
  val withOrient :
Orient.t -> t -> t
  val withStyle :
    [
      `String of
        string 
    | `Strings of
        string list ]
      -> t -> t
  val withTension :
    [ `Int of int 
    | `Float of float ]
      -> t -> t
  val withTyp :
Mark.t -> t -> t
end =
struct
  type nonrec t =
    {
    typ: Mark.t ;
    tension:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    style:
      [ `String of string 
      | `Strings of
          string list ]
        option
      ;
    orient: Orient.t option ;
    interpolate:
Interpolate.t option ;
    filled: bool option ;
    clip: bool option }

  (** Fields
  
    type:
      The mark type.
      One of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`,
      `"area"`, `"point"`, `"rule"`, and `"text"`.
  
    tension:
      Depending on the interpolation type, sets the tension parameter (for line and area marks).
      
      TODO: provide the link to D3 docs.
  
    style:
      A string or array of strings indicating the name of custom styles to apply to the mark. A style is a named collection of mark property defaults defined within the [configuration](config.html). If style is an array, later styles will override earlier styles. Any [mark properties](encoding.html#mark-prop) explicitly defined within the `encoding` will override a style default.
      
      __Default value:__ The mark's name.  For example, a bar mark will have style `"bar"` by default.
  
    orient:
      Orientation of the marks.
  
    interpolate:
      The line interpolation method to use for line and area marks. One of the following:
      - `"linear"`: piecewise linear segments, as in a polyline.
      - `"linear-closed"`: close the linear segments to form a polygon.
      - `"step"`: alternate between horizontal and vertical segments, as in a step function.
      - `"step-before"`: alternate between vertical and horizontal segments, as in a step function.
      - `"step-after"`: alternate between horizontal and vertical segments, as in a step function.
      - `"basis"`: a B-spline, with control point duplication on the ends.
      - `"basis-open"`: an open B-spline; may not intersect the start or end.
      - `"basis-closed"`: a closed B-spline, as in a loop.
      - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
      - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
      - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
      - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the spline.
      - `"monotone"`: cubic interpolation that preserves monotonicity in y.
      
      For more information about each interpolation method, please see [Vega's line interpolation docs](https://vega.github.io/vega/docs/marks/line/).
  
    filled:
      Whether the mark's color should be used as fill color instead of stroke color.
      
      __Default value:__ All marks except `"point"`, `"line"`, and `"rule"` are filled by default.
  
    clip:
      Whether a mark be clipped to the enclosing groups width and height.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("clip",
            (((function
               | None  ->
                   `Null
               | Some v ->
                   ((fun
                     (b :
                     bool)  ->
                     (`Bool b : 
Yojson.Safe.json)))
                     v))
               x.clip));
         ("filled",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (b :
                     bool)  ->
                     (`Bool b : 
Yojson.Safe.json)))
                    v))
              x.filled));
         ("interpolate",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (x :
Interpolate.t)
                      ->
                     (Interpolate.to_yojson
                     x : 
Yojson.Safe.json)))
                    v))
              x.interpolate));
         ("orient",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (x :
Orient.t)
                      ->
                     (Orient.to_yojson
                     x : 
Yojson.Safe.json)))
                    v))
              x.orient));
         ("style",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Strings v
                     ->
                     ((fun
                     (l :
                     string
                     list)  ->
                     let yojson_of_el
                     (s :
                     string) =
                     (`String
                     s : 
Yojson.Safe.json)
                      in
                     (`List
                     (List.map
                     yojson_of_el
                     l) : 
Yojson.Safe.json)))
                     v
                    | 
                    `String v
                     ->
                     ((fun
                     (s :
                     string) 
                     ->
                     (`String
                     s : Yojson.Safe.json)))
                     v)) v))
              x.style));
         ("tension",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.tension));
         ("type",
           (((fun (x : Mark.t)
                 ->
                (Mark.to_yojson
                   x : 
Yojson.Safe.json)))
x.typ))])                                                    
  let make ?clip  ?filled 
    ?interpolate  ?orient 
    ?style  ?tension  ~typ  ()
    =
    {
      typ;
      tension;
      style;
      orient;
      interpolate;
      filled;
      clip
    } 
  let withClip v x =
    { x with clip = (Some v) } 
  let withFilled v x =
    { x with filled = (Some v)
    } 
  let withInterpolate v x =
    {
      x with
      interpolate = (Some v)
    } 
  let withOrient v x =
    { x with orient = (Some v)
    } 
  let withStyle v x =
    { x with style = (Some v)
    } 
  let withTension v x =
    {
      x with
      tension = (Some v)
    } 
  let withTyp v x =
    { x with typ = v } 
end and
MarkConfigMixins:
                                                    sig
  type nonrec t =
    {
    tick:
TickConfig.t option ;
    text:
TextConfig.t option ;
    square:
MarkConfig.t option ;
    rule:
MarkConfig.t option ;
    rect:
MarkConfig.t option ;
    point:
MarkConfig.t option ;
    mark:
MarkConfig.t option ;
    line:
MarkConfig.t option ;
    circle:
MarkConfig.t option ;
    bar:
BarConfig.t option ;
    area:
MarkConfig.t option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?area:MarkConfig.t ->
      ?bar:BarConfig.t ->
        ?circle:MarkConfig.t
          ->
          ?line:MarkConfig.t
            ->
            ?mark:MarkConfig.t
              ->
              ?point:MarkConfig.t
                ->
                ?rect:MarkConfig.t
                ->
                ?rule:MarkConfig.t
                ->
                ?square:MarkConfig.t
                ->
                ?text:TextConfig.t
                ->
                ?tick:TickConfig.t
                ->
                unit -> t
  val withArea :
MarkConfig.t ->
      t -> t
  val withBar :
BarConfig.t -> t -> t
  val withCircle :
MarkConfig.t ->
      t -> t
  val withLine :
MarkConfig.t ->
      t -> t
  val withMark :
MarkConfig.t ->
      t -> t
  val withPoint :
MarkConfig.t ->
      t -> t
  val withRect :
MarkConfig.t ->
      t -> t
  val withRule :
MarkConfig.t ->
      t -> t
  val withSquare :
MarkConfig.t ->
      t -> t
  val withText :
TextConfig.t ->
      t -> t
  val withTick :
TickConfig.t ->
      t -> t
end =
struct
  type nonrec t =
    {
    tick:
TickConfig.t option ;
    text:
TextConfig.t option ;
    square:
MarkConfig.t option ;
    rule:
MarkConfig.t option ;
    rect:
MarkConfig.t option ;
    point:
MarkConfig.t option ;
    mark:
MarkConfig.t option ;
    line:
MarkConfig.t option ;
    circle:
MarkConfig.t option ;
    bar:
BarConfig.t option ;
    area:
MarkConfig.t option }

  (** Fields
  
    tick:
      Tick-Specific Config 
  
    text:
      Text-Specific Config 
  
    square:
      Square-Specific Config 
  
    rule:
      Rule-Specific Config 
  
    rect:
      Rect-Specific Config 
  
    point:
      Point-Specific Config 
  
    mark:
      Mark Config 
  
    line:
      Line-Specific Config 
  
    circle:
      Circle-Specific Config 
  
    bar:
      Bar-Specific Config 
  
    area:
      Area-Specific Config 
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null ->
                false
            | _ -> true)
         [("area",
            (((function
               | 
None  ->
                `Null
               | 
Some v ->
                ((fun
                (x :
MarkConfig.t)
                 ->
                (MarkConfig.to_yojson
                x : Yojson.Safe.json)))
                v))
               x.area));
         ("bar",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
BarConfig.t)
                 ->
                (BarConfig.to_yojson
                x : Yojson.Safe.json)))
                v)) x.bar));
         ("circle",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
MarkConfig.t)
                 ->
                (MarkConfig.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.circle));
         ("line",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
MarkConfig.t)
                 ->
                (MarkConfig.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.line));
         ("mark",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
MarkConfig.t)
                 ->
                (MarkConfig.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.mark));
         ("point",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
MarkConfig.t)
                 ->
                (MarkConfig.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.point));
         ("rect",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
MarkConfig.t)
                 ->
                (MarkConfig.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.rect));
         ("rule",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
MarkConfig.t)
                 ->
                (MarkConfig.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.rule));
         ("square",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
MarkConfig.t)
                 ->
                (MarkConfig.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.square));
         ("text",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
TextConfig.t)
                 ->
                (TextConfig.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.text));
         ("tick",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
TickConfig.t)
                 ->
                (TickConfig.to_yojson
                x : Yojson.Safe.json)))
                v))
x.tick))])                                                         
  let make ?area  ?bar 
    ?circle  ?line  ?mark
     ?point  ?rect  ?rule
     ?square  ?text 
    ?tick  () =
    {
      tick;
      text;
      square;
      rule;
      rect;
      point;
      mark;
      line;
      circle;
      bar;
      area
    } 
  let withArea v x =
    {
      x with
      area = (Some v)
    } 
  let withBar v x =
    {
      x with
      bar = (Some v)
    } 
  let withCircle v x =
    {
      x with
      circle = (Some v)
    } 
  let withLine v x =
    {
      x with
      line = (Some v)
    } 
  let withMark v x =
    {
      x with
      mark = (Some v)
    } 
  let withPoint v x =
    {
      x with
      point = (Some v)
    } 
  let withRect v x =
    {
      x with
      rect = (Some v)
    } 
  let withRule v x =
    {
      x with
      rule = (Some v)
    } 
  let withSquare v x =
    {
      x with
      square = (Some v)
    } 
  let withText v x =
    {
      x with
      text = (Some v)
    } 
  let withTick v x =
    {
      x with
      tick = (Some v)
    } 
end and
MarkConfig:sig
                                                                    type nonrec t =
                                                                    {
                                                                    theta:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    text:
                                                                    string
                                                                    option ;
                                                                    tension:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    strokeWidth:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    strokeOpacity:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    strokeDashOffset:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    strokeDash:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    list
                                                                    option ;
                                                                    stroke:
                                                                    string
                                                                    option ;
                                                                    size:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    shape:
                                                                    string
                                                                    option ;
                                                                    radius:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    orient:
Orient.t
                                                                    option ;
                                                                    opacity:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    limit:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    interpolate:
Interpolate.t
                                                                    option ;
                                                                    fontWeight:
                                                                    [
                                                                    `FontWeight
                                                                    of
FontWeight.t
 | 
                                                                    `Num of
FontWeightNumber.t
                                                                    ] option ;
                                                                    fontStyle:
FontStyle.t
                                                                    option ;
                                                                    fontSize:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    font:
                                                                    string
                                                                    option ;
                                                                    filled:
                                                                    bool
                                                                    option ;
                                                                    fillOpacity:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    fill:
                                                                    string
                                                                    option ;
                                                                    dy:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    dx:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    color:
                                                                    string
                                                                    option ;
                                                                    baseline:
VerticalAlign.t
                                                                    option ;
                                                                    angle:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    option ;
                                                                    align:
HorizontalAlign.t
                                                                    option }
                                                                    val
                                                                    to_yojson
                                                                    :
                                                                    t ->
Yojson.Safe.json
                                                                    val make
                                                                    :
                                                                    ?align:HorizontalAlign.t
                                                                    ->
                                                                    ?angle:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?baseline:VerticalAlign.t
                                                                    ->
                                                                    ?color:string
                                                                    ->
                                                                    ?dx:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?dy:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?fill:string
                                                                    ->
                                                                    ?fillOpacity:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?filled:bool
                                                                    ->
                                                                    ?font:string
                                                                    ->
                                                                    ?fontSize:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?fontStyle:FontStyle.t
                                                                    ->
                                                                    ?fontWeight:
                                                                    [
                                                                    `FontWeight
                                                                    of
FontWeight.t
 | 
                                                                    `Num of
FontWeightNumber.t
                                                                    ] ->
                                                                    ?interpolate:Interpolate.t
                                                                    ->
                                                                    ?limit:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?opacity:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?orient:Orient.t
                                                                    ->
                                                                    ?radius:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?shape:string
                                                                    ->
                                                                    ?size:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?stroke:string
                                                                    ->
                                                                    ?strokeDash:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    list ->
                                                                    ?strokeDashOffset:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?strokeOpacity:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?strokeWidth:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?tension:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    ?text:string
                                                                    ->
                                                                    ?theta:
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    ->
                                                                    unit -> t
                                                                    val
                                                                    withAlign
                                                                    :
HorizontalAlign.t
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withAngle
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withBaseline
                                                                    :
VerticalAlign.t
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withColor
                                                                    :
                                                                    string ->
                                                                    t -> t
                                                                    val
                                                                    withDx :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withDy :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withFill
                                                                    :
                                                                    string ->
                                                                    t -> t
                                                                    val
                                                                    withFillOpacity
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withFilled
                                                                    :
                                                                    bool ->
                                                                    t -> t
                                                                    val
                                                                    withFont
                                                                    :
                                                                    string ->
                                                                    t -> t
                                                                    val
                                                                    withFontSize
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withFontStyle
                                                                    :
FontStyle.t
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withFontWeight
                                                                    :
                                                                    [
                                                                    `FontWeight
                                                                    of
FontWeight.t
 | 
                                                                    `Num of
FontWeightNumber.t
                                                                    ] ->
                                                                    t -> t
                                                                    val
                                                                    withInterpolate
                                                                    :
Interpolate.t
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withLimit
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withOpacity
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withOrient
                                                                    :
Orient.t
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withRadius
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withShape
                                                                    :
                                                                    string ->
                                                                    t -> t
                                                                    val
                                                                    withSize
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withStroke
                                                                    :
                                                                    string ->
                                                                    t -> t
                                                                    val
                                                                    withStrokeDash
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    list ->
                                                                    t -> t
                                                                    val
                                                                    withStrokeDashOffset
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withStrokeOpacity
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withStrokeWidth
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withTension
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
                                                                    val
                                                                    withText
                                                                    :
                                                                    string ->
                                                                    t -> t
                                                                    val
                                                                    withTheta
                                                                    :
                                                                    [
                                                                    `Int of
                                                                    int 
                                                                    | `Float
                                                                    of float ]
                                                                    -> 
                                                                    t -> t
end =
struct
  type nonrec t =
    {
    theta:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    text:
      string option ;
    tension:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    strokeWidth:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    strokeOpacity:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    strokeDashOffset:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    strokeDash:
      [ `Int of int 
      | `Float of
          float ]
        list option
      ;
    stroke:
      string option ;
    size:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    shape:
      string option ;
    radius:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    orient:
Orient.t
        option
      ;
    opacity:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    limit:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    interpolate:
Interpolate.t
        option
      ;
    fontWeight:
      [
        `FontWeight
          of
FontWeight.t
           | 
        `Num of
FontWeightNumber.t
          ]
        option
      ;
    fontStyle:
FontStyle.t
        option
      ;
    fontSize:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    font:
      string option ;
    filled:
      bool option ;
    fillOpacity:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    fill:
      string option ;
    dy:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    dx:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    color:
      string option ;
    baseline:
VerticalAlign.t
        option
      ;
    angle:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    align:
HorizontalAlign.t
        option
      }

  (** Fields
  
    theta:
      Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating "north".
  
    text:
      Placeholder text if the `text` channel is not specified
  
    tension:
      Depending on the interpolation type, sets the tension parameter (for line and area marks).
  
    strokeWidth:
      The stroke width, in pixels.
  
    strokeOpacity:
      The stroke opacity (value between [0,1]).
      
      __Default value:__ `1`
  
    strokeDashOffset:
      The offset (in pixels) into which to begin drawing with the stroke dash array.
  
    strokeDash:
      An array of alternating stroke, space lengths for creating dashed or dotted lines.
  
    stroke:
      Default Stroke Color.  This has higher precedence than config.color
      
      __Default value:__ (None)
  
    size:
      The pixel area each the point/circle/square.
      For example: in the case of circles, the radius is determined in part by the square root of the size value.
      
      __Default value:__ `30`
  
    shape:
      The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
      
      __Default value:__ `"circle"`
  
    radius:
      Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.
  
    orient:
      The orientation of a non-stacked bar, tick, area, and line charts.
      The value is either horizontal (default) or vertical.
      - For bar, rule and tick, this determines whether the size of the bar and tick
      should be applied to x or y dimension.
      - For area, this property determines the orient property of the Vega output.
      - For line, this property determines the sort order of the points in the line
      if `config.sortLineBy` is not specified.
      For stacked charts, this is always determined by the orientation of the stack;
      therefore explicitly specified value will be ignored.
  
    opacity:
      The overall opacity (value between [0,1]).
      
      __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
  
    limit:
      The maximum length of the text mark in pixels (default 0, indicating no limit). The text value will be automatically truncated if the rendered size exceeds the limit.
  
    interpolate:
      The line interpolation method to use for line and area marks. One of the following:
      - `"linear"`: piecewise linear segments, as in a polyline.
      - `"linear-closed"`: close the linear segments to form a polygon.
      - `"step"`: alternate between horizontal and vertical segments, as in a step function.
      - `"step-before"`: alternate between vertical and horizontal segments, as in a step function.
      - `"step-after"`: alternate between horizontal and vertical segments, as in a step function.
      - `"basis"`: a B-spline, with control point duplication on the ends.
      - `"basis-open"`: an open B-spline; may not intersect the start or end.
      - `"basis-closed"`: a closed B-spline, as in a loop.
      - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
      - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
      - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
      - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the spline.
      - `"monotone"`: cubic interpolation that preserves monotonicity in y.
  
    fontWeight:
      The font weight (e.g., `"bold"`).
  
    fontStyle:
      The font style (e.g., `"italic"`).
  
    fontSize:
      The font size, in pixels.
  
    font:
      The typeface to set the text in (e.g., `"Helvetica Neue"`).
  
    filled:
      Whether the mark's color should be used as fill color instead of stroke color.
      
      __Default value:__ `true` for all marks except `point` and `false` for `point`.
      
      __Applicable for:__ `bar`, `point`, `circle`, `square`, and `area` marks.
  
    fillOpacity:
      The fill opacity (value between [0,1]).
      
      __Default value:__ `1`
  
    fill:
      Default Fill Color.  This has higher precedence than config.color
      
      __Default value:__ (None)
  
    dy:
      The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.
  
    dx:
      The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.
  
    color:
      Default color.  Note that `fill` and `stroke` have higher precedence than `color` and will override `color`.
      
      __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
  
    baseline:
      The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
      
      __Default value:__ `"middle"`
  
    angle:
      The rotation angle of the text, in degrees.
  
    align:
      The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun 
           (k,v)  ->
           match v
           with
           | 
           `Null ->
           false
           | 
           _ -> true)
         [("align",
           (((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
HorizontalAlign.t)
            ->
           (HorizontalAlign.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.align));
         ("angle",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.angle));
         ("baseline",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
VerticalAlign.t)
            ->
           (VerticalAlign.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.baseline));
         ("color",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.color));
         ("dx",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v)) x.dx));
         ("dy",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v)) x.dy));
         ("fill",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.fill));
         ("fillOpacity",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.fillOpacity));
         ("filled",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (b :
           bool)  ->
           (`Bool b : 
Yojson.Safe.json)))
           v))
           x.filled));
         ("font",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.font));
         ("fontSize",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.fontSize));
         ("fontStyle",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
FontStyle.t)
            ->
           (FontStyle.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.fontStyle));
         ("fontWeight",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Num v
           ->
           ((fun
           (x :
FontWeightNumber.t)
            ->
           (FontWeightNumber.to_yojson
           x : Yojson.Safe.json)))
           v
           | `FontWeight
           v ->
           ((fun
           (x :
FontWeight.t)
            ->
           (FontWeight.to_yojson
           x : Yojson.Safe.json)))
           v)) v))
           x.fontWeight));
         ("interpolate",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
Interpolate.t)
            ->
           (Interpolate.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.interpolate));
         ("limit",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.limit));
         ("opacity",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.opacity));
         ("orient",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
Orient.t)
            ->
           (Orient.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.orient));
         ("radius",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.radius));
         ("shape",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.shape));
         ("size",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.size));
         ("stroke",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.stroke));
         ("strokeDash",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (l :
           [
           `Int of
           int 
           | `Float
           of float ]
           list)  ->
           let yojson_of_el
           =
           function
           | 
           `Int i ->
           `Int i
           | 
           `Float f
           ->
           `Float f
            in
           (`List
           (List.map
           yojson_of_el
           l) : 
Yojson.Safe.json)))
           v))
           x.strokeDash));
         ("strokeDashOffset",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.strokeDashOffset));
         ("strokeOpacity",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.strokeOpacity));
         ("strokeWidth",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.strokeWidth));
         ("tension",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.tension));
         ("text",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v))
           x.text));
         ("theta",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
x.theta))])                                                              
  let make ?align 
    ?angle 
    ?baseline 
    ?color  ?dx  ?dy
     ?fill 
    ?fillOpacity 
    ?filled  ?font 
    ?fontSize 
    ?fontStyle 
    ?fontWeight 
    ?interpolate 
    ?limit  ?opacity
     ?orient 
    ?radius  ?shape 
    ?size  ?stroke 
    ?strokeDash 
    ?strokeDashOffset
     ?strokeOpacity 
    ?strokeWidth 
    ?tension  ?text 
    ?theta  () =
    {
      theta;
      text;
      tension;
      strokeWidth;
      strokeOpacity;
      strokeDashOffset;
      strokeDash;
      stroke;
      size;
      shape;
      radius;
      orient;
      opacity;
      limit;
      interpolate;
      fontWeight;
      fontStyle;
      fontSize;
      font;
      filled;
      fillOpacity;
      fill;
      dy;
      dx;
      color;
      baseline;
      angle;
      align
    } 
  let withAlign v x
    =
    {
      x with
      align =
        (Some v)
    } 
  let withAngle v x
    =
    {
      x with
      angle =
        (Some v)
    } 
  let withBaseline v
    x =
    {
      x with
      baseline =
        (Some v)
    } 
  let withColor v x
    =
    {
      x with
      color =
        (Some v)
    } 
  let withDx v x =
    {
      x with
      dx = (Some v)
    } 
  let withDy v x =
    {
      x with
      dy = (Some v)
    } 
  let withFill v x =
    {
      x with
      fill =
        (Some v)
    } 
  let withFillOpacity
    v x =
    {
      x with
      fillOpacity =
        (Some v)
    } 
  let withFilled v x
    =
    {
      x with
      filled =
        (Some v)
    } 
  let withFont v x =
    {
      x with
      font =
        (Some v)
    } 
  let withFontSize v
    x =
    {
      x with
      fontSize =
        (Some v)
    } 
  let withFontStyle
    v x =
    {
      x with
      fontStyle =
        (Some v)
    } 
  let withFontWeight
    v x =
    {
      x with
      fontWeight =
        (Some v)
    } 
  let withInterpolate
    v x =
    {
      x with
      interpolate =
        (Some v)
    } 
  let withLimit v x
    =
    {
      x with
      limit =
        (Some v)
    } 
  let withOpacity v
    x =
    {
      x with
      opacity =
        (Some v)
    } 
  let withOrient v x
    =
    {
      x with
      orient =
        (Some v)
    } 
  let withRadius v x
    =
    {
      x with
      radius =
        (Some v)
    } 
  let withShape v x
    =
    {
      x with
      shape =
        (Some v)
    } 
  let withSize v x =
    {
      x with
      size =
        (Some v)
    } 
  let withStroke v x
    =
    {
      x with
      stroke =
        (Some v)
    } 
  let withStrokeDash
    v x =
    {
      x with
      strokeDash =
        (Some v)
    } 
  let withStrokeDashOffset
    v x =
    {
      x with
      strokeDashOffset
        = (Some v)
    } 
  let withStrokeOpacity
    v x =
    {
      x with
      strokeOpacity
        = (Some v)
    } 
  let withStrokeWidth
    v x =
    {
      x with
      strokeWidth =
        (Some v)
    } 
  let withTension v
    x =
    {
      x with
      tension =
        (Some v)
    } 
  let withText v x =
    {
      x with
      text =
        (Some v)
    } 
  let withTheta v x
    =
    {
      x with
      theta =
        (Some v)
    } 
end and
Mark:sig
 type t =
 [ `Area 
 | `Bar 
 | `Line 
 | `Point 
 | `Text 
 | `Tick 
 | `Rect 
 | `Rule 
 | `Circle 
 | `Square ]
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
end =
struct
  type t =
    [ `Area 
    | `Bar 
    | `Line 
    | `Point 
    | `Text 
    | `Tick 
    | `Rect 
    | `Rule 
    | `Circle 
    | `Square ]

  (** All types of primitive marks.
  *)
  let to_yojson
    =
    function
    | `Square
      ->
      `String
      "square"
    | `Circle
      ->
      `String
      "circle"
    | `Rule ->
      `String
      "rule"
    | `Rect ->
      `String
      "rect"
    | `Tick ->
      `String
      "tick"
    | `Text ->
      `String
      "text"
    | `Point ->
      `String
      "point"
    | `Line ->
      `String
      "line"
    | `Bar ->
      `String
      "bar"
    | `Area ->
      `String
"area"                                                                   
end and
LookupTransform:
                                                                   sig
 type nonrec t =
 {
 lookup:
 string ;
 from:
LookupData.t
 ;
 default:
 string
 option ;
 nameAs:
 [
 `String
 of 
 string 
 | `Strings
 of
 string
 list ]
 option }
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
 val make
 :
 ?nameAs:
 [
 `String
 of 
 string 
 | `Strings
 of
 string
 list ] ->
 ?default:string
 ->
 from:LookupData.t
 ->
 lookup:string
 ->
 unit -> t
 val
 withNameAs
 :
 [
 `String
 of 
 string 
 | `Strings
 of
 string
 list ] ->
 t -> t
 val
 withDefault
 :
 string ->
 t -> t
 val
 withFrom
 :
LookupData.t
 -> 
 t -> t
 val
 withLookup
 :
 string ->
 t -> t
end =
struct
 type nonrec t =
 {
 lookup:
 string ;
 from:
LookupData.t
 ;
 default:
 string
 option ;
 nameAs:
 [
 `String
 of 
 string 
 | `Strings
 of
 string
 list ]
 option }

  (** Fields
  
    lookup:
      key in primary data source
  
    from:
      secondary data reference
  
    default:
      (Optional) The default value to use if lookup fails
  
    as:
      (Optional) The field or fields for storing the computed formula value.
      If `from.fields` is not specified, `as` has to be a string and we put the whole object into the data
  *)
 let to_yojson
 x =
 `Assoc
 (List.filter
 (fun
 (k,v)  ->
 match v
 with
 | 
 `Null ->
 false
 | 
 _ -> true)
 [
 ("as",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Strings
 v ->
 ((fun
 (l :
 string
 list)  ->
 let yojson_of_el
 (s :
 string) =
 (`String
 s : 
Yojson.Safe.json)
  in
 (`List
 (List.map
 yojson_of_el
 l) : 
Yojson.Safe.json)))
 v
 | `String
 v ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v)) v))
 x.nameAs));
 ("default",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.default));
 ("from",
 (((fun
 (x :
LookupData.t)
  ->
 (LookupData.to_yojson
 x : Yojson.Safe.json)))
 x.from));
 ("lookup",
 (((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
x.lookup))])                                                                     
 let make
 ?nameAs 
 ?default 
 ~from 
 ~lookup 
 () =
 {
 lookup;
 from;
 default;
 nameAs
 } 
 let withNameAs
 v x =
 {
 x with
 nameAs =
 (Some v)
 } 
 let withDefault
 v x =
 {
 x with
 default =
 (Some v)
 } 
 let withFrom
 v x =
 {
 x with
 from = v
 } 
 let withLookup
 v x =
 {
 x with
 lookup =
 v
 } 
end
and
LookupData:sig
  type nonrec t =
    {
    key: string ;
    fields: string list option ;
    data: Data.t }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?fields:string list ->
      data:Data.t -> key:string -> unit -> t
  val withData : Data.t -> t -> t
  val withFields : string list -> t -> t
  val withKey : string -> t -> t
end =
struct
  type nonrec t = {
    key: string ;
    fields: string list option ;
    data: Data.t }

  (** Fields
  
    key:
      key in data to lookup
  
    fields:
      (Optional) fields in foreign data to lookup
      if not specificied, the entire object is queried
  
    data:
      secondary data source to lookup in
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("data",
            (((fun (x : Data.t)  -> (Data.to_yojson x : Yojson.Safe.json)))
               x.data));
         ("fields",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : string list)  ->
                      let yojson_of_el (s : string) =
                        (`String s : Yojson.Safe.json)  in
                      (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
                    v)) x.fields));
         ("key",
(((fun (s : string)  -> (`String s : Yojson.Safe.json))) x.key))])       
  let make ?fields  ~data  ~key  () = { key; data; fields } 
  let withData v x = { x with data = v } 
  let withFields v x = { x with fields = (Some v) } 
  let withKey v x = { x with key = v } 
end and
LocalSingleTimeUnit:sig
  type t =
    [ `Year  | `Quarter  | `Month  | `Day 
    | `Date  | `Hours  | `Minutes  | `Seconds 
    | `Milliseconds ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Year  | `Quarter  | `Month  | `Day  | `Date  | `Hours 
    | `Minutes  | `Seconds  | `Milliseconds ]

  let to_yojson =
    function
    | `Milliseconds -> `String "milliseconds"
    | `Seconds -> `String "seconds"
    | `Minutes -> `String "minutes"
    | `Hours -> `String "hours"
    | `Date -> `String "date"
    | `Day -> `String "day"
    | `Month -> `String "month"
    | `Quarter -> `String "quarter"
    | `Year -> `String "year" 
end and
LocalMultiTimeUnit:sig
  type t =
    [ `Yearquarter  | `Yearquartermonth 
    | `Yearmonth  | `Yearmonthdate 
    | `Yearmonthdatehours 
    | `Yearmonthdatehoursminutes 
    | `Yearmonthdatehoursminutesseconds 
    | `Quartermonth  | `Monthdate 
    | `Hoursminutes  | `Hoursminutesseconds 
    | `Minutesseconds 
    | `Secondsmilliseconds ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Yearquarter  | `Yearquartermonth  | `Yearmonth 
    | `Yearmonthdate  | `Yearmonthdatehours 
    | `Yearmonthdatehoursminutes 
    | `Yearmonthdatehoursminutesseconds  | `Quartermonth 
    | `Monthdate  | `Hoursminutes  | `Hoursminutesseconds 
    | `Minutesseconds  | `Secondsmilliseconds ]

  let to_yojson =
    function
    | `Secondsmilliseconds -> `String "secondsmilliseconds"
    | `Minutesseconds -> `String "minutesseconds"
    | `Hoursminutesseconds -> `String "hoursminutesseconds"
    | `Hoursminutes -> `String "hoursminutes"
    | `Monthdate -> `String "monthdate"
    | `Quartermonth -> `String "quartermonth"
    | `Yearmonthdatehoursminutesseconds ->
        `String "yearmonthdatehoursminutesseconds"
    | `Yearmonthdatehoursminutes ->
        `String "yearmonthdatehoursminutes"
    | `Yearmonthdatehours -> `String "yearmonthdatehours"
    | `Yearmonthdate -> `String "yearmonthdate"
    | `Yearmonth -> `String "yearmonth"
    | `Yearquartermonth -> `String "yearquartermonth"
    | `Yearquarter -> `String "yearquarter" 
end and
LegendResolveMap:sig
  type nonrec t =
    {
    size: ResolveMode.t option ;
    shape: ResolveMode.t option ;
    opacity: ResolveMode.t option ;
    color: ResolveMode.t option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?color:ResolveMode.t ->
      ?opacity:ResolveMode.t ->
        ?shape:ResolveMode.t ->
          ?size:ResolveMode.t -> unit -> t
  val withColor : ResolveMode.t -> t -> t
  val withOpacity : ResolveMode.t -> t -> t
  val withShape : ResolveMode.t -> t -> t
  val withSize : ResolveMode.t -> t -> t
end =
struct
  type nonrec t =
    {
    size: ResolveMode.t option ;
    shape: ResolveMode.t option ;
    opacity: ResolveMode.t option ;
    color: ResolveMode.t option }

  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("color",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : ResolveMode.t)  ->
                       (ResolveMode.to_yojson x : Yojson.Safe.json)))
                     v)) x.color));
         ("opacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : ResolveMode.t)  ->
                      (ResolveMode.to_yojson x : Yojson.Safe.json)))
                    v)) x.opacity));
         ("shape",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : ResolveMode.t)  ->
                      (ResolveMode.to_yojson x : Yojson.Safe.json)))
                    v)) x.shape));
         ("size",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : ResolveMode.t)  ->
                      (ResolveMode.to_yojson x : Yojson.Safe.json)))
v)) x.size))])                      
  let make ?color  ?opacity  ?shape  ?size  () =
    { size; shape; opacity; color } 
  let withColor v x = { x with color = (Some v) } 
  let withOpacity v x = { x with opacity = (Some v) } 
  let withShape v x = { x with shape = (Some v) } 
  let withSize v x = { x with size = (Some v) } 
end and
LegendOrient:sig
  type t =
    [ `Left  | `Right  | `Top_left 
    | `Top_right  | `Bottom_left 
    | `Bottom_right  | `None ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Left  | `Right  | `Top_left  | `Top_right 
    | `Bottom_left  | `Bottom_right  | `None ]

  let to_yojson =
    function
    | `None -> `String "none"
    | `Bottom_right -> `String "bottom_right"
    | `Bottom_left -> `String "bottom_left"
    | `Top_right -> `String "top_right"
    | `Top_left -> `String "top_left"
    | `Right -> `String "right"
    | `Left -> `String "left" 
end and
LegendFieldDef:sig
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit: TimeUnit.t option ;
    sort:
      [ `Order of SortOrder.t 
      | `Field of SortField.t ]
        option
      ;
    scale: Scale.t option ;
    legend: Legend.t option ;
    field: Field.t option ;
    bin:
      [ `Bool of bool 
      | `Params of BinParams.t ]
        option
      ;
    aggregate: Aggregate.t option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?aggregate:Aggregate.t ->
      ?bin:[ `Bool of bool 
           | `Params of BinParams.t ]
        ->
        ?field:Field.t ->
          ?legend:Legend.t ->
            ?scale:Scale.t ->
              ?sort:[
                      `Order of
SortOrder.t 
                    | `Field of
SortField.t ]
                ->
                ?timeUnit:TimeUnit.t
                  ->
                  typ:Type.t ->
                    unit -> t
  val withAggregate :
Aggregate.t -> t -> t
  val withBin :
    [ `Bool of bool 
    | `Params of BinParams.t ] ->
      t -> t
  val withField : Field.t -> t -> t
  val withLegend :
Legend.t -> t -> t
  val withScale : Scale.t -> t -> t
  val withSort :
    [ `Order of SortOrder.t 
    | `Field of SortField.t ] ->
      t -> t
  val withTimeUnit :
TimeUnit.t -> t -> t
  val withTyp : Type.t -> t -> t
end =
struct
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit: TimeUnit.t option ;
    sort:
      [ `Order of SortOrder.t 
      | `Field of SortField.t ] option ;
    scale: Scale.t option ;
    legend: Legend.t option ;
    field: Field.t option ;
    bin:
      [ `Bool of bool  | `Params of BinParams.t ]
        option
      ;
    aggregate: Aggregate.t option }

  (** Fields
  
    type:
      The encoded field's type of measurement. This can be either a full type
      name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and `"nominal"`).
  
    timeUnit:
      Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).
      
      __Default value:__ `undefined` (None)
  
    sort:
      Sort order for the encoded field.
      Supported `sort` values include `"ascending"`, `"descending"` and `null` (no sorting).
      For fields with discrete domains, `sort` can also be a [sort field definition object](sort.html#sort-field).
      
      __Default value:__ `"ascending"`
  
    scale:
      An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
      
      __Default value:__ If undefined, default [scale properties](scale.html) are applied.
  
    legend:
      An object defining properties of the legend.
      If `null`, the legend for the encoding channel will be removed.
      
      __Default value:__ If undefined, default [legend properties](legend.html) are applied.
  
    field:
      __Required.__ A string defining the name of the field from which to pull a data value
      or an object defining iterated values from the [`repeat`](repeat.html) operator.
      
      __Note:__ `field` is not required if `aggregate` is `count`.
  
    bin:
      A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).
      If `true`, default [binning parameters](bin.html) will be applied.
      
      __Default value:__ `false`
  
    aggregate:
      Aggregation function for the field
      (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
      
      __Default value:__ `undefined` (None)
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("aggregate",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : Aggregate.t)  ->
                       (Aggregate.to_yojson x : 
Yojson.Safe.json))) v))
               x.aggregate));
         ("bin",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : BinParams.t) 
                            ->
                            (BinParams.to_yojson x : 
Yojson.Safe.json))) v
                    | `Bool v ->
                        ((fun (b : bool)  ->
                            (`Bool b : Yojson.Safe.json)))
                          v)) v)) x.bin));
         ("field",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Field.t)  ->
                      (Field.to_yojson x : 
Yojson.Safe.json))) v))
              x.field));
         ("legend",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Legend.t)  ->
                      (Legend.to_yojson x : 
Yojson.Safe.json))) v))
              x.legend));
         ("scale",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Scale.t)  ->
                      (Scale.to_yojson x : 
Yojson.Safe.json))) v))
              x.scale));
         ("sort",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Field v ->
                        ((fun (x : SortField.t) 
                            ->
                            (SortField.to_yojson x : 
Yojson.Safe.json))) v
                    | `Order v ->
                        ((fun (x : SortOrder.t) 
                            ->
                            (SortOrder.to_yojson x : 
Yojson.Safe.json))) v))
                    v)) x.sort));
         ("timeUnit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : TimeUnit.t)  ->
                      (TimeUnit.to_yojson x : 
Yojson.Safe.json))) v))
              x.timeUnit));
         ("type",
           (((fun (x : Type.t)  ->
                (Type.to_yojson x : Yojson.Safe.json)))
x.typ))])                                
  let make ?aggregate  ?bin  ?field  ?legend 
    ?scale  ?sort  ?timeUnit  ~typ  () =
    {
      typ;
      timeUnit;
      sort;
      scale;
      legend;
      field;
      bin;
      aggregate
    } 
  let withAggregate v x =
    { x with aggregate = (Some v) } 
  let withBin v x = { x with bin = (Some v) } 
  let withField v x = { x with field = (Some v) } 
  let withLegend v x =
    { x with legend = (Some v) } 
  let withScale v x = { x with scale = (Some v) } 
  let withSort v x = { x with sort = (Some v) } 
  let withTimeUnit v x =
    { x with timeUnit = (Some v) } 
  let withTyp v x = { x with typ = v } 
end and
LegendConfig:sig
  type nonrec t =
    {
    titlePadding:
      [ `Int of int 
      | `Float of float ] option ;
    titleLimit:
      [ `Int of int 
      | `Float of float ] option ;
    titleFontWeight:
      [ `Float of float 
      | `Int of int 
      | `String of string ]
        option
      ;
    titleFontSize:
      [ `Int of int 
      | `Float of float ] option ;
    titleFont: string option ;
    titleColor: string option ;
    titleBaseline: string option ;
    titleAlign: string option ;
    symbolType: string option ;
    symbolStrokeWidth:
      [ `Int of int 
      | `Float of float ] option ;
    symbolSize:
      [ `Int of int 
      | `Float of float ] option ;
    symbolColor: string option ;
    strokeWidth:
      [ `Int of int 
      | `Float of float ] option ;
    strokeDash:
      [ `Int of int 
      | `Float of float ] list
        option
      ;
    strokeColor: string option ;
    shortTimeLabels: bool option ;
    padding:
      [ `Int of int 
      | `Float of float ] option ;
    orient:
LegendOrient.t option ;
    offset:
      [ `Int of int 
      | `Float of float ] option ;
    labelOffset:
      [ `Int of int 
      | `Float of float ] option ;
    labelLimit:
      [ `Int of int 
      | `Float of float ] option ;
    labelFontSize:
      [ `Int of int 
      | `Float of float ] option ;
    labelFont: string option ;
    labelColor: string option ;
    labelBaseline: string option ;
    labelAlign: string option ;
    gradientWidth:
      [ `Int of int 
      | `Float of float ] option ;
    gradientStrokeWidth:
      [ `Int of int 
      | `Float of float ] option ;
    gradientStrokeColor:
      string option ;
    gradientLabelOffset:
      [ `Int of int 
      | `Float of float ] option ;
    gradientLabelLimit:
      [ `Int of int 
      | `Float of float ] option ;
    gradientLabelBaseline:
      string option ;
    gradientHeight:
      [ `Int of int 
      | `Float of float ] option ;
    fillColor: string option ;
    entryPadding:
      [ `Int of int 
      | `Float of float ] option ;
    cornerRadius:
      [ `Int of int 
      | `Float of float ] option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?cornerRadius:[ `Int of int 
                  | `Float of
                      float ]
      ->
      ?entryPadding:[
                      `Int of
                       int 
                    | `Float of
                       float ]
        ->
        ?fillColor:string ->
          ?gradientHeight:
            [ `Int of int 
            | `Float of float ]
            ->
            ?gradientLabelBaseline:string
              ->
              ?gradientLabelLimit:
                [ `Int of int 
                | `Float of
                    float ]
                ->
                ?gradientLabelOffset:
                  [ `Int of int 
                  | `Float of
                      float ]
                  ->
                  ?gradientStrokeColor:string
                    ->
                    ?gradientStrokeWidth:
                      [
                       `Int of
                       int 
                      | `Float
                       of float ]
                      ->
                      ?gradientWidth:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?labelAlign:string
                       ->
                       ?labelBaseline:string
                       ->
                       ?labelColor:string
                       ->
                       ?labelFont:string
                       ->
                       ?labelFontSize:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?labelLimit:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?labelOffset:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?offset:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?orient:LegendOrient.t
                       ->
                       ?padding:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?shortTimeLabels:bool
                       ->
                       ?strokeColor:string
                       ->
                       ?strokeDash:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       list ->
                       ?strokeWidth:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?symbolColor:string
                       ->
                       ?symbolSize:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?symbolStrokeWidth:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?symbolType:string
                       ->
                       ?titleAlign:string
                       ->
                       ?titleBaseline:string
                       ->
                       ?titleColor:string
                       ->
                       ?titleFont:string
                       ->
                       ?titleFontSize:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?titleFontWeight:
                       [
                       `Float of
                       float 
                       | `Int of
                       int 
                       | `String
                       of string ]
                       ->
                       ?titleLimit:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       ?titlePadding:
                       [
                       `Int of
                       int 
                       | `Float
                       of float ]
                       ->
                       unit -> t
  val withCornerRadius :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withEntryPadding :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withFillColor :
    string -> t -> t
  val withGradientHeight :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withGradientLabelBaseline
    : string -> t -> t
  val withGradientLabelLimit :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withGradientLabelOffset :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withGradientStrokeColor :
    string -> t -> t
  val withGradientStrokeWidth :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withGradientWidth :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withLabelAlign :
    string -> t -> t
  val withLabelBaseline :
    string -> t -> t
  val withLabelColor :
    string -> t -> t
  val withLabelFont :
    string -> t -> t
  val withLabelFontSize :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withLabelLimit :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withLabelOffset :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withOffset :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withOrient :
LegendOrient.t -> t -> t
  val withPadding :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withShortTimeLabels :
    bool -> t -> t
  val withStrokeColor :
    string -> t -> t
  val withStrokeDash :
    [ `Int of int 
    | `Float of float ] list ->
      t -> t
  val withStrokeWidth :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withSymbolColor :
    string -> t -> t
  val withSymbolSize :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withSymbolStrokeWidth :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withSymbolType :
    string -> t -> t
  val withTitleAlign :
    string -> t -> t
  val withTitleBaseline :
    string -> t -> t
  val withTitleColor :
    string -> t -> t
  val withTitleFont :
    string -> t -> t
  val withTitleFontSize :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withTitleFontWeight :
    [ `Float of float 
    | `Int of int 
    | `String of string ] ->
      t -> t
  val withTitleLimit :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withTitlePadding :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
end =
struct
  type nonrec t =
    {
    titlePadding:
      [ `Int of int  | `Float of float ]
        option
      ;
    titleLimit:
      [ `Int of int  | `Float of float ]
        option
      ;
    titleFontWeight:
      [ `Float of float  | `Int of int 
      | `String of string ] option ;
    titleFontSize:
      [ `Int of int  | `Float of float ]
        option
      ;
    titleFont: string option ;
    titleColor: string option ;
    titleBaseline: string option ;
    titleAlign: string option ;
    symbolType: string option ;
    symbolStrokeWidth:
      [ `Int of int  | `Float of float ]
        option
      ;
    symbolSize:
      [ `Int of int  | `Float of float ]
        option
      ;
    symbolColor: string option ;
    strokeWidth:
      [ `Int of int  | `Float of float ]
        option
      ;
    strokeDash:
      [ `Int of int  | `Float of float ] list
        option
      ;
    strokeColor: string option ;
    shortTimeLabels: bool option ;
    padding:
      [ `Int of int  | `Float of float ]
        option
      ;
    orient: LegendOrient.t option ;
    offset:
      [ `Int of int  | `Float of float ]
        option
      ;
    labelOffset:
      [ `Int of int  | `Float of float ]
        option
      ;
    labelLimit:
      [ `Int of int  | `Float of float ]
        option
      ;
    labelFontSize:
      [ `Int of int  | `Float of float ]
        option
      ;
    labelFont: string option ;
    labelColor: string option ;
    labelBaseline: string option ;
    labelAlign: string option ;
    gradientWidth:
      [ `Int of int  | `Float of float ]
        option
      ;
    gradientStrokeWidth:
      [ `Int of int  | `Float of float ]
        option
      ;
    gradientStrokeColor: string option ;
    gradientLabelOffset:
      [ `Int of int  | `Float of float ]
        option
      ;
    gradientLabelLimit:
      [ `Int of int  | `Float of float ]
        option
      ;
    gradientLabelBaseline: string option ;
    gradientHeight:
      [ `Int of int  | `Float of float ]
        option
      ;
    fillColor: string option ;
    entryPadding:
      [ `Int of int  | `Float of float ]
        option
      ;
    cornerRadius:
      [ `Int of int  | `Float of float ]
        option
      }

  (** Fields
  
    titlePadding:
      The padding, in pixels, between title and legend.
  
    titleLimit:
      Maximum allowed pixel width of axis titles.
  
    titleFontWeight:
      The font weight of the legend title.
  
    titleFontSize:
      The font size of the legend title.
  
    titleFont:
      The font of the legend title.
  
    titleColor:
      The color of the legend title, can be in hex color code or regular color name.
  
    titleBaseline:
      Optional mark property definitions for custom legend styling. 
       Vertical text baseline for legend titles.
  
    titleAlign:
      Horizontal text alignment for legend titles.
  
    symbolType:
      Default shape type (such as "circle") for legend symbols.
  
    symbolStrokeWidth:
      The width of the symbol's stroke.
  
    symbolSize:
      The size of the legend symbol, in pixels.
  
    symbolColor:
      The color of the legend symbol,
  
    strokeWidth:
      Border stroke width for the full legend.
  
    strokeDash:
      Border stroke dash pattern for the full legend.
  
    strokeColor:
      Border stroke color for the full legend.
  
    shortTimeLabels:
      Whether month names and weekday names should be abbreviated.
      
      __Default value:__  `false`
  
    padding:
      The padding, in pixels, between the legend and axis.
  
    orient:
      The orientation of the legend, which determines how the legend is positioned within the scene. One of "left", "right", "top-left", "top-right", "bottom-left", "bottom-right", "none".
      
      __Default value:__ `"right"`
  
    offset:
      The offset, in pixels, by which to displace the legend from the edge of the enclosing group or data rectangle.
      
      __Default value:__  `0`
  
    labelOffset:
      The offset of the legend label.
  
    labelLimit:
      Maximum allowed pixel width of axis tick labels.
  
    labelFontSize:
      The font size of legend label.
      
      __Default value:__ `10`.
  
    labelFont:
      The font of the legend label.
  
    labelColor:
      The color of the legend label, can be in hex color code or regular color name.
  
    labelBaseline:
      The position of the baseline of legend label, can be top, middle or bottom.
  
    labelAlign:
      The alignment of the legend label, can be left, middle or right.
  
    gradientWidth:
      The width of the gradient, in pixels.
  
    gradientStrokeWidth:
      The width of the gradient stroke, in pixels.
  
    gradientStrokeColor:
      The color of the gradient stroke, can be in hex color code or regular color name.
  
    gradientLabelOffset:
      Vertical offset in pixels for color ramp gradient labels.
  
    gradientLabelLimit:
      The maximum allowed length in pixels of color ramp gradient labels.
  
    gradientLabelBaseline:
      Text baseline for color ramp gradient labels.
  
    gradientHeight:
      The height of the gradient, in pixels.
  
    fillColor:
      Background fill color for the full legend.
  
    entryPadding:
      Padding (in pixels) between legend entries in a symbol legend.
  
    cornerRadius:
      Corner radius for the full legend.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("cornerRadius",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function
                     | `Int i -> `Int i
                     | `Float f -> `Float f))
                     v)) x.cornerRadius));
         ("entryPadding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.entryPadding));
         ("fillColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.fillColor));
         ("gradientHeight",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.gradientHeight));
         ("gradientLabelBaseline",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v))
              x.gradientLabelBaseline));
         ("gradientLabelLimit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.gradientLabelLimit));
         ("gradientLabelOffset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.gradientLabelOffset));
         ("gradientStrokeColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.gradientStrokeColor));
         ("gradientStrokeWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.gradientStrokeWidth));
         ("gradientWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.gradientWidth));
         ("labelAlign",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.labelAlign));
         ("labelBaseline",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.labelBaseline));
         ("labelColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.labelColor));
         ("labelFont",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.labelFont));
         ("labelFontSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.labelFontSize));
         ("labelLimit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.labelLimit));
         ("labelOffset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.labelOffset));
         ("offset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.offset));
         ("orient",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : LegendOrient.t) 
                      ->
                      (LegendOrient.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.orient));
         ("padding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.padding));
         ("shortTimeLabels",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  ->
                      (`Bool b : Yojson.Safe.json)))
                    v)) x.shortTimeLabels));
         ("strokeColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.strokeColor));
         ("strokeDash",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (l :
                        [ `Int of int 
                        | `Float of float ]
                          list)
                       ->
                      let yojson_of_el =
                        function
                        | `Int i -> `Int i
                        | `Float f ->
                            `Float f
                         in
                      (`List
                         (List.map
                            yojson_of_el l) : 
Yojson.Safe.json))) v))
              x.strokeDash));
         ("strokeWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.strokeWidth));
         ("symbolColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.symbolColor));
         ("symbolSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.symbolSize));
         ("symbolStrokeWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.symbolStrokeWidth));
         ("symbolType",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.symbolType));
         ("titleAlign",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.titleAlign));
         ("titleBaseline",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.titleBaseline));
         ("titleColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.titleColor));
         ("titleFont",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.titleFont));
         ("titleFontSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.titleFontSize));
         ("titleFontWeight",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `String v ->
                        ((fun (s : string) 
                            ->
                            (`String s : 
Yojson.Safe.json)))
                          v
                    | `Int v ->
                        ((fun (i : int)  ->
                            (`Int i : 
Yojson.Safe.json)))
                          v
                    | `Float v ->
                        ((fun (f : float)  ->
                            (`Float f : 
Yojson.Safe.json)))
                          v)) v))
              x.titleFontWeight));
         ("titleLimit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
                    v)) x.titleLimit));
         ("titlePadding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f))
v)) x.titlePadding))])                                     
  let make ?cornerRadius  ?entryPadding 
    ?fillColor  ?gradientHeight 
    ?gradientLabelBaseline 
    ?gradientLabelLimit  ?gradientLabelOffset
     ?gradientStrokeColor 
    ?gradientStrokeWidth  ?gradientWidth 
    ?labelAlign  ?labelBaseline  ?labelColor 
    ?labelFont  ?labelFontSize  ?labelLimit 
    ?labelOffset  ?offset  ?orient  ?padding 
    ?shortTimeLabels  ?strokeColor 
    ?strokeDash  ?strokeWidth  ?symbolColor 
    ?symbolSize  ?symbolStrokeWidth 
    ?symbolType  ?titleAlign  ?titleBaseline 
    ?titleColor  ?titleFont  ?titleFontSize 
    ?titleFontWeight  ?titleLimit 
    ?titlePadding  () =
    {
      titlePadding;
      titleLimit;
      titleFontWeight;
      titleFontSize;
      titleFont;
      titleColor;
      titleBaseline;
      titleAlign;
      symbolType;
      symbolStrokeWidth;
      symbolSize;
      symbolColor;
      strokeWidth;
      strokeDash;
      strokeColor;
      shortTimeLabels;
      padding;
      orient;
      offset;
      labelOffset;
      labelLimit;
      labelFontSize;
      labelFont;
      labelColor;
      labelBaseline;
      labelAlign;
      gradientWidth;
      gradientStrokeWidth;
      gradientStrokeColor;
      gradientLabelOffset;
      gradientLabelLimit;
      gradientLabelBaseline;
      gradientHeight;
      fillColor;
      entryPadding;
      cornerRadius
    } 
  let withCornerRadius v x =
    { x with cornerRadius = (Some v) } 
  let withEntryPadding v x =
    { x with entryPadding = (Some v) } 
  let withFillColor v x =
    { x with fillColor = (Some v) } 
  let withGradientHeight v x =
    { x with gradientHeight = (Some v) } 
  let withGradientLabelBaseline v x =
    { x with gradientLabelBaseline = (Some v)
    } 
  let withGradientLabelLimit v x =
    { x with gradientLabelLimit = (Some v) } 
  let withGradientLabelOffset v x =
    { x with gradientLabelOffset = (Some v) } 
  let withGradientStrokeColor v x =
    { x with gradientStrokeColor = (Some v) } 
  let withGradientStrokeWidth v x =
    { x with gradientStrokeWidth = (Some v) } 
  let withGradientWidth v x =
    { x with gradientWidth = (Some v) } 
  let withLabelAlign v x =
    { x with labelAlign = (Some v) } 
  let withLabelBaseline v x =
    { x with labelBaseline = (Some v) } 
  let withLabelColor v x =
    { x with labelColor = (Some v) } 
  let withLabelFont v x =
    { x with labelFont = (Some v) } 
  let withLabelFontSize v x =
    { x with labelFontSize = (Some v) } 
  let withLabelLimit v x =
    { x with labelLimit = (Some v) } 
  let withLabelOffset v x =
    { x with labelOffset = (Some v) } 
  let withOffset v x =
    { x with offset = (Some v) } 
  let withOrient v x =
    { x with orient = (Some v) } 
  let withPadding v x =
    { x with padding = (Some v) } 
  let withShortTimeLabels v x =
    { x with shortTimeLabels = (Some v) } 
  let withStrokeColor v x =
    { x with strokeColor = (Some v) } 
  let withStrokeDash v x =
    { x with strokeDash = (Some v) } 
  let withStrokeWidth v x =
    { x with strokeWidth = (Some v) } 
  let withSymbolColor v x =
    { x with symbolColor = (Some v) } 
  let withSymbolSize v x =
    { x with symbolSize = (Some v) } 
  let withSymbolStrokeWidth v x =
    { x with symbolStrokeWidth = (Some v) } 
  let withSymbolType v x =
    { x with symbolType = (Some v) } 
  let withTitleAlign v x =
    { x with titleAlign = (Some v) } 
  let withTitleBaseline v x =
    { x with titleBaseline = (Some v) } 
  let withTitleColor v x =
    { x with titleColor = (Some v) } 
  let withTitleFont v x =
    { x with titleFont = (Some v) } 
  let withTitleFontSize v x =
    { x with titleFontSize = (Some v) } 
  let withTitleFontWeight v x =
    { x with titleFontWeight = (Some v) } 
  let withTitleLimit v x =
    { x with titleLimit = (Some v) } 
  let withTitlePadding v x =
    { x with titlePadding = (Some v) } 
end and
Legend:sig
  type nonrec t =
    {
    zindex:
      [ `Int of int 
      | `Float of float ] option ;
    values:
      [
        `Nums of
          [ `Int of int 
          | `Float of float ]
            list
           | `Strings of
               string list 
      | `DateTimes of
DateTime.t list ]
        option
      ;
    typ:
      [ `Symbol  | `Gradient ]
        option
      ;
    titleAlign: string option ;
    title: string option ;
    tickCount:
      [ `Int of int 
      | `Float of float ] option ;
    padding:
      [ `Int of int 
      | `Float of float ] option ;
    orient: LegendOrient.t option ;
    offset:
      [ `Int of int 
      | `Float of float ] option ;
    format: string option ;
    fillColor: string option ;
    entryPadding:
      [ `Int of int 
      | `Float of float ] option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?entryPadding:[ `Int of int 
                  | `Float of
                      float ]
      ->
      ?fillColor:string ->
        ?format:string ->
          ?offset:[ `Int of int 
                  | `Float of
                      float ]
            ->
            ?orient:LegendOrient.t
              ->
              ?padding:[
                        `Int of
                        int 
                       | `Float
                        of float ]
                ->
                ?tickCount:
                  [ `Int of int 
                  | `Float of
                      float ]
                  ->
                  ?title:string
                    ->
                    ?titleAlign:string
                      ->
                      ?typ:
                        [
                        `Symbol 
                        | `Gradient
                        ] ->
                        ?values:
                        [
                        `Nums of
                        [
                        `Int of
                        int 
                        | `Float
                        of float ]
                        list 
                        | `Strings
                        of
                        string
                        list 
                        | `DateTimes
                        of
DateTime.t
                        list ] ->
                        ?zindex:
                        [
                        `Int of
                        int 
                        | `Float
                        of float ]
                        ->
                        unit -> t
  val withEntryPadding :
    [ `Int of int 
    | `Float of float ] -> 
      t -> t
  val withFillColor :
    string -> t -> t
  val withFormat :
    string -> t -> t
  val withOffset :
    [ `Int of int 
    | `Float of float ] -> 
      t -> t
  val withOrient :
LegendOrient.t -> t -> t
  val withPadding :
    [ `Int of int 
    | `Float of float ] -> 
      t -> t
  val withTickCount :
    [ `Int of int 
    | `Float of float ] -> 
      t -> t
  val withTitle :
    string -> t -> t
  val withTitleAlign :
    string -> t -> t
  val withTyp :
    [ `Symbol  | `Gradient ] ->
      t -> t
  val withValues :
    [
      `Nums of
        [ `Int of int 
        | `Float of float ] list 
    | `Strings of string list 
    | `DateTimes of
DateTime.t list ]
      -> t -> t
  val withZindex :
    [ `Int of int 
    | `Float of float ] -> 
      t -> t
end =
struct
  type nonrec t =
    {
    zindex:
      [ `Int of int  | `Float of float ]
        option
      ;
    values:
      [
        `Nums of
          [ `Int of int 
          | `Float of float ] list 
      | `Strings of string list 
      | `DateTimes of DateTime.t list ]
        option
      ;
    typ: [ `Symbol  | `Gradient ] option ;
    titleAlign: string option ;
    title: string option ;
    tickCount:
      [ `Int of int  | `Float of float ]
        option
      ;
    padding:
      [ `Int of int  | `Float of float ]
        option
      ;
    orient: LegendOrient.t option ;
    offset:
      [ `Int of int  | `Float of float ]
        option
      ;
    format: string option ;
    fillColor: string option ;
    entryPadding:
      [ `Int of int  | `Float of float ]
        option
      }

  (** Properties of a legend or boolean flag for determining whether to show it.
  
  
  Fields:
  
    zindex:
      A non-positive integer indicating z-index of the legend.
      If zindex is 0, legend should be drawn behind all chart elements.
      To put them in front, use zindex = 1.
  
    values:
      Explicitly set the visible legend values.
  
    type:
      The type of the legend. Use `"symbol"` to create a discrete legend and `"gradient"` for a continuous color gradient.
      
      __Default value:__ `"gradient"` for non-binned quantitative fields and temporal fields; `"symbol"` otherwise.
  
    titleAlign:
      Horizontal text alignment for legend titles.
  
    title:
      A title for the field.
      
      __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`).  If the field has a function, the function is displayed as an all capped text with parentheses wrapping the field name (e.g., `"SUM(field_name)"`, `"BIN(field_name)"`, `"YEAR(field_name)"`).  Otherwise, the title is simply the field name.
  
    tickCount:
      The desired number of tick values for quantitative legends.
  
    padding:
      The padding, in pixels, between the legend and axis.
  
    orient:
      The orientation of the legend, which determines how the legend is positioned within the scene. One of "left", "right", "top-left", "top-right", "bottom-left", "bottom-right", "none".
      
      __Default value:__ `"right"`
  
    offset:
      The offset, in pixels, by which to displace the legend from the edge of the enclosing group or data rectangle.
      
      __Default value:__  `0`
  
    format:
      The formatting pattern for labels. This is D3's [number format pattern](https://github.com/d3/d3-format#locale_format) for quantitative fields and D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format) for time field.
      
      See the [format documentation](format.html) for more information.
      
      __Default value:__  derived from [numberFormat](config.html#format) config for quantitative fields and from [timeFormat](config.html#format) config for temporal fields.
  
    fillColor:
      Background fill color for the full legend.
  
    entryPadding:
      Padding (in pixels) between legend entries in a symbol legend.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("entryPadding",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function
                     | `Int i -> `Int i
                     | `Float f ->
                         `Float f)) v))
               x.entryPadding));
         ("fillColor",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.fillColor));
         ("format",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.format));
         ("offset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.offset));
         ("orient",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
LegendOrient.t)
                       ->
                      (LegendOrient.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.orient));
         ("padding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.padding));
         ("tickCount",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
              x.tickCount));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.title));
         ("titleAlign",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : 
Yojson.Safe.json)))
                    v)) x.titleAlign));
         ("type",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Gradient ->
                        `String
                          "gradient"
                    | `Symbol ->
                        `String "symbol"))
                    v)) x.typ));
         ("values",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `DateTimes v ->
                        ((fun
                            (l :
DateTime.t
                               list)
                             ->
                            let yojson_of_el
                              (x :
DateTime.t)
                              =
                              (DateTime.to_yojson
                               x : 
Yojson.Safe.json)
                               in
                            (`List
                               (
List.map
                               yojson_of_el
                               l) : 
Yojson.Safe.json)))
                          v
                    | `Strings v ->
                        ((fun
                            (l :
                              string
                               list)
                             ->
                            let yojson_of_el
                              (s :
                               string)
                              =
                              (`String s : 
Yojson.Safe.json)
                               in
                            (`List
                               (
List.map
                               yojson_of_el
                               l) : 
Yojson.Safe.json)))
                          v
                    | `Nums v ->
                        ((fun
                            (l :
                              [
                               `Int of
                               int 
                              | `Float
                               of float ]
                               list)
                             ->
                            let yojson_of_el
                              =
                              function
                              | 
                              `Int i ->
                               `Int i
                              | 
                              `Float f
                               ->
                               `Float f
                               in
                            (`List
                               (
List.map
                               yojson_of_el
                               l) : 
Yojson.Safe.json)))
                          v)) v))
              x.values));
         ("zindex",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f ->
                        `Float f)) v))
x.zindex))])                                          
  let make ?entryPadding  ?fillColor 
    ?format  ?offset  ?orient  ?padding 
    ?tickCount  ?title  ?titleAlign 
    ?typ  ?values  ?zindex  () =
    {
      zindex;
      values;
      typ;
      titleAlign;
      title;
      tickCount;
      padding;
      orient;
      offset;
      format;
      fillColor;
      entryPadding
    } 
  let withEntryPadding v x =
    { x with entryPadding = (Some v) } 
  let withFillColor v x =
    { x with fillColor = (Some v) } 
  let withFormat v x =
    { x with format = (Some v) } 
  let withOffset v x =
    { x with offset = (Some v) } 
  let withOrient v x =
    { x with orient = (Some v) } 
  let withPadding v x =
    { x with padding = (Some v) } 
  let withTickCount v x =
    { x with tickCount = (Some v) } 
  let withTitle v x =
    { x with title = (Some v) } 
  let withTitleAlign v x =
    { x with titleAlign = (Some v) } 
  let withTyp v x =
    { x with typ = (Some v) } 
  let withValues v x =
    { x with values = (Some v) } 
  let withZindex v x =
    { x with zindex = (Some v) } 
end and
LayoutSizeMixins:sig
  type nonrec t =
    {
    width:
      [
        `Int of
         int 
      | `Float of
         float ]
        option
      ;
    height:
      [
        `Int of
         int 
      | `Float of
         float ]
        option
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?height:
      [
        `Int of
         int 
      | `Float of
         float ]
      ->
      ?width:
        [
         `Int of
         int 
        | `Float
         of float ]
        ->
        unit -> t
  val withHeight :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withWidth :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
end =
struct
  type nonrec t =
    {
    width:
      [ `Int of int 
      | `Float of float ] option ;
    height:
      [ `Int of int 
      | `Float of float ] option }

  (** Fields
  
    width:
      The width of a visualization.
      
      __Default value:__ This will be determined by the following rules:
      
      - For x-axis with a continuous (non-ordinal) scale, the width will be the value of [`config.view.width`](spec.html#config).
      - For x-axis with an ordinal scale: if [`rangeStep`](scale.html#ordinal) is a numeric value (default), the width is determined by the value of `rangeStep` and the cardinality of the field mapped to x-channel.   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](spec.html#config).
      - If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.
      
      __Note:__ For plot with `row` and `column` channels, this represents the width of a single view.
      
      __See also:__ The documentation for [width and height](size.html) contains more examples.
  
    height:
      The height of a visualization.
      
      __Default value:__
      - For y-axis with a continuous (non-ordinal) scale, the height will be the value of [`config.view.height`](spec.html#config).
      - For y-axis with an ordinal scale: if [`rangeStep`](scale.html#ordinal) is a numeric value (default), the height is determined by the value of `rangeStep` and the cardinality of the field mapped to y-channel.   Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](spec.html#config).
      - If no field is mapped to `x` channel, the `height` will be the value of `rangeStep`.
      
      __Note__: For plot with `row` and `column` channels, this represents the height of a single view.
      
      __See also:__ The documentation for [width and height](size.html) contains more examples.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("height",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function
                     | `Int i ->
                         `Int i
                     | `Float f ->
                         `Float f))
                     v)) x.height));
         ("width",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i ->
                        `Int i
                    | `Float f ->
                        `Float f))
v)) x.width))])                                               
  let make ?height  ?width  () =
    { width; height } 
  let withHeight v x =
    { x with height = (Some v) } 
  let withWidth v x =
    { x with width = (Some v) } 
end and
LayerSpec:sig
  type nonrec t =
    {
    width:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    transform:
Transform.t
        list option
      ;
    title:
      [
        `String of
          string 
      | `Params of
TitleParams.t
          ]
        option
      ;
    resolve:
Resolve.t
        option
      ;
    name:
      string option ;
    layer:
      [
        `Unit of
CompositeUnitSpec.t
           | 
        `Layer of
LayerSpec.t
          ]
        list
      ;
    height:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    description:
      string option ;
    data:
Data.t option }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?data:Data.t ->
      ?description:string
        ->
        ?height:
          [
           `Int of
           int 
          | `Float
           of float ]
          ->
          ?name:string
           ->
           ?resolve:Resolve.t
           ->
           ?title:
           [
           `String
           of 
           string 
           | `Params
           of
TitleParams.t
           ] ->
           ?transform:Transform.t
           list ->
           ?width:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           layer:
           [
           `Unit of
CompositeUnitSpec.t
            | 
           `Layer of
LayerSpec.t
           ] list ->
           unit -> t
  val withData :
Data.t -> t -> t
  val
    withDescription
    :
    string -> t -> t
  val withHeight :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withLayer :
    [
      `Unit of
CompositeUnitSpec.t
         | `Layer of
LayerSpec.t
           ]
      list -> 
      t -> t
  val withName :
    string -> t -> t
  val withResolve :
Resolve.t ->
      t -> t
  val withTitle :
    [
      `String of
        string 
    | `Params of
TitleParams.t
        ]
      -> t -> t
  val withTransform
    :
Transform.t list
      -> t -> t
  val withWidth :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
end =
struct
  type nonrec t =
    {
    width:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    transform:
Transform.t list option ;
    title:
      [ `String of string 
      | `Params of
TitleParams.t ]
        option
      ;
    resolve: Resolve.t option ;
    name: string option ;
    layer:
      [
        `Unit of
CompositeUnitSpec.t 
      | `Layer of LayerSpec.t ]
        list
      ;
    height:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    description: string option ;
    data: Data.t option }

  (** Fields
  
    width:
      The width of a visualization.
      
      __Default value:__ This will be determined by the following rules:
      
      - For x-axis with a continuous (non-ordinal) scale, the width will be the value of [`config.view.width`](spec.html#config).
      - For x-axis with an ordinal scale: if [`rangeStep`](scale.html#ordinal) is a numeric value (default), the width is determined by the value of `rangeStep` and the cardinality of the field mapped to x-channel.   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](spec.html#config).
      - If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.
      
      __Note:__ For plot with `row` and `column` channels, this represents the width of a single view.
      
      __See also:__ The documentation for [width and height](size.html) contains more examples.
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    name:
      Name of the visualization for later reference.
  
    layer:
      Layer or single view specifications to be layered.
      
      __Note__: Specifications inside `layer` cannot use `row` and `column` channels as layering facet specifications is not allowed.
  
    height:
      The height of a visualization.
      
      __Default value:__
      - For y-axis with a continuous (non-ordinal) scale, the height will be the value of [`config.view.height`](spec.html#config).
      - For y-axis with an ordinal scale: if [`rangeStep`](scale.html#ordinal) is a numeric value (default), the height is determined by the value of `rangeStep` and the cardinality of the field mapped to y-channel.   Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](spec.html#config).
      - If no field is mapped to `x` channel, the `height` will be the value of `rangeStep`.
      
      __Note__: For plot with `row` and `column` channels, this represents the height of a single view.
      
      __See also:__ The documentation for [width and height](size.html) contains more examples.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("data",
            (((function
               | None  ->
                   `Null
               | Some v ->
                   ((fun
                     (x :
Data.t) 
                     ->
                     (Data.to_yojson
                     x : 
Yojson.Safe.json)))
                     v))
               x.data));
         ("description",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (s :
                     string) 
                     ->
                     (`String
                     s : 
Yojson.Safe.json)))
                    v))
              x.description));
         ("height",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.height));
         ("layer",
           (((fun
                (l :
                  [
                    `Unit of
CompositeUnitSpec.t
                      | 
                    `Layer of
LayerSpec.t
                     ]
                    list)
                 ->
                let yojson_of_el
                  =
                  function
                  | `Layer v
                     ->
                     ((fun
                     (x :
LayerSpec.t)
                      ->
                     (LayerSpec.to_yojson
                     x : Yojson.Safe.json)))
                     v
                  | `Unit v ->
                     ((fun
                     (x :
CompositeUnitSpec.t)
                      ->
                     (CompositeUnitSpec.to_yojson
                     x : Yojson.Safe.json)))
                     v
                   in
                (`List
                   (List.map
                     yojson_of_el
                     l) : 
Yojson.Safe.json)))
              x.layer));
         ("name",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (s :
                     string) 
                     ->
                     (`String
                     s : 
Yojson.Safe.json)))
                    v)) x.name));
         ("resolve",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (x :
Resolve.t)
                      ->
                     (Resolve.to_yojson
                     x : 
Yojson.Safe.json)))
                    v))
              x.resolve));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Params v
                     ->
                     ((fun
                     (x :
TitleParams.t)
                      ->
                     (TitleParams.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `String v
                     ->
                     ((fun
                     (s :
                     string) 
                     ->
                     (`String
                     s : Yojson.Safe.json)))
                     v)) v))
              x.title));
         ("transform",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (l :
Transform.t
                     list)  ->
                     let yojson_of_el
                     (x :
Transform.t)
                     =
                     (Transform.to_yojson
                     x : 
Yojson.Safe.json)
                      in
                     (`List
                     (List.map
                     yojson_of_el
                     l) : 
Yojson.Safe.json)))
                    v))
              x.transform));
         ("width",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
x.width))])                                                    
  let make ?data  ?description
     ?height  ?name  ?resolve 
    ?title  ?transform  ?width
     ~layer  () =
    {
      layer;
      width;
      transform;
      title;
      resolve;
      name;
      height;
      description;
      data
    } 
  let withData v x =
    { x with data = (Some v) } 
  let withDescription v x =
    {
      x with
      description = (Some v)
    } 
  let withHeight v x =
    { x with height = (Some v)
    } 
  let withLayer v x =
    { x with layer = v } 
  let withName v x =
    { x with name = (Some v) } 
  let withResolve v x =
    {
      x with
      resolve = (Some v)
    } 
  let withTitle v x =
    { x with title = (Some v)
    } 
  let withTransform v x =
    {
      x with
      transform = (Some v)
    } 
  let withWidth v x =
    { x with width = (Some v)
    } 
end and
JsonDataFormat:sig
 type nonrec t =
 {
 typ:
 [ `Json ]
 option ;
 property:
 string
 option ;
 parse:
 [ `Auto 
 | `Json
 of
Yojson.Safe.json
 ] option }
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
 val make
 :
 ?parse:
 [ `Auto 
 | `Json
 of
Yojson.Safe.json
 ] ->
 ?property:string
 ->
 ?typ:
 [ `Json ]
 ->
 unit -> t
 val
 withParse
 :
 [ `Auto 
 | `Json
 of
Yojson.Safe.json
 ] ->
 t -> t
 val
 withProperty
 :
 string ->
 t -> t
 val
 withTyp :
 [ `Json ]
 -> 
 t -> t
end =
struct
  type nonrec t =
    {
    typ: [ `Json ] option ;
    property:
      string option ;
    parse:
      [ `Auto 
      | `Json of
Yojson.Safe.json
          ]
        option
      }

  (** Fields
  
    type:
      Type of input data: `"json"`, `"csv"`, `"tsv"`.
      The default format type is determined by the extension of the file URL.
      If no extension is detected, `"json"` will be used by default.
  
    property:
      The JSON property containing the desired data.
      This parameter can be used when the loaded JSON file may have surrounding structure or meta-data.
      For example `"property": "values.features"` is equivalent to retrieving `json.values.features`
      from the loaded JSON object.
  
    parse:
      If set to auto (the default), perform automatic type inference to determine the desired data types.
      Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `"number"`, `"boolean"` or `"date"`).
      For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field in each input record a Date value.
      
      For `"date"`, we parse data based using Javascript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).
      For Specific date formats can be provided (e.g., `{foo: 'date:"%m%d%Y"'}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: 'utc:"%m%d%Y"'}`). See more about [UTC time](timeunit.html#utc)
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null ->
                false
            | _ -> true)
         [("parse",
            (((function
               | 
None  ->
                `Null
               | 
Some v ->
                ((function
                | `Json v
                ->
                ((fun
                (j :
Yojson.Safe.json)
                 ->
                (j : 
Yojson.Safe.json)))
                v
                | `Auto
                ->
                `String
                "auto"))
                v))
               x.parse));
         ("property",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (s :
                string) 
                ->
                (`String
                s : Yojson.Safe.json)))
                v))
              x.property));
         ("type",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((function
                | `Json
                ->
                `String
                "json"))
v)) x.typ))])                                                         
  let make ?parse 
    ?property  ?typ  () =
    {
      typ;
      property;
      parse
    } 
  let withParse v x =
    {
      x with
      parse = (Some v)
    } 
  let withProperty v x =
    {
      x with
      property = (Some v)
    } 
  let withTyp v x =
    {
      x with
      typ = (Some v)
    } 
end and
IntervalSelectionConfig:
                                                         sig
  type nonrec t =
    {
    zoom:
      [
        `Bool of
          bool 
      | `String of
          string ]
        option
      ;
    translate:
      [
        `Bool of
          bool 
      | `String of
          string ]
        option
      ;
    resolve:
SelectionResolution.t
        option
      ;
    on:
VgEventStream.t
        option
      ;
    mark:
BrushConfig.t
        option
      ;
    fields:
      string list
        option
      ;
    encodings:
SingleDefChannel.t
        list option
      ;
    bind:
      [ `Scales ]
        option
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?bind:[
           `Scales ]
      ->
      ?encodings:SingleDefChannel.t
        list ->
        ?fields:string
          list ->
          ?mark:BrushConfig.t
           ->
           ?on:VgEventStream.t
           ->
           ?resolve:SelectionResolution.t
           ->
           ?translate:
           [
           `Bool of
           bool 
           | `String
           of string ]
           ->
           ?zoom:
           [
           `Bool of
           bool 
           | `String
           of string ]
           ->
           unit -> t
  val withBind :
    [ `Scales ] ->
      t -> t
  val withEncodings
    :
SingleDefChannel.t
      list -> 
      t -> t
  val withFields :
    string list ->
      t -> t
  val withMark :
BrushConfig.t ->
      t -> t
  val withOn :
VgEventStream.t
      -> t -> t
  val withResolve :
SelectionResolution.t
      -> t -> t
  val withTranslate
    :
    [ `Bool of bool 
    | `String of
        string ]
      -> t -> t
  val withZoom :
    [ `Bool of bool 
    | `String of
        string ]
      -> t -> t
end =
struct
  type nonrec t =
    {
    zoom:
      [
        `Bool of
          bool 
      | `String of
          string ]
        option
      ;
    translate:
      [
        `Bool of
          bool 
      | `String of
          string ]
        option
      ;
    resolve:
SelectionResolution.t
        option
      ;
    on:
VgEventStream.t
        option
      ;
    mark:
BrushConfig.t
        option
      ;
    fields:
      string list
        option
      ;
    encodings:
SingleDefChannel.t
        list option
      ;
    bind:
      [ `Scales ]
        option
      }

  (** Fields
  
    zoom:
      When truthy, allows a user to interactively resize an interval selection.
      Can be `true`, `false` (to disable zooming), or a [Vega event stream
      definition](https://vega.github.io/vega/docs/event-streams/). Currently,
      only `wheel` events are supported.
      
      
      __Default value:__ `true`, which corresponds to `wheel!`.
  
    translate:
      When truthy, allows a user to interactively move an interval selection
      back-and-forth. Can be `true`, `false` (to disable panning), or a
      [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/)
      which must include a start and end event to trigger continuous panning.
      
      __Default value:__ `true`, which corresponds to
      `[mousedown, window:mouseup] > window:mousemove!` which corresponds to
      clicks and dragging within an interval selection to reposition it.
  
    resolve:
      With layered and multi-view displays, a strategy that determines how
      selections' data queries are resolved when applied in a filter transform,
      conditional encoding rule, or scale domain.
  
    on:
      A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.
      For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
  
    mark:
      An interval selection also adds a rectangle mark to depict the
      extents of the interval. The `mark` property can be used to customize the
      appearance of the mark.
  
    fields:
      An array of field names whose values must match for a data tuple to
      fall within the selection.
  
    encodings:
      An array of encoding channels. The corresponding data field values
      must match for a data tuple to fall within the selection.
  
    bind:
      Establishes a two-way binding between the interval selection and the scales
      used within the same view. This allows a user to interactively pan and
      zoom the view.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun 
           (k,v)  ->
           match v
           with
           | 
           `Null ->
           false
           | 
           _ -> true)
         [("bind",
           (((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Scales
           ->
           `String
           "scales"))
           v))
           x.bind));
         ("encodings",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (l :
SingleDefChannel.t
           list)  ->
           let yojson_of_el
           (x :
SingleDefChannel.t)
           =
           (SingleDefChannel.to_yojson
           x : 
Yojson.Safe.json)
            in
           (`List
           (List.map
           yojson_of_el
           l) : 
Yojson.Safe.json)))
           v))
           x.encodings));
         ("fields",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (l :
           string
           list)  ->
           let yojson_of_el
           (s :
           string) =
           (`String
           s : 
Yojson.Safe.json)
            in
           (`List
           (List.map
           yojson_of_el
           l) : 
Yojson.Safe.json)))
           v))
           x.fields));
         ("mark",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
BrushConfig.t)
            ->
           (BrushConfig.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.mark));
         ("on",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
VgEventStream.t)
            ->
           (VgEventStream.to_yojson
           x : Yojson.Safe.json)))
           v)) x.on));
         ("resolve",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (x :
SelectionResolution.t)
            ->
           (SelectionResolution.to_yojson
           x : Yojson.Safe.json)))
           v))
           x.resolve));
         ("translate",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `String
           v ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v
           | `Bool v
           ->
           ((fun
           (b :
           bool)  ->
           (`Bool b : 
Yojson.Safe.json)))
           v)) v))
           x.translate));
         ("zoom",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `String
           v ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v
           | `Bool v
           ->
           ((fun
           (b :
           bool)  ->
           (`Bool b : 
Yojson.Safe.json)))
           v)) v))
x.zoom))])                                                              
  let make ?bind 
    ?encodings 
    ?fields  ?mark 
    ?on  ?resolve 
    ?translate 
    ?zoom  () =
    {
      zoom;
      translate;
      resolve;
      on;
      mark;
      fields;
      encodings;
      bind
    } 
  let withBind v x =
    {
      x with
      bind =
        (Some v)
    } 
  let withEncodings
    v x =
    {
      x with
      encodings =
        (Some v)
    } 
  let withFields v x
    =
    {
      x with
      fields =
        (Some v)
    } 
  let withMark v x =
    {
      x with
      mark =
        (Some v)
    } 
  let withOn v x =
    {
      x with
      on = (Some v)
    } 
  let withResolve v
    x =
    {
      x with
      resolve =
        (Some v)
    } 
  let withTranslate
    v x =
    {
      x with
      translate =
        (Some v)
    } 
  let withZoom v x =
    {
      x with
      zoom =
        (Some v)
    } 
end and
IntervalSelection:
                                                              sig
  type nonrec t =
    {
    zoom:
      [
      `Bool of
      bool 
      | `String
      of string ]
      option ;
    typ:
      [
      `Interval ]
      ;
    translate:
      [
      `Bool of
      bool 
      | `String
      of string ]
      option ;
    resolve:
SelectionResolution.t
      option ;
    on:
VgEventStream.t
      option ;
    mark:
BrushConfig.t
      option ;
    fields:
      string
      list
      option ;
    encodings:
SingleDefChannel.t
      list
      option ;
    bind:
      [
      `Scales ]
      option }
  val to_yojson
    :
    t ->
Yojson.Safe.json
  val make :
    ?bind:
      [
      `Scales ]
      ->
      ?encodings:SingleDefChannel.t
      list ->
      ?fields:string
      list ->
      ?mark:BrushConfig.t
      ->
      ?on:VgEventStream.t
      ->
      ?resolve:SelectionResolution.t
      ->
      ?translate:
      [
      `Bool of
      bool 
      | `String
      of string ]
      ->
      ?zoom:
      [
      `Bool of
      bool 
      | `String
      of string ]
      ->
      typ:
      [
      `Interval ]
      ->
      unit -> t
  val withBind
    :
    [ `Scales ]
      -> 
      t -> t
  val
    withEncodings
    :
SingleDefChannel.t
      list ->
      t -> t
  val
    withFields
    :
    string list
      -> 
      t -> t
  val withMark
    :
BrushConfig.t
      -> 
      t -> t
  val withOn :
VgEventStream.t
      -> 
      t -> t
  val
    withResolve
    :
SelectionResolution.t
      -> 
      t -> t
  val
    withTranslate
    :
    [
      `Bool of
      bool 
    | `String
      of 
      string ]
      -> 
      t -> t
  val withTyp :
    [
      `Interval ]
      -> 
      t -> t
  val withZoom
    :
    [
      `Bool of
      bool 
    | `String
      of 
      string ]
      -> 
      t -> t
end =
struct
  type nonrec t =
    {
    zoom:
      [
      `Bool of
      bool 
      | `String
      of string ]
      option ;
    typ:
      [
      `Interval ]
      ;
    translate:
      [
      `Bool of
      bool 
      | `String
      of string ]
      option ;
    resolve:
SelectionResolution.t
      option ;
    on:
VgEventStream.t
      option ;
    mark:
BrushConfig.t
      option ;
    fields:
      string
      list
      option ;
    encodings:
SingleDefChannel.t
      list
      option ;
    bind:
      [
      `Scales ]
      option }

  (** Fields
  
    zoom:
      When truthy, allows a user to interactively resize an interval selection.
      Can be `true`, `false` (to disable zooming), or a [Vega event stream
      definition](https://vega.github.io/vega/docs/event-streams/). Currently,
      only `wheel` events are supported.
      
      
      __Default value:__ `true`, which corresponds to `wheel!`.
  
    translate:
      When truthy, allows a user to interactively move an interval selection
      back-and-forth. Can be `true`, `false` (to disable panning), or a
      [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/)
      which must include a start and end event to trigger continuous panning.
      
      __Default value:__ `true`, which corresponds to
      `[mousedown, window:mouseup] > window:mousemove!` which corresponds to
      clicks and dragging within an interval selection to reposition it.
  
    resolve:
      With layered and multi-view displays, a strategy that determines how
      selections' data queries are resolved when applied in a filter transform,
      conditional encoding rule, or scale domain.
  
    on:
      A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.
      For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
  
    mark:
      An interval selection also adds a rectangle mark to depict the
      extents of the interval. The `mark` property can be used to customize the
      appearance of the mark.
  
    fields:
      An array of field names whose values must match for a data tuple to
      fall within the selection.
  
    encodings:
      An array of encoding channels. The corresponding data field values
      must match for a data tuple to fall within the selection.
  
    bind:
      Establishes a two-way binding between the interval selection and the scales
      used within the same view. This allows a user to interactively pan and
      zoom the view.
  *)
  let to_yojson
    x =
    `Assoc
      (
List.filter
      (fun
      (k,v)  ->
      match v
      with
      | 
      `Null ->
      false
      | 
      _ -> true)
      [
      ("bind",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((function
      | `Scales
      ->
      `String
      "scales"))
      v))
      x.bind));
      ("encodings",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (l :
SingleDefChannel.t
      list)  ->
      let yojson_of_el
      (x :
SingleDefChannel.t)
      =
      (SingleDefChannel.to_yojson
      x : 
Yojson.Safe.json)
       in
      (`List
      (List.map
      yojson_of_el
      l) : 
Yojson.Safe.json)))
      v))
      x.encodings));
      ("fields",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (l :
      string
      list)  ->
      let yojson_of_el
      (s :
      string) =
      (`String
      s : 
Yojson.Safe.json)
       in
      (`List
      (List.map
      yojson_of_el
      l) : 
Yojson.Safe.json)))
      v))
      x.fields));
      ("mark",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
BrushConfig.t)
       ->
      (BrushConfig.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.mark));
      ("on",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
VgEventStream.t)
       ->
      (VgEventStream.to_yojson
      x : Yojson.Safe.json)))
      v)) x.on));
      ("resolve",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
SelectionResolution.t)
       ->
      (SelectionResolution.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.resolve));
      ("translate",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((function
      | `String
      v ->
      ((fun
      (s :
      string) 
      ->
      (`String
      s : Yojson.Safe.json)))
      v
      | `Bool v
      ->
      ((fun
      (b :
      bool)  ->
      (`Bool b : 
Yojson.Safe.json)))
      v)) v))
      x.translate));
      ("type",
      (((function
      | `Interval
      ->
      `String
      "interval"))
      x.typ));
      ("zoom",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((function
      | `String
      v ->
      ((fun
      (s :
      string) 
      ->
      (`String
      s : Yojson.Safe.json)))
      v
      | `Bool v
      ->
      ((fun
      (b :
      bool)  ->
      (`Bool b : 
Yojson.Safe.json)))
      v)) v))
x.zoom))])                                                                   
  let make
    ?bind 
    ?encodings 
    ?fields 
    ?mark  ?on 
    ?resolve 
    ?translate 
    ?zoom  ~typ
     () =
    {
      typ;
      zoom;
      translate;
      resolve;
      on;
      mark;
      fields;
      encodings;
      bind
    } 
  let withBind
    v x =
    {
      x with
      bind =
      (Some v)
    } 
  let withEncodings
    v x =
    {
      x with
      encodings
      =
      (Some v)
    } 
  let withFields
    v x =
    {
      x with
      fields =
      (Some v)
    } 
  let withMark
    v x =
    {
      x with
      mark =
      (Some v)
    } 
  let withOn v
    x =
    {
      x with
      on =
      (Some v)
    } 
  let withResolve
    v x =
    {
      x with
      resolve =
      (Some v)
    } 
  let withTranslate
    v x =
    {
      x with
      translate
      =
      (Some v)
    } 
  let withTyp v
    x =
    {
      x with
      typ = v
    } 
  let withZoom
    v x =
    {
      x with
      zoom =
      (Some v)
    } 
end and
InterpolateParams:
                                                                   sig
 type nonrec t =
 {
 typ:
 [ `Rgb 
 | `Cubehelix
  | 
 `Cubehelix_long
 ] ;
 gamma:
 [
 `Int of
 int 
 | `Float
 of float ]
 option }
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
 val make
 :
 ?gamma:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 typ:
 [ `Rgb 
 | `Cubehelix
  | 
 `Cubehelix_long
 ] ->
 unit -> t
 val
 withGamma
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTyp :
 [ `Rgb 
 | `Cubehelix
  | 
 `Cubehelix_long
 ] ->
 t -> t
end =
struct
 type nonrec t =
 {
 typ:
 [ `Rgb 
 | `Cubehelix
  | 
 `Cubehelix_long
 ] ;
 gamma:
 [
 `Int of
 int 
 | `Float
 of float ]
 option }

 let to_yojson
 x =
 `Assoc
 (List.filter
 (fun
 (k,v)  ->
 match v
 with
 | 
 `Null ->
 false
 | 
 _ -> true)
 [
 ("gamma",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.gamma));
 ("type",
 (((function
 | `Cubehelix_long
 ->
 `String
 "cubehelix_long"
 | `Cubehelix
 ->
 `String
 "cubehelix"
 | `Rgb ->
 `String
 "rgb"))
 x.typ))]) 
 let make
 ?gamma 
 ~typ  ()
 =
 {
 typ;
 gamma
 } 
 let withGamma
 v x =
 {
 x with
 gamma =
 (Some v)
 } 
 let withTyp
 v x =
 {
 x with
 typ = v
 } 
end
and
Interpolate:sig
  type t =
    [ `Linear  | `Linear_closed  | `Step  | `Step_before 
    | `Step_after  | `Basis  | `Basis_open  | `Basis_closed 
    | `Cardinal  | `Cardinal_open  | `Cardinal_closed 
    | `Bundle  | `Monotone ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Linear  | `Linear_closed  | `Step  | `Step_before  | `Step_after 
    | `Basis  | `Basis_open  | `Basis_closed  | `Cardinal 
    | `Cardinal_open  | `Cardinal_closed  | `Bundle  | `Monotone ]

  let to_yojson =
    function
    | `Monotone -> `String "monotone"
    | `Bundle -> `String "bundle"
    | `Cardinal_closed -> `String "cardinal_closed"
    | `Cardinal_open -> `String "cardinal_open"
    | `Cardinal -> `String "cardinal"
    | `Basis_closed -> `String "basis_closed"
    | `Basis_open -> `String "basis_open"
    | `Basis -> `String "basis"
    | `Step_after -> `String "step_after"
    | `Step_before -> `String "step_before"
    | `Step -> `String "step"
    | `Linear_closed -> `String "linear_closed"
    | `Linear -> `String "linear" 
end and
InlineData:sig
  type nonrec t =
    {
    values:
      [ `Jsons of Yojson.Safe.json list 
      | `String of string ] ;
    format: DataFormat.t option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?format:DataFormat.t ->
      values:[ `Jsons of Yojson.Safe.json list 
             | `String of string ]
        -> unit -> t
  val withFormat : DataFormat.t -> t -> t
  val withValues :
    [ `Jsons of Yojson.Safe.json list 
    | `String of string ] -> t -> t
end =
struct
  type nonrec t =
    {
    values: [ `Jsons of Yojson.Safe.json list  | `String of string ] ;
    format: DataFormat.t option }

  (** Fields
  
    values:
      The full data set, included inline. This can be a string or an array of objects or primitive values.
      Arrays of primitive values are ingested as objects with a `data` property.
  
    format:
      An object that specifies the format for parsing the data values.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("format",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : DataFormat.t)  ->
                       (DataFormat.to_yojson x : Yojson.Safe.json))) v))
               x.format));
         ("values",
           (((function
              | `String v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v
              | `Jsons v ->
                  ((fun (l : Yojson.Safe.json list)  ->
                      let yojson_of_el (j : Yojson.Safe.json) =
                        (j : Yojson.Safe.json)  in
                      (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
v)) x.values))])            
  let make ?format  ~values  () = { values; format } 
  let withFormat v x = { x with format = (Some v) } 
  let withValues v x = { x with values = v } 
end and
HorizontalAlign:sig
  type t = [ `Left  | `Right  | `Center ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = [ `Left  | `Right  | `Center ]

  let to_yojson =
    function
    | `Center -> `String "center"
    | `Right -> `String "right"
    | `Left -> `String "left" 
end and
Header:sig
  type nonrec t =
    {
    title: string option ;
    format: string option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?format:string -> ?title:string -> unit -> t
  val withFormat : string -> t -> t
  val withTitle : string -> t -> t
end =
struct
  type nonrec t =
    {
    title: string option ;
    format: string option }

  (** Headers of row / column channels for faceted plots.
  
  
  Fields:
  
    title:
      A title for the axis. Shows field name and its function by default.
      
      __Default value:__  derived from the field's name and transformation function applied e.g, "field_name", "SUM(field_name)", "BIN(field_name)", "YEAR(field_name)".
  
    format:
      The formatting pattern for labels. This is D3's [number format pattern](https://github.com/d3/d3-format#locale_format) for quantitative fields and D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format) for time field.
      
      __Default value:__  derived from [numberFormat](config.html#format) config for quantitative fields and from [timeFormat](config.html#format) config for temporal fields.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("format",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (s : string)  ->
                       (`String s : Yojson.Safe.json))) v))
               x.format));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
x.title))])                      
  let make ?format  ?title  () = { title; format } 
  let withFormat v x = { x with format = (Some v) } 
  let withTitle v x = { x with title = (Some v) } 
end and
HConcatSpec:sig
  type nonrec t =
    {
    transform: Transform.t list option ;
    title:
      [ `String of string 
      | `Params of TitleParams.t ] option ;
    resolve: Resolve.t option ;
    name: string option ;
    hconcat: Spec.t list ;
    description: string option ;
    data: Data.t option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?data:Data.t ->
      ?description:string ->
        ?name:string ->
          ?resolve:Resolve.t ->
            ?title:[ `String of string 
                   | `Params of
TitleParams.t ]
              ->
              ?transform:Transform.t list
                ->
                hconcat:Spec.t list ->
                  unit -> t
  val withData : Data.t -> t -> t
  val withDescription : string -> t -> t
  val withHconcat : Spec.t list -> t -> t
  val withName : string -> t -> t
  val withResolve : Resolve.t -> t -> t
  val withTitle :
    [ `String of string 
    | `Params of TitleParams.t ] -> 
      t -> t
  val withTransform :
Transform.t list -> t -> t
end =
struct
  type nonrec t =
    {
    transform: Transform.t list option ;
    title:
      [ `String of string  | `Params of TitleParams.t ]
        option
      ;
    resolve: Resolve.t option ;
    name: string option ;
    hconcat: Spec.t list ;
    description: string option ;
    data: Data.t option }

  (** Fields
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    name:
      Name of the visualization for later reference.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("data",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : Data.t)  ->
                       (Data.to_yojson x : Yojson.Safe.json)))
                     v)) x.data));
         ("description",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.description));
         ("hconcat",
           (((fun (l : Spec.t list)  ->
                let yojson_of_el (x : Spec.t) =
                  (Spec.to_yojson x : Yojson.Safe.json)
                   in
                (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) x.hconcat));
         ("name",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.name));
         ("resolve",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Resolve.t)  ->
                      (Resolve.to_yojson x : Yojson.Safe.json)))
                    v)) x.resolve));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : TitleParams.t)  ->
                            (TitleParams.to_yojson x : 
Yojson.Safe.json))) v
                    | `String v ->
                        ((fun (s : string)  ->
                            (`String s : Yojson.Safe.json)))
                          v)) v)) x.title));
         ("transform",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : Transform.t list)  ->
                      let yojson_of_el
                        (x : Transform.t) =
                        (Transform.to_yojson x : 
Yojson.Safe.json)  in
                      (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v))
x.transform))])                           
  let make ?data  ?description  ?name  ?resolve  ?title
     ?transform  ~hconcat  () =
    {
      hconcat;
      transform;
      title;
      resolve;
      name;
      description;
      data
    } 
  let withData v x = { x with data = (Some v) } 
  let withDescription v x =
    { x with description = (Some v) } 
  let withHconcat v x = { x with hconcat = v } 
  let withName v x = { x with name = (Some v) } 
  let withResolve v x = { x with resolve = (Some v) } 
  let withTitle v x = { x with title = (Some v) } 
  let withTransform v x =
    { x with transform = (Some v) } 
end and
Guide:sig
  type nonrec t =
    {
    title: string option ;
    format: string option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?format:string ->
      ?title:string -> unit -> t
  val withFormat : string -> t -> t
  val withTitle : string -> t -> t
end =
struct
  type nonrec t =
    {
    title: string option ;
    format: string option }

  (** Fields
  
    title:
      A title for the field.
      
      __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`).  If the field has a function, the function is displayed as an all capped text with parentheses wrapping the field name (e.g., `"SUM(field_name)"`, `"BIN(field_name)"`, `"YEAR(field_name)"`).  Otherwise, the title is simply the field name.
  
    format:
      The formatting pattern for labels. This is D3's [number format pattern](https://github.com/d3/d3-format#locale_format) for quantitative fields and D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format) for time field.
      
      See the [format documentation](format.html) for more information.
      
      __Default value:__  derived from [numberFormat](config.html#format) config for quantitative fields and from [timeFormat](config.html#format) config for temporal fields.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("format",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (s : string)  ->
                       (`String s : Yojson.Safe.json)))
                     v)) x.format));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
v)) x.title))])                                
  let make ?format  ?title  () = { title; format } 
  let withFormat v x =
    { x with format = (Some v) } 
  let withTitle v x = { x with title = (Some v) } 
end and
FontWeightNumber:sig
  type t =
    [ `Int of int 
    | `Float of float ]
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type t = [ `Int of int  | `Float of float ]

  let to_yojson =
    function
    | `Int i -> `Int i
    | `Float f -> `Float f 
end and
FontWeight:sig
  type t =
    [ `Normal  | `Bold ]
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type t = [ `Normal  | `Bold ]

  let to_yojson =
    function
    | `Bold -> `String "bold"
    | `Normal -> `String "normal" 
end and
FontStyle:sig
  type t =
    [ `Normal 
    | `Italic ]
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type t = [ `Normal  | `Italic ]

  let to_yojson =
    function
    | `Italic -> `String "italic"
    | `Normal -> `String "normal" 
end and
FilterTransform:sig
  type t =
FilterOperand.t
  val
    to_yojson
    :
    t ->
Yojson.Safe.json
end =
struct
  type t = FilterOperand.t

  (** Fields
  
    filter:
      The `filter` property must be either (1) a filter object for [equal-filters](filter.html#equalfilter),
      [range-filters](filter.html#rangefilter), [one-of filters](filter.html#oneoffilter), or [selection filters](filter.html#selectionfilter);
      (2) a [Vega Expression](filter.html#expression) string,
      where `datum` can be used to refer to the current data object; or (3) an array of filters (either objects or expression strings) that must all be true for a datum to pass the filter and be included.
  *)
  let to_yojson x =
    `Assoc
      [("filter",
         (((fun
              (x :
FilterOperand.t)
               ->
              (FilterOperand.to_yojson
                 x : Yojson.Safe.json)))
x))]                                                    
end and
FilterOperand:sig
  type t =
  [
  `Not of
NotFilter.t
   | 
  `And of
AndFilter.t
   | 
  `Or of
OrFilter.t
   | 
  `Filter
  of
Filter.t ]
  val
  to_yojson
  :
  t ->
Yojson.Safe.json
end =
struct
  type t =
    [
      `Not of NotFilter.t 
    | `And of AndFilter.t 
    | `Or of OrFilter.t 
    | `Filter of Filter.t ]

  let to_yojson =
    function
    | `Filter v ->
        ((fun
            (x :
Filter.t)
             ->
            (Filter.to_yojson
               x : 
Yojson.Safe.json)))
          v
    | `Or v ->
        ((fun
            (x :
OrFilter.t)
             ->
            (OrFilter.to_yojson
               x : 
Yojson.Safe.json)))
          v
    | `And v ->
        ((fun
            (x :
AndFilter.t)
             ->
            (AndFilter.to_yojson
               x : 
Yojson.Safe.json)))
          v
    | `Not v ->
        ((fun
            (x :
NotFilter.t)
             ->
            (NotFilter.to_yojson
               x : 
Yojson.Safe.json)))
v                                                         
end and
Filter:sig
  type t =
    [
    `Equal of
EqualFilter.t
     | 
    `Range of
RangeFilter.t
     | 
    `OneOf of
OneOfFilter.t
     | 
    `Selection
    of
SelectionFilter.t
     | 
    `String
    of 
    string ]
  val
    to_yojson
    :
    t ->
Yojson.Safe.json
end =
struct
  type t =
    [
      `Equal of
EqualFilter.t
         | `Range of
RangeFilter.t
            | 
      `OneOf of
OneOfFilter.t
         | `Selection
           of
SelectionFilter.t
            | 
      `String of
        string ]

  let to_yojson =
    function
    | `String v ->
        ((fun
           (s :
           string) 
           ->
           (`String
           s : 
Yojson.Safe.json)))
          v
    | `Selection v
        ->
        ((fun
           (x :
SelectionFilter.t)
            ->
           (SelectionFilter.to_yojson
           x : 
Yojson.Safe.json)))
          v
    | `OneOf v ->
        ((fun
           (x :
OneOfFilter.t)
            ->
           (OneOfFilter.to_yojson
           x : 
Yojson.Safe.json)))
          v
    | `Range v ->
        ((fun
           (x :
RangeFilter.t)
            ->
           (RangeFilter.to_yojson
           x : 
Yojson.Safe.json)))
          v
    | `Equal v ->
        ((fun
           (x :
EqualFilter.t)
            ->
           (EqualFilter.to_yojson
           x : 
Yojson.Safe.json)))
v                                                              
end and
FieldDefBase:
                                                              sig
  type nonrec t =
    {
    timeUnit:
TimeUnit.t
      option ;
    field:
Field.t
      option ;
    bin:
      [
      `Bool of
      bool 
      | `Params
      of
BinParams.t
      ] option ;
    aggregate:
Aggregate.t
      option }
  val to_yojson
    :
    t ->
Yojson.Safe.json
  val make :
    ?aggregate:Aggregate.t
      ->
      ?bin:
      [
      `Bool of
      bool 
      | `Params
      of
BinParams.t
      ] ->
      ?field:Field.t
      ->
      ?timeUnit:TimeUnit.t
      ->
      unit -> t
  val
    withAggregate
    :
Aggregate.t
      -> 
      t -> t
  val withBin :
    [
      `Bool of
      bool 
    | `Params
      of
BinParams.t
      ] ->
      t -> t
  val withField
    :
Field.t ->
      t -> t
  val
    withTimeUnit
    :
TimeUnit.t
      -> 
      t -> t
end =
struct
  type nonrec t =
    {
    timeUnit:
TimeUnit.t
      option ;
    field:
Field.t
      option ;
    bin:
      [
      `Bool of
      bool 
      | `Params
      of
BinParams.t
      ] option ;
    aggregate:
Aggregate.t
      option }

  (** Fields
  
    timeUnit:
      Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).
      
      __Default value:__ `undefined` (None)
  
    field:
      __Required.__ A string defining the name of the field from which to pull a data value
      or an object defining iterated values from the [`repeat`](repeat.html) operator.
      
      __Note:__ `field` is not required if `aggregate` is `count`.
  
    bin:
      A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).
      If `true`, default [binning parameters](bin.html) will be applied.
      
      __Default value:__ `false`
  
    aggregate:
      Aggregation function for the field
      (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
      
      __Default value:__ `undefined` (None)
  *)
  let to_yojson
    x =
    `Assoc
      (
List.filter
      (fun
      (k,v)  ->
      match v
      with
      | 
      `Null ->
      false
      | 
      _ -> true)
      [
      ("aggregate",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
Aggregate.t)
       ->
      (Aggregate.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.aggregate));
      ("bin",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((function
      | `Params
      v ->
      ((fun
      (x :
BinParams.t)
       ->
      (BinParams.to_yojson
      x : Yojson.Safe.json)))
      v
      | `Bool v
      ->
      ((fun
      (b :
      bool)  ->
      (`Bool b : 
Yojson.Safe.json)))
      v)) v))
      x.bin));
      ("field",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
Field.t) 
      ->
      (Field.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.field));
      ("timeUnit",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
TimeUnit.t)
       ->
      (TimeUnit.to_yojson
      x : Yojson.Safe.json)))
      v))
x.timeUnit))])                                                                   
  let make
    ?aggregate 
    ?bin 
    ?field 
    ?timeUnit 
    () =
    {
      timeUnit;
      field;
      bin;
      aggregate
    } 
  let withAggregate
    v x =
    {
      x with
      aggregate
      =
      (Some v)
    } 
  let withBin v
    x =
    {
      x with
      bin =
      (Some v)
    } 
  let withField
    v x =
    {
      x with
      field =
      (Some v)
    } 
  let withTimeUnit
    v x =
    {
      x with
      timeUnit
      =
      (Some v)
    } 
end and
FieldDef:
                                                                   sig
 type nonrec t =
 {
 typ:
Type.t ;
 timeUnit:
TimeUnit.t
 option ;
 field:
Field.t
 option ;
 bin:
 [
 `Bool of
 bool 
 | `Params
 of
BinParams.t
 ] option ;
 aggregate:
Aggregate.t
 option }
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
 val make
 :
 ?aggregate:Aggregate.t
 ->
 ?bin:
 [
 `Bool of
 bool 
 | `Params
 of
BinParams.t
 ] ->
 ?field:Field.t
 ->
 ?timeUnit:TimeUnit.t
 ->
 typ:Type.t
 ->
 unit -> t
 val
 withAggregate
 :
Aggregate.t
 -> 
 t -> t
 val
 withBin :
 [
 `Bool of
 bool 
 | `Params
 of
BinParams.t
 ] ->
 t -> t
 val
 withField
 :
Field.t
 -> 
 t -> t
 val
 withTimeUnit
 :
TimeUnit.t
 -> 
 t -> t
 val
 withTyp :
Type.t ->
 t -> t
end =
struct
 type nonrec t =
 {
 typ:
Type.t ;
 timeUnit:
TimeUnit.t
 option ;
 field:
Field.t
 option ;
 bin:
 [
 `Bool of
 bool 
 | `Params
 of
BinParams.t
 ] option ;
 aggregate:
Aggregate.t
 option }

  (** Definition object for a data field, its type and transformation of an encoding channel.
  
  
  Fields:
  
    type:
      The encoded field's type of measurement. This can be either a full type
      name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and `"nominal"`).
  
    timeUnit:
      Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).
      
      __Default value:__ `undefined` (None)
  
    field:
      __Required.__ A string defining the name of the field from which to pull a data value
      or an object defining iterated values from the [`repeat`](repeat.html) operator.
      
      __Note:__ `field` is not required if `aggregate` is `count`.
  
    bin:
      A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).
      If `true`, default [binning parameters](bin.html) will be applied.
      
      __Default value:__ `false`
  
    aggregate:
      Aggregation function for the field
      (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
      
      __Default value:__ `undefined` (None)
  *)
 let to_yojson
 x =
 `Assoc
 (List.filter
 (fun
 (k,v)  ->
 match v
 with
 | 
 `Null ->
 false
 | 
 _ -> true)
 [
 ("aggregate",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
Aggregate.t)
  ->
 (Aggregate.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.aggregate));
 ("bin",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Params
 v ->
 ((fun
 (x :
BinParams.t)
  ->
 (BinParams.to_yojson
 x : Yojson.Safe.json)))
 v
 | `Bool v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v)) v))
 x.bin));
 ("field",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
Field.t) 
 ->
 (Field.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.field));
 ("timeUnit",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
TimeUnit.t)
  ->
 (TimeUnit.to_yojson
 x : Yojson.Safe.json)))
 v))
 x.timeUnit));
 ("type",
 (((fun
 (x :
Type.t) 
 ->
 (Type.to_yojson
 x : Yojson.Safe.json)))
 x.typ))]) 
 let make
 ?aggregate
  ?bin 
 ?field 
 ?timeUnit
  ~typ  ()
 =
 {
 typ;
 timeUnit;
 field;
 bin;
 aggregate
 } 
 let withAggregate
 v x =
 {
 x with
 aggregate
 =
 (Some v)
 } 
 let withBin
 v x =
 {
 x with
 bin =
 (Some v)
 } 
 let withField
 v x =
 {
 x with
 field =
 (Some v)
 } 
 let withTimeUnit
 v x =
 {
 x with
 timeUnit
 =
 (Some v)
 } 
 let withTyp
 v x =
 {
 x with
 typ = v
 } 
end
and
Field:sig
  type t = [ `String of string  | `Repeat of RepeatRef.t ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = [ `String of string  | `Repeat of RepeatRef.t ]

  let to_yojson =
    function
    | `Repeat v ->
        ((fun (x : RepeatRef.t)  ->
            (RepeatRef.to_yojson x : Yojson.Safe.json))) v
    | `String v ->
((fun (s : string)  -> (`String s : Yojson.Safe.json))) v       
end and
FacetedUnitSpec:sig
  type t = FacetedCompositeUnitSpec.t
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = FacetedCompositeUnitSpec.t

  let to_yojson (x : FacetedCompositeUnitSpec.t) =
    (FacetedCompositeUnitSpec.to_yojson x : Yojson.Safe.json) 
end and
FacetedSpec:sig
  type nonrec t =
    {
    transform: Transform.t list option ;
    title:
      [ `String of string 
      | `Params of TitleParams.t ] option ;
    spec:
      [ `Layer of LayerSpec.t 
      | `Unit of CompositeUnitSpec.t ] ;
    resolve: Resolve.t option ;
    name: string option ;
    facet: Facet.t ;
    description: string option ;
    data: Data.t option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?data:Data.t ->
      ?description:string ->
        ?name:string ->
          ?resolve:Resolve.t ->
            ?title:[ `String of string 
                   | `Params of TitleParams.t ]
              ->
              ?transform:Transform.t list ->
                facet:Facet.t ->
                  spec:[ `Layer of LayerSpec.t 
                       | `Unit of CompositeUnitSpec.t ]
                    -> unit -> t
  val withData : Data.t -> t -> t
  val withDescription : string -> t -> t
  val withFacet : Facet.t -> t -> t
  val withName : string -> t -> t
  val withResolve : Resolve.t -> t -> t
  val withSpec :
    [ `Layer of LayerSpec.t 
    | `Unit of CompositeUnitSpec.t ] -> t -> t
  val withTitle :
    [ `String of string  | `Params of TitleParams.t ]
      -> t -> t
  val withTransform : Transform.t list -> t -> t
end =
struct
  type nonrec t =
    {
    transform: Transform.t list option ;
    title:
      [ `String of string  | `Params of TitleParams.t ] option ;
    spec:
      [ `Layer of LayerSpec.t  | `Unit of CompositeUnitSpec.t ] ;
    resolve: Resolve.t option ;
    name: string option ;
    facet: Facet.t ;
    description: string option ;
    data: Data.t option }

  (** Fields
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    name:
      Name of the visualization for later reference.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("data",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : Data.t)  ->
                       (Data.to_yojson x : Yojson.Safe.json))) v))
               x.data));
         ("description",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.description));
         ("facet",
           (((fun (x : Facet.t)  ->
                (Facet.to_yojson x : Yojson.Safe.json))) x.facet));
         ("name",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v)) x.name));
         ("resolve",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Resolve.t)  ->
                      (Resolve.to_yojson x : Yojson.Safe.json)))
                    v)) x.resolve));
         ("spec",
           (((function
              | `Unit v ->
                  ((fun (x : CompositeUnitSpec.t)  ->
                      (CompositeUnitSpec.to_yojson x : Yojson.Safe.json)))
                    v
              | `Layer v ->
                  ((fun (x : LayerSpec.t)  ->
                      (LayerSpec.to_yojson x : Yojson.Safe.json)))
                    v)) x.spec));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : TitleParams.t)  ->
                            (TitleParams.to_yojson x : Yojson.Safe.json)))
                          v
                    | `String v ->
                        ((fun (s : string)  ->
                            (`String s : Yojson.Safe.json))) v))
                    v)) x.title));
         ("transform",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : Transform.t list)  ->
                      let yojson_of_el (x : Transform.t) =
                        (Transform.to_yojson x : Yojson.Safe.json)
                         in
                      (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v)) x.transform))])                 
  let make ?data  ?description  ?name  ?resolve  ?title 
    ?transform  ~facet  ~spec  () =
    {
      spec;
      facet;
      transform;
      title;
      resolve;
      name;
      description;
      data
    } 
  let withData v x = { x with data = (Some v) } 
  let withDescription v x = { x with description = (Some v) } 
  let withFacet v x = { x with facet = v } 
  let withName v x = { x with name = (Some v) } 
  let withResolve v x = { x with resolve = (Some v) } 
  let withSpec v x = { x with spec = v } 
  let withTitle v x = { x with title = (Some v) } 
  let withTransform v x = { x with transform = (Some v) } 
end and
FacetedCompositeUnitSpec_Selection:sig
  type nonrec t =
    (string *
SelectionDef.t)
      list
  val to_yojson :
    t -> Yojson.Safe.json
end =
struct
  type nonrec t = (string * SelectionDef.t) list

  let to_yojson x =
    let mapper (k,v) =
      (k,
        ((fun (x : SelectionDef.t)  ->
            (SelectionDef.to_yojson x : Yojson.Safe.json)) v))
       in
    `Assoc (List.map mapper x) 
end and
FacetedCompositeUnitSpec:sig
  type nonrec t =
    {
    width:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    transform:
Transform.t list option ;
    title:
      [ `String of string 
      | `Params of
TitleParams.t ]
        option
      ;
    selection:
FacetedCompositeUnitSpec_Selection.t
        option
      ;
    name: string option ;
    mark: AnyMark.t ;
    height:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    encoding:
EncodingWithFacet.t ;
    description: string option ;
    data: Data.t option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?data:Data.t ->
      ?description:string ->
        ?height:[ `Int of int 
                | `Float of
                    float ]
          ->
          ?name:string ->
            ?selection:FacetedCompositeUnitSpec_Selection.t
              ->
              ?title:[
                     `String
                     of 
                     string 
                     | `Params
                     of
TitleParams.t
                     ]
                ->
                ?transform:Transform.t
                  list ->
                  ?width:
                    [
                     `Int of
                     int 
                    | `Float
                     of float ]
                    ->
                    encoding:EncodingWithFacet.t
                     ->
                     mark:AnyMark.t
                     ->
                     unit -> t
  val withData :
Data.t -> t -> t
  val withDescription :
    string -> t -> t
  val withEncoding :
EncodingWithFacet.t ->
      t -> t
  val withHeight :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withMark :
AnyMark.t -> t -> t
  val withName :
    string -> t -> t
  val withSelection :
FacetedCompositeUnitSpec_Selection.t
      -> t -> t
  val withTitle :
    [ `String of string 
    | `Params of TitleParams.t ]
      -> t -> t
  val withTransform :
Transform.t list -> t -> t
  val withWidth :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
end =
struct
  type nonrec t =
    {
    width: [ `Int of int  | `Float of float ] option ;
    transform: Transform.t list option ;
    title:
      [ `String of string  | `Params of TitleParams.t ]
        option
      ;
    selection:
FacetedCompositeUnitSpec_Selection.t option ;
    name: string option ;
    mark: AnyMark.t ;
    height: [ `Int of int  | `Float of float ] option ;
    encoding: EncodingWithFacet.t ;
    description: string option ;
    data: Data.t option }

  (** Fields
  
    width:
      The width of a visualization.
      
      __Default value:__ This will be determined by the following rules:
      
      - For x-axis with a continuous (non-ordinal) scale, the width will be the value of [`config.view.width`](spec.html#config).
      - For x-axis with an ordinal scale: if [`rangeStep`](scale.html#ordinal) is a numeric value (default), the width is determined by the value of `rangeStep` and the cardinality of the field mapped to x-channel.   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](spec.html#config).
      - If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.
      
      __Note:__ For plot with `row` and `column` channels, this represents the width of a single view.
      
      __See also:__ The documentation for [width and height](size.html) contains more examples.
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    selection:
      A key-value mapping between selection names and definitions.
  
    name:
      Name of the visualization for later reference.
  
    mark:
      A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`,
      `"area"`, `"point"`, `"rule"`, and `"text"`) or a [mark definition object](mark.html#mark-def).
  
    height:
      The height of a visualization.
      
      __Default value:__
      - For y-axis with a continuous (non-ordinal) scale, the height will be the value of [`config.view.height`](spec.html#config).
      - For y-axis with an ordinal scale: if [`rangeStep`](scale.html#ordinal) is a numeric value (default), the height is determined by the value of `rangeStep` and the cardinality of the field mapped to y-channel.   Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](spec.html#config).
      - If no field is mapped to `x` channel, the `height` will be the value of `rangeStep`.
      
      __Note__: For plot with `row` and `column` channels, this represents the height of a single view.
      
      __See also:__ The documentation for [width and height](size.html) contains more examples.
  
    encoding:
      A key-value mapping between encoding channels and definition of fields.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("data",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : Data.t)  ->
                       (Data.to_yojson x : Yojson.Safe.json)))
                     v)) x.data));
         ("description",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.description));
         ("encoding",
           (((fun (x : EncodingWithFacet.t)  ->
                (EncodingWithFacet.to_yojson x : 
Yojson.Safe.json))) x.encoding));
         ("height",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v))
              x.height));
         ("mark",
           (((fun (x : AnyMark.t)  ->
                (AnyMark.to_yojson x : Yojson.Safe.json)))
              x.mark));
         ("name",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.name));
         ("selection",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
FacetedCompositeUnitSpec_Selection.t)
                       ->
                      (FacetedCompositeUnitSpec_Selection.to_yojson
                         x : Yojson.Safe.json))) v))
              x.selection));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : TitleParams.t)  ->
                            (TitleParams.to_yojson x : 
Yojson.Safe.json))) v
                    | `String v ->
                        ((fun (s : string)  ->
                            (`String s : Yojson.Safe.json)))
                          v)) v)) x.title));
         ("transform",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : Transform.t list)  ->
                      let yojson_of_el
                        (x : Transform.t) =
                        (Transform.to_yojson x : 
Yojson.Safe.json)  in
                      (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v))
              x.transform));
         ("width",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v))
x.width))])                           
  let make ?data  ?description  ?height  ?name 
    ?selection  ?title  ?transform  ?width  ~encoding 
    ~mark  () =
    {
      mark;
      encoding;
      width;
      transform;
      title;
      selection;
      name;
      height;
      description;
      data
    } 
  let withData v x = { x with data = (Some v) } 
  let withDescription v x =
    { x with description = (Some v) } 
  let withEncoding v x = { x with encoding = v } 
  let withHeight v x = { x with height = (Some v) } 
  let withMark v x = { x with mark = v } 
  let withName v x = { x with name = (Some v) } 
  let withSelection v x =
    { x with selection = (Some v) } 
  let withTitle v x = { x with title = (Some v) } 
  let withTransform v x =
    { x with transform = (Some v) } 
  let withWidth v x = { x with width = (Some v) } 
end and
FacetFieldDef:sig
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit: TimeUnit.t option ;
    sort: SortOrder.t option ;
    header: Header.t option ;
    field: Field.t option ;
    bin:
      [ `Bool of bool 
      | `Params of BinParams.t ]
        option
      ;
    aggregate: Aggregate.t option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?aggregate:Aggregate.t ->
      ?bin:[ `Bool of bool 
           | `Params of BinParams.t ]
        ->
        ?field:Field.t ->
          ?header:Header.t ->
            ?sort:SortOrder.t ->
              ?timeUnit:TimeUnit.t
                ->
                typ:Type.t ->
                  unit -> t
  val withAggregate :
Aggregate.t -> t -> t
  val withBin :
    [ `Bool of bool 
    | `Params of BinParams.t ] ->
      t -> t
  val withField : Field.t -> t -> t
  val withHeader :
Header.t -> t -> t
  val withSort :
SortOrder.t -> t -> t
  val withTimeUnit :
TimeUnit.t -> t -> t
  val withTyp : Type.t -> t -> t
end =
struct
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit: TimeUnit.t option ;
    sort: SortOrder.t option ;
    header: Header.t option ;
    field: Field.t option ;
    bin:
      [ `Bool of bool  | `Params of BinParams.t ]
        option
      ;
    aggregate: Aggregate.t option }

  (** Fields
  
    type:
      The encoded field's type of measurement. This can be either a full type
      name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and `"nominal"`).
  
    timeUnit:
      Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).
      
      __Default value:__ `undefined` (None)
  
    sort:
      Sort order for a facet field.
      This can be `"ascending"`, `"descending"`.
  
    field:
      __Required.__ A string defining the name of the field from which to pull a data value
      or an object defining iterated values from the [`repeat`](repeat.html) operator.
      
      __Note:__ `field` is not required if `aggregate` is `count`.
  
    bin:
      A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).
      If `true`, default [binning parameters](bin.html) will be applied.
      
      __Default value:__ `false`
  
    aggregate:
      Aggregation function for the field
      (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
      
      __Default value:__ `undefined` (None)
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("aggregate",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : Aggregate.t)  ->
                       (Aggregate.to_yojson x : 
Yojson.Safe.json))) v))
               x.aggregate));
         ("bin",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : BinParams.t) 
                            ->
                            (BinParams.to_yojson x : 
Yojson.Safe.json))) v
                    | `Bool v ->
                        ((fun (b : bool)  ->
                            (`Bool b : Yojson.Safe.json)))
                          v)) v)) x.bin));
         ("field",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Field.t)  ->
                      (Field.to_yojson x : 
Yojson.Safe.json))) v))
              x.field));
         ("header",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Header.t)  ->
                      (Header.to_yojson x : 
Yojson.Safe.json))) v))
              x.header));
         ("sort",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : SortOrder.t)  ->
                      (SortOrder.to_yojson x : 
Yojson.Safe.json))) v))
              x.sort));
         ("timeUnit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : TimeUnit.t)  ->
                      (TimeUnit.to_yojson x : 
Yojson.Safe.json))) v))
              x.timeUnit));
         ("type",
           (((fun (x : Type.t)  ->
                (Type.to_yojson x : Yojson.Safe.json)))
x.typ))])                                
  let make ?aggregate  ?bin  ?field  ?header 
    ?sort  ?timeUnit  ~typ  () =
    {
      typ;
      timeUnit;
      sort;
      header;
      field;
      bin;
      aggregate
    } 
  let withAggregate v x =
    { x with aggregate = (Some v) } 
  let withBin v x = { x with bin = (Some v) } 
  let withField v x = { x with field = (Some v) } 
  let withHeader v x =
    { x with header = (Some v) } 
  let withSort v x = { x with sort = (Some v) } 
  let withTimeUnit v x =
    { x with timeUnit = (Some v) } 
  let withTyp v x = { x with typ = v } 
end and
Facet:sig
  type nonrec t =
    {
    row: FacetFieldDef.t option ;
    column: FacetFieldDef.t option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?column:FacetFieldDef.t ->
      ?row:FacetFieldDef.t -> unit -> t
  val withColumn :
FacetFieldDef.t -> t -> t
  val withRow :
FacetFieldDef.t -> t -> t
end =
struct
  type nonrec t =
    {
    row: FacetFieldDef.t option ;
    column: FacetFieldDef.t option }

  (** Fields
  
    row:
      Vertical facets for trellis plots.
  
    column:
      Horizontal facets for trellis plots.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("column",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun
                       (x : FacetFieldDef.t) 
                       ->
                       (FacetFieldDef.to_yojson
                          x : Yojson.Safe.json)))
                     v)) x.column));
         ("row",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : FacetFieldDef.t)
                       ->
                      (FacetFieldDef.to_yojson
                         x : Yojson.Safe.json)))
v)) x.row))])                                     
  let make ?column  ?row  () =
    { row; column } 
  let withColumn v x =
    { x with column = (Some v) } 
  let withRow v x = { x with row = (Some v) } 
end and
EqualFilter:sig
  type nonrec t =
    {
    timeUnit:
TimeUnit.t option ;
    field: string ;
    equal:
      [ `String of string 
      | `Float of float 
      | `Int of int 
      | `Bool of bool 
      | `DateTime of
DateTime.t ]
      }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?timeUnit:TimeUnit.t ->
      equal:[
              `String of
                string 
            | `Float of
                float 
            | `Int of int 
            | `Bool of bool 
            | `DateTime of
DateTime.t ]
        ->
        field:string ->
          unit -> t
  val withEqual :
    [ `String of string 
    | `Float of float 
    | `Int of int 
    | `Bool of bool 
    | `DateTime of
DateTime.t ]
      -> t -> t
  val withField :
    string -> t -> t
  val withTimeUnit :
TimeUnit.t -> t -> t
end =
struct
  type nonrec t =
    {
    timeUnit: TimeUnit.t option ;
    field: string ;
    equal:
      [ `String of string 
      | `Float of float  | `Int of int 
      | `Bool of bool 
      | `DateTime of DateTime.t ] }

  (** Fields
  
    timeUnit:
      Time unit for the field to be filtered.
  
    field:
      Field to be filtered.
  
    equal:
      The value that the field should be equal to.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("equal",
            (((function
               | `DateTime v ->
                   ((fun
                       (x : DateTime.t) 
                       ->
                       (DateTime.to_yojson
                          x : Yojson.Safe.json)))
                     v
               | `Bool v ->
                   ((fun (b : bool)  ->
                       (`Bool b : 
Yojson.Safe.json)))
                     v
               | `Int v ->
                   ((fun (i : int)  ->
                       (`Int i : 
Yojson.Safe.json)))
                     v
               | `Float v ->
                   ((fun (f : float)  ->
                       (`Float f : 
Yojson.Safe.json)))
                     v
               | `String v ->
                   ((fun (s : string) 
                       ->
                       (`String s : 
Yojson.Safe.json)))
                     v)) x.equal));
         ("field",
           (((fun (s : string)  ->
                (`String s : Yojson.Safe.json)))
              x.field));
         ("timeUnit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : TimeUnit.t)
                       ->
                      (TimeUnit.to_yojson
                         x : Yojson.Safe.json)))
v)) x.timeUnit))])                                          
  let make ?timeUnit  ~equal  ~field  ()
    = { field; equal; timeUnit } 
  let withEqual v x =
    { x with equal = v } 
  let withField v x =
    { x with field = v } 
  let withTimeUnit v x =
    { x with timeUnit = (Some v) } 
end and
EncodingWithFacet:sig
  type nonrec t =
    {
    y2:
      [
        `Field of
FieldDef.t
         | 
        `Value of
ValueDef.t
        ] option
      ;
    y:
      [
        `Field of
PositionFieldDef.t
         | 
        `Value of
ValueDef.t
        ] option
      ;
    x2:
      [
        `Field of
FieldDef.t
         | 
        `Value of
ValueDef.t
        ] option
      ;
    x:
      [
        `Field of
PositionFieldDef.t
         | 
        `Value of
ValueDef.t
        ] option
      ;
    tooltip:
      [
        `Field of
ConditionalTextFieldDef.t
         | 
        `Value of
ConditionalTextValueDef.t
        ] option
      ;
    text:
      [
        `Field of
ConditionalTextFieldDef.t
         | 
        `Value of
ConditionalTextValueDef.t
        ] option
      ;
    size:
      [
        `Field of
ConditionalLegendFieldDef.t
         | 
        `Value of
ConditionalLegendValueDef.t
        ] option
      ;
    shape:
      [
        `Field of
ConditionalLegendFieldDef.t
         | 
        `Value of
ConditionalLegendValueDef.t
        ] option
      ;
    row:
FacetFieldDef.t
        option
      ;
    order:
      [
        `Field of
OrderFieldDef.t
         | 
        `Fields
        of
OrderFieldDef.t
        list ]
        option
      ;
    opacity:
      [
        `Field of
ConditionalLegendFieldDef.t
         | 
        `Value of
ConditionalLegendValueDef.t
        ] option
      ;
    detail:
      [
        `Field of
FieldDef.t
         | 
        `Fields
        of
FieldDef.t
        list ]
        option
      ;
    column:
FacetFieldDef.t
        option
      ;
    color:
      [
        `Field of
ConditionalLegendFieldDef.t
         | 
        `Value of
ConditionalLegendValueDef.t
        ] option
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?color:
      [
        `Field of
ConditionalLegendFieldDef.t
         | 
        `Value of
ConditionalLegendValueDef.t
        ]
      ->
      ?column:FacetFieldDef.t
        ->
        ?detail:
        [
        `Field of
FieldDef.t
         | 
        `Fields
        of
FieldDef.t
        list ] ->
        ?opacity:
        [
        `Field of
ConditionalLegendFieldDef.t
         | 
        `Value of
ConditionalLegendValueDef.t
        ] ->
        ?order:
        [
        `Field of
OrderFieldDef.t
         | 
        `Fields
        of
OrderFieldDef.t
        list ] ->
        ?row:FacetFieldDef.t
        ->
        ?shape:
        [
        `Field of
ConditionalLegendFieldDef.t
         | 
        `Value of
ConditionalLegendValueDef.t
        ] ->
        ?size:
        [
        `Field of
ConditionalLegendFieldDef.t
         | 
        `Value of
ConditionalLegendValueDef.t
        ] ->
        ?text:
        [
        `Field of
ConditionalTextFieldDef.t
         | 
        `Value of
ConditionalTextValueDef.t
        ] ->
        ?tooltip:
        [
        `Field of
ConditionalTextFieldDef.t
         | 
        `Value of
ConditionalTextValueDef.t
        ] ->
        ?x:
        [
        `Field of
PositionFieldDef.t
         | 
        `Value of
ValueDef.t
        ] ->
        ?x2:
        [
        `Field of
FieldDef.t
         | 
        `Value of
ValueDef.t
        ] ->
        ?y:
        [
        `Field of
PositionFieldDef.t
         | 
        `Value of
ValueDef.t
        ] ->
        ?y2:
        [
        `Field of
FieldDef.t
         | 
        `Value of
ValueDef.t
        ] ->
        unit -> t
  val withColor :
    [
      `Field of
ConditionalLegendFieldDef.t
         | 
      `Value of
ConditionalLegendValueDef.t
        ]
      -> 
      t -> t
  val withColumn
    :
FacetFieldDef.t
      -> 
      t -> t
  val withDetail
    :
    [
      `Field of
FieldDef.t
         | 
      `Fields of
FieldDef.t
        list ]
      -> 
      t -> t
  val withOpacity
    :
    [
      `Field of
ConditionalLegendFieldDef.t
         | 
      `Value of
ConditionalLegendValueDef.t
        ]
      -> 
      t -> t
  val withOrder :
    [
      `Field of
OrderFieldDef.t
         | 
      `Fields of
OrderFieldDef.t
        list ]
      -> 
      t -> t
  val withRow :
FacetFieldDef.t
      -> 
      t -> t
  val withShape :
    [
      `Field of
ConditionalLegendFieldDef.t
         | 
      `Value of
ConditionalLegendValueDef.t
        ]
      -> 
      t -> t
  val withSize :
    [
      `Field of
ConditionalLegendFieldDef.t
         | 
      `Value of
ConditionalLegendValueDef.t
        ]
      -> 
      t -> t
  val withText :
    [
      `Field of
ConditionalTextFieldDef.t
         | 
      `Value of
ConditionalTextValueDef.t
        ]
      -> 
      t -> t
  val withTooltip
    :
    [
      `Field of
ConditionalTextFieldDef.t
         | 
      `Value of
ConditionalTextValueDef.t
        ]
      -> 
      t -> t
  val withX :
    [
      `Field of
PositionFieldDef.t
         | 
      `Value of
ValueDef.t
        ]
      -> 
      t -> t
  val withX2 :
    [
      `Field of
FieldDef.t
         | 
      `Value of
ValueDef.t
        ]
      -> 
      t -> t
  val withY :
    [
      `Field of
PositionFieldDef.t
         | 
      `Value of
ValueDef.t
        ]
      -> 
      t -> t
  val withY2 :
    [
      `Field of
FieldDef.t
         | 
      `Value of
ValueDef.t
        ]
      -> 
      t -> t
end =
struct
  type nonrec t =
    {
    y2:
      [ `Field of FieldDef.t 
      | `Value of ValueDef.t ]
        option
      ;
    y:
      [
        `Field of
PositionFieldDef.t 
      | `Value of ValueDef.t ]
        option
      ;
    x2:
      [ `Field of FieldDef.t 
      | `Value of ValueDef.t ]
        option
      ;
    x:
      [
        `Field of
PositionFieldDef.t 
      | `Value of ValueDef.t ]
        option
      ;
    tooltip:
      [
        `Field of
ConditionalTextFieldDef.t 
      | `Value of
ConditionalTextValueDef.t ]
        option
      ;
    text:
      [
        `Field of
ConditionalTextFieldDef.t 
      | `Value of
ConditionalTextValueDef.t ]
        option
      ;
    size:
      [
        `Field of
ConditionalLegendFieldDef.t
           | `Value of
ConditionalLegendValueDef.t
               ]
        option
      ;
    shape:
      [
        `Field of
ConditionalLegendFieldDef.t
           | `Value of
ConditionalLegendValueDef.t
               ]
        option
      ;
    row: FacetFieldDef.t option ;
    order:
      [ `Field of OrderFieldDef.t 
      | `Fields of
OrderFieldDef.t list ]
        option
      ;
    opacity:
      [
        `Field of
ConditionalLegendFieldDef.t
           | `Value of
ConditionalLegendValueDef.t
               ]
        option
      ;
    detail:
      [ `Field of FieldDef.t 
      | `Fields of FieldDef.t list ]
        option
      ;
    column: FacetFieldDef.t option ;
    color:
      [
        `Field of
ConditionalLegendFieldDef.t
           | `Value of
ConditionalLegendValueDef.t
               ]
        option
      }

  (** Fields
  
    y2:
      Y2 coordinates for ranged  `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
  
    y:
      Y coordinates of the marks, or height of vertical `"bar"` and `"area"`.
  
    x2:
      X2 coordinates for ranged  `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
  
    x:
      X coordinates of the marks, or width of horizontal `"bar"` and `"area"`.
  
    tooltip:
      The tooltip text to show upon mouse hover.
  
    text:
      Text of the `text` mark.
  
    size:
      Size of the mark.
      - For `"point"`, `"square"` and `"circle"`,  the symbol size, or pixel area of the mark.
      - For `"bar"` and `"tick"`  the bar and tick's size.
      - For `"text"`  the text's font size.
      - Size is currently unsupported for `"line"`, `"area"`, and `"rect"`.
  
    shape:
      The symbol's shape (only for `point` marks). The supported values are
      `"circle"` (default), `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`,
      or `"triangle-down"`, or else a custom SVG path string.
      __Default value:__ If undefined, the default shape depends on [mark config](config.html#point-config)'s `shape` property.
  
    row:
      Vertical facets for trellis plots.
  
    order:
      Stack order for stacked marks or order of data points in line marks for connected scatter plots.
      
      __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping.
  
    opacity:
      Opacity of the marks  either can be a value or a range.
      
      __Default value:__ If undefined, the default opacity depends on [mark config](config.html#mark)'s `opacity` property.
  
    detail:
      Additional levels of detail for grouping data in aggregate views and
      in line and area marks without mapping data to a specific visual channel.
  
    column:
      Horizontal facets for trellis plots.
  
    color:
      Color of the marks  either fill or stroke color based on mark type.
      By default, `color` represents fill color for `"area"`, `"bar"`, `"tick"`,
      `"text"`, `"circle"`, and `"square"` / stroke color for `"line"` and `"point"`.
      
      __Default value:__ If undefined, the default color depends on [mark config](config.html#mark)'s `color` property.
      
      _Note:_ See the scale documentation for more information about customizing [color scheme](scale.html#scheme).
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("color",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function
                     | `Value v ->
                         ((fun
                          (x :
ConditionalLegendValueDef.t)
                           ->
                          (ConditionalLegendValueDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v
                     | `Field v ->
                         ((fun
                          (x :
ConditionalLegendFieldDef.t)
                           ->
                          (ConditionalLegendFieldDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v)) v))
               x.color));
         ("column",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
FacetFieldDef.t)
                       ->
                      (FacetFieldDef.to_yojson
                         x : 
Yojson.Safe.json)))
                    v)) x.column));
         ("detail",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Fields v ->
                        ((fun
                          (l :
FieldDef.t
                          list)  ->
                          let yojson_of_el
                          (x :
FieldDef.t)
                          =
                          (FieldDef.to_yojson
                          x : 
Yojson.Safe.json)
                           in
                          (`List
                          (List.map
                          yojson_of_el
                          l) : 
Yojson.Safe.json)))
                          v
                    | `Field v ->
                        ((fun
                          (x :
FieldDef.t)
                           ->
                          (FieldDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v)) v))
              x.detail));
         ("opacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Value v ->
                        ((fun
                          (x :
ConditionalLegendValueDef.t)
                           ->
                          (ConditionalLegendValueDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v
                    | `Field v ->
                        ((fun
                          (x :
ConditionalLegendFieldDef.t)
                           ->
                          (ConditionalLegendFieldDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v)) v))
              x.opacity));
         ("order",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Fields v ->
                        ((fun
                          (l :
OrderFieldDef.t
                          list)  ->
                          let yojson_of_el
                          (x :
OrderFieldDef.t)
                          =
                          (OrderFieldDef.to_yojson
                          x : 
Yojson.Safe.json)
                           in
                          (`List
                          (List.map
                          yojson_of_el
                          l) : 
Yojson.Safe.json)))
                          v
                    | `Field v ->
                        ((fun
                          (x :
OrderFieldDef.t)
                           ->
                          (OrderFieldDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v)) v))
              x.order));
         ("row",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
FacetFieldDef.t)
                       ->
                      (FacetFieldDef.to_yojson
                         x : 
Yojson.Safe.json)))
                    v)) x.row));
         ("shape",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Value v ->
                        ((fun
                          (x :
ConditionalLegendValueDef.t)
                           ->
                          (ConditionalLegendValueDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v
                    | `Field v ->
                        ((fun
                          (x :
ConditionalLegendFieldDef.t)
                           ->
                          (ConditionalLegendFieldDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v)) v))
              x.shape));
         ("size",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Value v ->
                        ((fun
                          (x :
ConditionalLegendValueDef.t)
                           ->
                          (ConditionalLegendValueDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v
                    | `Field v ->
                        ((fun
                          (x :
ConditionalLegendFieldDef.t)
                           ->
                          (ConditionalLegendFieldDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v)) v))
              x.size));
         ("text",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Value v ->
                        ((fun
                          (x :
ConditionalTextValueDef.t)
                           ->
                          (ConditionalTextValueDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v
                    | `Field v ->
                        ((fun
                          (x :
ConditionalTextFieldDef.t)
                           ->
                          (ConditionalTextFieldDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v)) v))
              x.text));
         ("tooltip",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Value v ->
                        ((fun
                          (x :
ConditionalTextValueDef.t)
                           ->
                          (ConditionalTextValueDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v
                    | `Field v ->
                        ((fun
                          (x :
ConditionalTextFieldDef.t)
                           ->
                          (ConditionalTextFieldDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v)) v))
              x.tooltip));
         ("x",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Value v ->
                        ((fun
                          (x :
ValueDef.t)
                           ->
                          (ValueDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v
                    | `Field v ->
                        ((fun
                          (x :
PositionFieldDef.t)
                           ->
                          (PositionFieldDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v)) v))
              x.x));
         ("x2",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Value v ->
                        ((fun
                          (x :
ValueDef.t)
                           ->
                          (ValueDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v
                    | `Field v ->
                        ((fun
                          (x :
FieldDef.t)
                           ->
                          (FieldDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v)) v))
              x.x2));
         ("y",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Value v ->
                        ((fun
                          (x :
ValueDef.t)
                           ->
                          (ValueDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v
                    | `Field v ->
                        ((fun
                          (x :
PositionFieldDef.t)
                           ->
                          (PositionFieldDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v)) v))
              x.y));
         ("y2",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Value v ->
                        ((fun
                          (x :
ValueDef.t)
                           ->
                          (ValueDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v
                    | `Field v ->
                        ((fun
                          (x :
FieldDef.t)
                           ->
                          (FieldDef.to_yojson
                          x : 
Yojson.Safe.json)))
                          v)) v))
x.y2))])                                               
  let make ?color  ?column  ?detail
     ?opacity  ?order  ?row  ?shape
     ?size  ?text  ?tooltip  ?x 
    ?x2  ?y  ?y2  () =
    {
      y2;
      y;
      x2;
      x;
      tooltip;
      text;
      size;
      shape;
      row;
      order;
      opacity;
      detail;
      column;
      color
    } 
  let withColor v x =
    { x with color = (Some v) } 
  let withColumn v x =
    { x with column = (Some v) } 
  let withDetail v x =
    { x with detail = (Some v) } 
  let withOpacity v x =
    { x with opacity = (Some v) } 
  let withOrder v x =
    { x with order = (Some v) } 
  let withRow v x =
    { x with row = (Some v) } 
  let withShape v x =
    { x with shape = (Some v) } 
  let withSize v x =
    { x with size = (Some v) } 
  let withText v x =
    { x with text = (Some v) } 
  let withTooltip v x =
    { x with tooltip = (Some v) } 
  let withX v x =
    { x with x = (Some v) } 
  let withX2 v x =
    { x with x2 = (Some v) } 
  let withY v x =
    { x with y = (Some v) } 
  let withY2 v x =
    { x with y2 = (Some v) } 
end and
Encoding:sig
  type nonrec t =
    {
    y2:
      [
        `Field of
FieldDef.t 
      | `Value of
ValueDef.t ]
        option
      ;
    y:
      [
        `Field of
PositionFieldDef.t
           | 
        `Value of
ValueDef.t ]
        option
      ;
    x2:
      [
        `Field of
FieldDef.t 
      | `Value of
ValueDef.t ]
        option
      ;
    x:
      [
        `Field of
PositionFieldDef.t
           | 
        `Value of
ValueDef.t ]
        option
      ;
    tooltip:
      [
        `Field of
ConditionalTextFieldDef.t
           | 
        `Value of
ConditionalTextValueDef.t
          ]
        option
      ;
    text:
      [
        `Field of
ConditionalTextFieldDef.t
           | 
        `Value of
ConditionalTextValueDef.t
          ]
        option
      ;
    size:
      [
        `Field of
ConditionalLegendFieldDef.t
           | 
        `Value of
ConditionalLegendValueDef.t
          ]
        option
      ;
    shape:
      [
        `Field of
ConditionalLegendFieldDef.t
           | 
        `Value of
ConditionalLegendValueDef.t
          ]
        option
      ;
    order:
      [
        `Field of
OrderFieldDef.t
           | 
        `Fields of
OrderFieldDef.t
            list
          ]
        option
      ;
    opacity:
      [
        `Field of
ConditionalLegendFieldDef.t
           | 
        `Value of
ConditionalLegendValueDef.t
          ]
        option
      ;
    detail:
      [
        `Field of
FieldDef.t 
      | `Fields of
FieldDef.t
            list
          ]
        option
      ;
    color:
      [
        `Field of
ConditionalLegendFieldDef.t
           | 
        `Value of
ConditionalLegendValueDef.t
          ]
        option
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?color:[
            `Field of
ConditionalLegendFieldDef.t
             | 
            `Value of
ConditionalLegendValueDef.t
            ]
      ->
      ?detail:
        [
          `Field of
FieldDef.t
             | 
          `Fields of
FieldDef.t
            list ]
        ->
        ?opacity:
          [
            `Field of
ConditionalLegendFieldDef.t
             | 
            `Value of
ConditionalLegendValueDef.t
            ]
          ->
          ?order:
            [
            `Field of
OrderFieldDef.t
             | 
            `Fields
            of
OrderFieldDef.t
            list ] ->
            ?shape:
            [
            `Field of
ConditionalLegendFieldDef.t
             | 
            `Value of
ConditionalLegendValueDef.t
            ] ->
            ?size:
            [
            `Field of
ConditionalLegendFieldDef.t
             | 
            `Value of
ConditionalLegendValueDef.t
            ] ->
            ?text:
            [
            `Field of
ConditionalTextFieldDef.t
             | 
            `Value of
ConditionalTextValueDef.t
            ] ->
            ?tooltip:
            [
            `Field of
ConditionalTextFieldDef.t
             | 
            `Value of
ConditionalTextValueDef.t
            ] ->
            ?x:
            [
            `Field of
PositionFieldDef.t
             | 
            `Value of
ValueDef.t
            ] ->
            ?x2:
            [
            `Field of
FieldDef.t
             | 
            `Value of
ValueDef.t
            ] ->
            ?y:
            [
            `Field of
PositionFieldDef.t
             | 
            `Value of
ValueDef.t
            ] ->
            ?y2:
            [
            `Field of
FieldDef.t
             | 
            `Value of
ValueDef.t
            ] ->
            unit -> t
  val withColor :
    [
      `Field of
ConditionalLegendFieldDef.t
         | `Value of
ConditionalLegendValueDef.t
            ]
      -> t -> t
  val withDetail :
    [
      `Field of
FieldDef.t 
    | `Fields of
FieldDef.t
          list
        ]
      -> t -> t
  val withOpacity :
    [
      `Field of
ConditionalLegendFieldDef.t
         | `Value of
ConditionalLegendValueDef.t
            ]
      -> t -> t
  val withOrder :
    [
      `Field of
OrderFieldDef.t
         | `Fields of
OrderFieldDef.t
            list ]
      -> t -> t
  val withShape :
    [
      `Field of
ConditionalLegendFieldDef.t
         | `Value of
ConditionalLegendValueDef.t
            ]
      -> t -> t
  val withSize :
    [
      `Field of
ConditionalLegendFieldDef.t
         | `Value of
ConditionalLegendValueDef.t
            ]
      -> t -> t
  val withText :
    [
      `Field of
ConditionalTextFieldDef.t
         | `Value of
ConditionalTextValueDef.t
            ]
      -> t -> t
  val withTooltip :
    [
      `Field of
ConditionalTextFieldDef.t
         | `Value of
ConditionalTextValueDef.t
            ]
      -> t -> t
  val withX :
    [
      `Field of
PositionFieldDef.t
         | `Value of
ValueDef.t
            ]
      -> t -> t
  val withX2 :
    [
      `Field of
FieldDef.t 
    | `Value of
ValueDef.t ]
      -> t -> t
  val withY :
    [
      `Field of
PositionFieldDef.t
         | `Value of
ValueDef.t
            ]
      -> t -> t
  val withY2 :
    [
      `Field of
FieldDef.t 
    | `Value of
ValueDef.t ]
      -> t -> t
end =
struct
  type nonrec t =
    {
    y2:
      [ `Field of FieldDef.t 
      | `Value of ValueDef.t ]
        option
      ;
    y:
      [
        `Field of
PositionFieldDef.t 
      | `Value of ValueDef.t ]
        option
      ;
    x2:
      [ `Field of FieldDef.t 
      | `Value of ValueDef.t ]
        option
      ;
    x:
      [
        `Field of
PositionFieldDef.t 
      | `Value of ValueDef.t ]
        option
      ;
    tooltip:
      [
        `Field of
ConditionalTextFieldDef.t
           | `Value of
ConditionalTextValueDef.t
               ]
        option
      ;
    text:
      [
        `Field of
ConditionalTextFieldDef.t
           | `Value of
ConditionalTextValueDef.t
               ]
        option
      ;
    size:
      [
        `Field of
ConditionalLegendFieldDef.t
           | `Value of
ConditionalLegendValueDef.t
               ]
        option
      ;
    shape:
      [
        `Field of
ConditionalLegendFieldDef.t
           | `Value of
ConditionalLegendValueDef.t
               ]
        option
      ;
    order:
      [
        `Field of
OrderFieldDef.t 
      | `Fields of
OrderFieldDef.t list ]
        option
      ;
    opacity:
      [
        `Field of
ConditionalLegendFieldDef.t
           | `Value of
ConditionalLegendValueDef.t
               ]
        option
      ;
    detail:
      [ `Field of FieldDef.t 
      | `Fields of
FieldDef.t list ]
        option
      ;
    color:
      [
        `Field of
ConditionalLegendFieldDef.t
           | `Value of
ConditionalLegendValueDef.t
               ]
        option
      }

  (** Fields
  
    y2:
      Y2 coordinates for ranged  `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
  
    y:
      Y coordinates of the marks, or height of vertical `"bar"` and `"area"`.
  
    x2:
      X2 coordinates for ranged  `"area"`, `"bar"`, `"rect"`, and  `"rule"`.
  
    x:
      X coordinates of the marks, or width of horizontal `"bar"` and `"area"`.
  
    tooltip:
      The tooltip text to show upon mouse hover.
  
    text:
      Text of the `text` mark.
  
    size:
      Size of the mark.
      - For `"point"`, `"square"` and `"circle"`,  the symbol size, or pixel area of the mark.
      - For `"bar"` and `"tick"`  the bar and tick's size.
      - For `"text"`  the text's font size.
      - Size is currently unsupported for `"line"`, `"area"`, and `"rect"`.
  
    shape:
      The symbol's shape (only for `point` marks). The supported values are
      `"circle"` (default), `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`,
      or `"triangle-down"`, or else a custom SVG path string.
      __Default value:__ If undefined, the default shape depends on [mark config](config.html#point-config)'s `shape` property.
  
    order:
      Stack order for stacked marks or order of data points in line marks for connected scatter plots.
      
      __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping.
  
    opacity:
      Opacity of the marks  either can be a value or a range.
      
      __Default value:__ If undefined, the default opacity depends on [mark config](config.html#mark)'s `opacity` property.
  
    detail:
      Additional levels of detail for grouping data in aggregate views and
      in line and area marks without mapping data to a specific visual channel.
  
    color:
      Color of the marks  either fill or stroke color based on mark type.
      By default, `color` represents fill color for `"area"`, `"bar"`, `"tick"`,
      `"text"`, `"circle"`, and `"square"` / stroke color for `"line"` and `"point"`.
      
      __Default value:__ If undefined, the default color depends on [mark config](config.html#mark)'s `color` property.
      
      _Note:_ See the scale documentation for more information about customizing [color scheme](scale.html#scheme).
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("color",
            (((function
               | None  ->
                   `Null
               | Some v ->
                   ((function
                     | 
                     `Value v
                     ->
                     ((fun
                     (x :
ConditionalLegendValueDef.t)
                      ->
                     (ConditionalLegendValueDef.to_yojson
                     x : Yojson.Safe.json)))
                     v
                     | 
                     `Field v
                     ->
                     ((fun
                     (x :
ConditionalLegendFieldDef.t)
                      ->
                     (ConditionalLegendFieldDef.to_yojson
                     x : Yojson.Safe.json)))
                     v)) v))
               x.color));
         ("detail",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Fields v
                     ->
                     ((fun
                     (l :
FieldDef.t
                     list)  ->
                     let yojson_of_el
                     (x :
FieldDef.t)
                     =
                     (FieldDef.to_yojson
                     x : 
Yojson.Safe.json)
                      in
                     (`List
                     (List.map
                     yojson_of_el
                     l) : 
Yojson.Safe.json)))
                     v
                    | 
                    `Field v
                     ->
                     ((fun
                     (x :
FieldDef.t)
                      ->
                     (FieldDef.to_yojson
                     x : Yojson.Safe.json)))
                     v)) v))
              x.detail));
         ("opacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Value v
                     ->
                     ((fun
                     (x :
ConditionalLegendValueDef.t)
                      ->
                     (ConditionalLegendValueDef.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Field v
                     ->
                     ((fun
                     (x :
ConditionalLegendFieldDef.t)
                      ->
                     (ConditionalLegendFieldDef.to_yojson
                     x : Yojson.Safe.json)))
                     v)) v))
              x.opacity));
         ("order",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Fields v
                     ->
                     ((fun
                     (l :
OrderFieldDef.t
                     list)  ->
                     let yojson_of_el
                     (x :
OrderFieldDef.t)
                     =
                     (OrderFieldDef.to_yojson
                     x : 
Yojson.Safe.json)
                      in
                     (`List
                     (List.map
                     yojson_of_el
                     l) : 
Yojson.Safe.json)))
                     v
                    | 
                    `Field v
                     ->
                     ((fun
                     (x :
OrderFieldDef.t)
                      ->
                     (OrderFieldDef.to_yojson
                     x : Yojson.Safe.json)))
                     v)) v))
              x.order));
         ("shape",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Value v
                     ->
                     ((fun
                     (x :
ConditionalLegendValueDef.t)
                      ->
                     (ConditionalLegendValueDef.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Field v
                     ->
                     ((fun
                     (x :
ConditionalLegendFieldDef.t)
                      ->
                     (ConditionalLegendFieldDef.to_yojson
                     x : Yojson.Safe.json)))
                     v)) v))
              x.shape));
         ("size",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Value v
                     ->
                     ((fun
                     (x :
ConditionalLegendValueDef.t)
                      ->
                     (ConditionalLegendValueDef.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Field v
                     ->
                     ((fun
                     (x :
ConditionalLegendFieldDef.t)
                      ->
                     (ConditionalLegendFieldDef.to_yojson
                     x : Yojson.Safe.json)))
                     v)) v))
              x.size));
         ("text",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Value v
                     ->
                     ((fun
                     (x :
ConditionalTextValueDef.t)
                      ->
                     (ConditionalTextValueDef.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Field v
                     ->
                     ((fun
                     (x :
ConditionalTextFieldDef.t)
                      ->
                     (ConditionalTextFieldDef.to_yojson
                     x : Yojson.Safe.json)))
                     v)) v))
              x.text));
         ("tooltip",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Value v
                     ->
                     ((fun
                     (x :
ConditionalTextValueDef.t)
                      ->
                     (ConditionalTextValueDef.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Field v
                     ->
                     ((fun
                     (x :
ConditionalTextFieldDef.t)
                      ->
                     (ConditionalTextFieldDef.to_yojson
                     x : Yojson.Safe.json)))
                     v)) v))
              x.tooltip));
         ("x",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Value v
                     ->
                     ((fun
                     (x :
ValueDef.t)
                      ->
                     (ValueDef.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Field v
                     ->
                     ((fun
                     (x :
PositionFieldDef.t)
                      ->
                     (PositionFieldDef.to_yojson
                     x : Yojson.Safe.json)))
                     v)) v))
              x.x));
         ("x2",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Value v
                     ->
                     ((fun
                     (x :
ValueDef.t)
                      ->
                     (ValueDef.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Field v
                     ->
                     ((fun
                     (x :
FieldDef.t)
                      ->
                     (FieldDef.to_yojson
                     x : Yojson.Safe.json)))
                     v)) v))
              x.x2));
         ("y",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Value v
                     ->
                     ((fun
                     (x :
ValueDef.t)
                      ->
                     (ValueDef.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Field v
                     ->
                     ((fun
                     (x :
PositionFieldDef.t)
                      ->
                     (PositionFieldDef.to_yojson
                     x : Yojson.Safe.json)))
                     v)) v))
              x.y));
         ("y2",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Value v
                     ->
                     ((fun
                     (x :
ValueDef.t)
                      ->
                     (ValueDef.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Field v
                     ->
                     ((fun
                     (x :
FieldDef.t)
                      ->
                     (FieldDef.to_yojson
                     x : Yojson.Safe.json)))
                     v)) v))
x.y2))])                                                    
  let make ?color  ?detail 
    ?opacity  ?order  ?shape 
    ?size  ?text  ?tooltip  ?x
     ?x2  ?y  ?y2  () =
    {
      y2;
      y;
      x2;
      x;
      tooltip;
      text;
      size;
      shape;
      order;
      opacity;
      detail;
      color
    } 
  let withColor v x =
    { x with color = (Some v)
    } 
  let withDetail v x =
    { x with detail = (Some v)
    } 
  let withOpacity v x =
    {
      x with
      opacity = (Some v)
    } 
  let withOrder v x =
    { x with order = (Some v)
    } 
  let withShape v x =
    { x with shape = (Some v)
    } 
  let withSize v x =
    { x with size = (Some v) } 
  let withText v x =
    { x with text = (Some v) } 
  let withTooltip v x =
    {
      x with
      tooltip = (Some v)
    } 
  let withX v x =
    { x with x = (Some v) } 
  let withX2 v x =
    { x with x2 = (Some v) } 
  let withY v x =
    { x with y = (Some v) } 
  let withY2 v x =
    { x with y2 = (Some v) } 
end and
Day:sig
  type t =
    [ `Int of int 
    | `Float of float ]
  val to_yojson :
    t ->
Yojson.Safe.json
end =
struct
  type t =
    [ `Int of int 
    | `Float of float ]

  let to_yojson =
    function
    | `Int i -> `Int i
    | `Float f ->
`Float f                                                         
end and
DateTime:sig
  type nonrec t =
  {
  year:
  [
  `Int of
  int 
  | `Float
  of float ]
  option ;
  utc:
  bool
  option ;
  seconds:
  [
  `Int of
  int 
  | `Float
  of float ]
  option ;
  quarter:
  [
  `Int of
  int 
  | `Float
  of float ]
  option ;
  month:
  [
  `Mo of
Month.t 
  | `String
  of string ]
  option ;
  minutes:
  [
  `Int of
  int 
  | `Float
  of float ]
  option ;
  milliseconds:
  [
  `Int of
  int 
  | `Float
  of float ]
  option ;
  hours:
  [
  `Int of
  int 
  | `Float
  of float ]
  option ;
  day:
  [
  `Day of
Day.t 
  | `String
  of string ]
  option ;
  date:
  [
  `Int of
  int 
  | `Float
  of float ]
  option }
  val
  to_yojson
  :
  t ->
Yojson.Safe.json
  val make
  :
  ?date:
  [
  `Int of
  int 
  | `Float
  of float ]
  ->
  ?day:
  [
  `Day of
Day.t 
  | `String
  of string ]
  ->
  ?hours:
  [
  `Int of
  int 
  | `Float
  of float ]
  ->
  ?milliseconds:
  [
  `Int of
  int 
  | `Float
  of float ]
  ->
  ?minutes:
  [
  `Int of
  int 
  | `Float
  of float ]
  ->
  ?month:
  [
  `Mo of
Month.t 
  | `String
  of string ]
  ->
  ?quarter:
  [
  `Int of
  int 
  | `Float
  of float ]
  ->
  ?seconds:
  [
  `Int of
  int 
  | `Float
  of float ]
  ->
  ?utc:bool
  ->
  ?year:
  [
  `Int of
  int 
  | `Float
  of float ]
  ->
  unit -> t
  val
  withDate
  :
  [
  `Int of
  int 
  | `Float
  of float ]
  -> 
  t -> t
  val
  withDay :
  [
  `Day of
Day.t 
  | `String
  of string ]
  -> 
  t -> t
  val
  withHours
  :
  [
  `Int of
  int 
  | `Float
  of float ]
  -> 
  t -> t
  val
  withMilliseconds
  :
  [
  `Int of
  int 
  | `Float
  of float ]
  -> 
  t -> t
  val
  withMinutes
  :
  [
  `Int of
  int 
  | `Float
  of float ]
  -> 
  t -> t
  val
  withMonth
  :
  [
  `Mo of
Month.t 
  | `String
  of string ]
  -> 
  t -> t
  val
  withQuarter
  :
  [
  `Int of
  int 
  | `Float
  of float ]
  -> 
  t -> t
  val
  withSeconds
  :
  [
  `Int of
  int 
  | `Float
  of float ]
  -> 
  t -> t
  val
  withUtc :
  bool ->
  t -> t
  val
  withYear
  :
  [
  `Int of
  int 
  | `Float
  of float ]
  -> 
  t -> t
end =
struct
  type nonrec t =
    {
    year:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    utc: bool option ;
    seconds:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    quarter:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    month:
      [
        `Mo of
Month.t 
      | `String of
          string ]
        option
      ;
    minutes:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    milliseconds:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    hours:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    day:
      [
        `Day of
Day.t 
      | `String of
          string ]
        option
      ;
    date:
      [ `Int of int 
      | `Float of
          float ]
        option
      }

  (** Object for defining datetime in Vega-Lite Filter.
  If both month and quarter are provided, month has higher precedence.
  `day` cannot be combined with other date.
  We accept string for month and day names.
  
  
  Fields:
  
    year:
      Integer value representing the year.
  
    utc:
      A boolean flag indicating if date time is in utc time. If false, the date time is in local time
  
    seconds:
      Integer value representing the second segment (0-59) of a time value
  
    quarter:
      Integer value representing the quarter of the year (from 1-4).
  
    month:
      One of: (1) integer value representing the month from `1`-`12`. `1` represents January;  (2) case-insensitive month name (e.g., `"January"`);  (3) case-insensitive, 3-character short month name (e.g., `"Jan"`). 
  
    minutes:
      Integer value representing the minute segment of time from 0-59.
  
    milliseconds:
      Integer value representing the millisecond segment of time.
  
    hours:
      Integer value representing the hour of a day from 0-23.
  
    day:
      Value representing the day of a week.  This can be one of: (1) integer value -- `1` represents Monday; (2) case-insensitive day name (e.g., `"Monday"`);  (3) case-insensitive, 3-character short day name (e.g., `"Mon"`).   <br/> **Warning:** A DateTime definition object with `day`** should not be combined with `year`, `quarter`, `month`, or `date`.
  
    date:
      Integer value representing the date from 1-31.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun 
           (k,v)  ->
           match v
           with
           | 
           `Null ->
           false
           | 
           _ -> true)
         [("date",
           (((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.date));
         ("day",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `String
           v ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v
           | `Day v
           ->
           ((fun
           (x :
Day.t) 
           ->
           (Day.to_yojson
           x : Yojson.Safe.json)))
           v)) v))
           x.day));
         ("hours",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.hours));
         ("milliseconds",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.milliseconds));
         ("minutes",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.minutes));
         ("month",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `String
           v ->
           ((fun
           (s :
           string) 
           ->
           (`String
           s : Yojson.Safe.json)))
           v
           | `Mo v
           ->
           ((fun
           (x :
Month.t) 
           ->
           (Month.to_yojson
           x : Yojson.Safe.json)))
           v)) v))
           x.month));
         ("quarter",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.quarter));
         ("seconds",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
           x.seconds));
         ("utc",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((fun
           (b :
           bool)  ->
           (`Bool b : 
Yojson.Safe.json)))
           v)) x.utc));
         ("year",
           (
           ((function
           | None 
           -> `Null
           | Some v
           ->
           ((function
           | `Int i
           -> `Int i
           | `Float
           f ->
           `Float f))
           v))
x.year))])                                                              
  let make ?date 
    ?day  ?hours 
    ?milliseconds 
    ?minutes  ?month
     ?quarter 
    ?seconds  ?utc 
    ?year  () =
    {
      year;
      utc;
      seconds;
      quarter;
      month;
      minutes;
      milliseconds;
      hours;
      day;
      date
    } 
  let withDate v x =
    {
      x with
      date =
        (Some v)
    } 
  let withDay v x =
    {
      x with
      day = (Some v)
    } 
  let withHours v x
    =
    {
      x with
      hours =
        (Some v)
    } 
  let withMilliseconds
    v x =
    {
      x with
      milliseconds =
        (Some v)
    } 
  let withMinutes v
    x =
    {
      x with
      minutes =
        (Some v)
    } 
  let withMonth v x
    =
    {
      x with
      month =
        (Some v)
    } 
  let withQuarter v
    x =
    {
      x with
      quarter =
        (Some v)
    } 
  let withSeconds v
    x =
    {
      x with
      seconds =
        (Some v)
    } 
  let withUtc v x =
    {
      x with
      utc = (Some v)
    } 
  let withYear v x =
    {
      x with
      year =
        (Some v)
    } 
end and
DataFormatType:
                                                              sig
  type t =
    [ `Json 
    | `Csv 
    | `Tsv 
    | `Topojson ]
  val to_yojson
    :
    t ->
Yojson.Safe.json
end =
struct
  type t =
    [ `Json 
    | `Csv 
    | `Tsv 
    | `Topojson ]

  let to_yojson
    =
    function
    | `Topojson
      ->
      `String
      "topojson"
    | `Tsv ->
      `String
      "tsv"
    | `Csv ->
      `String
      "csv"
    | `Json ->
      `String
"json"                                                                   
end and
DataFormatBase:
                                                                   sig
 type nonrec t =
 {
 typ:
DataFormatType.t
 option ;
 parse:
 [ `Auto 
 | `Json
 of
Yojson.Safe.json
 ] option }
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
 val make
 :
 ?parse:
 [ `Auto 
 | `Json
 of
Yojson.Safe.json
 ] ->
 ?typ:DataFormatType.t
 ->
 unit -> t
 val
 withParse
 :
 [ `Auto 
 | `Json
 of
Yojson.Safe.json
 ] ->
 t -> t
 val
 withTyp :
DataFormatType.t
 -> 
 t -> t
end =
struct
 type nonrec t =
 {
 typ:
DataFormatType.t
 option ;
 parse:
 [ `Auto 
 | `Json
 of
Yojson.Safe.json
 ] option }

  (** Fields
  
    type:
      Type of input data: `"json"`, `"csv"`, `"tsv"`.
      The default format type is determined by the extension of the file URL.
      If no extension is detected, `"json"` will be used by default.
  
    parse:
      If set to auto (the default), perform automatic type inference to determine the desired data types.
      Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `"number"`, `"boolean"` or `"date"`).
      For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field in each input record a Date value.
      
      For `"date"`, we parse data based using Javascript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).
      For Specific date formats can be provided (e.g., `{foo: 'date:"%m%d%Y"'}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: 'utc:"%m%d%Y"'}`). See more about [UTC time](timeunit.html#utc)
  *)
 let to_yojson
 x =
 `Assoc
 (List.filter
 (fun
 (k,v)  ->
 match v
 with
 | 
 `Null ->
 false
 | 
 _ -> true)
 [
 ("parse",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Json v
 ->
 ((fun
 (j :
Yojson.Safe.json)
  ->
 (j : 
Yojson.Safe.json)))
 v
 | `Auto
 ->
 `String
 "auto"))
 v))
 x.parse));
 ("type",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (x :
DataFormatType.t)
  ->
 (DataFormatType.to_yojson
 x : Yojson.Safe.json)))
v)) x.typ))])                                                                     
 let make
 ?parse 
 ?typ  ()
 =
 {
 typ;
 parse
 } 
 let withParse
 v x =
 {
 x with
 parse =
 (Some v)
 } 
 let withTyp
 v x =
 {
 x with
 typ =
 (Some v)
 } 
end
and
DataFormat:sig
  type t =
    [ `Csv of CsvDataFormat.t  | `Json of JsonDataFormat.t 
    | `Topo of TopoDataFormat.t ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Csv of CsvDataFormat.t  | `Json of JsonDataFormat.t 
    | `Topo of TopoDataFormat.t ]

  let to_yojson =
    function
    | `Topo v ->
        ((fun (x : TopoDataFormat.t)  ->
            (TopoDataFormat.to_yojson x : Yojson.Safe.json))) v
    | `Json v ->
        ((fun (x : JsonDataFormat.t)  ->
            (JsonDataFormat.to_yojson x : Yojson.Safe.json))) v
    | `Csv v ->
        ((fun (x : CsvDataFormat.t)  ->
(CsvDataFormat.to_yojson x : Yojson.Safe.json))) v       
end and
Data:sig
  type t =
    [ `Url of UrlData.t  | `Inline of InlineData.t 
    | `Named of NamedData.t ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Url of UrlData.t  | `Inline of InlineData.t 
    | `Named of NamedData.t ]

  let to_yojson =
    function
    | `Named v ->
        ((fun (x : NamedData.t)  ->
            (NamedData.to_yojson x : Yojson.Safe.json))) v
    | `Inline v ->
        ((fun (x : InlineData.t)  ->
            (InlineData.to_yojson x : Yojson.Safe.json))) v
    | `Url v ->
        ((fun (x : UrlData.t)  ->
(UrlData.to_yojson x : Yojson.Safe.json))) v            
end and
CsvDataFormat:sig
  type nonrec t =
    {
    typ: [ `Csv  | `Tsv ] option ;
    parse:
      [ `Auto  | `Json of Yojson.Safe.json ] option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?parse:[ `Auto  | `Json of Yojson.Safe.json ]
      -> ?typ:[ `Csv  | `Tsv ] -> unit -> t
  val withParse :
    [ `Auto  | `Json of Yojson.Safe.json ] ->
      t -> t
  val withTyp : [ `Csv  | `Tsv ] -> t -> t
end =
struct
  type nonrec t =
    {
    typ: [ `Csv  | `Tsv ] option ;
    parse: [ `Auto  | `Json of Yojson.Safe.json ] option }

  (** Fields
  
    type:
      Type of input data: `"json"`, `"csv"`, `"tsv"`.
      The default format type is determined by the extension of the file URL.
      If no extension is detected, `"json"` will be used by default.
  
    parse:
      If set to auto (the default), perform automatic type inference to determine the desired data types.
      Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `"number"`, `"boolean"` or `"date"`).
      For example, `"parse": {"modified_on": "date"}` parses the `modified_on` field in each input record a Date value.
      
      For `"date"`, we parse data based using Javascript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).
      For Specific date formats can be provided (e.g., `{foo: 'date:"%m%d%Y"'}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: 'utc:"%m%d%Y"'}`). See more about [UTC time](timeunit.html#utc)
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("parse",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function
                     | `Json v ->
                         ((fun (j : Yojson.Safe.json)  ->
                             (j : Yojson.Safe.json))) v
                     | `Auto -> `String "auto")) v)) x.parse));
         ("type",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Tsv -> `String "tsv"
| `Csv -> `String "csv")) v)) x.typ))])                 
  let make ?parse  ?typ  () = { typ; parse } 
  let withParse v x = { x with parse = (Some v) } 
  let withTyp v x = { x with typ = (Some v) } 
end and
Config:sig
  type nonrec t =
    {
    view: ViewConfig.t option ;
    title: VgTitleConfig.t option ;
    timeFormat: string option ;
    tick: TickConfig.t option ;
    text: TextConfig.t option ;
    style: StyleConfigIndex.t option ;
    stack: StackOffset.t option ;
    square: MarkConfig.t option ;
    selection: SelectionConfig.t option ;
    scale: ScaleConfig.t option ;
    rule: MarkConfig.t option ;
    rect: MarkConfig.t option ;
    range: RangeConfig.t option ;
    point: MarkConfig.t option ;
    padding: Padding.t option ;
    numberFormat: string option ;
    mark: MarkConfig.t option ;
    line: MarkConfig.t option ;
    legend: LegendConfig.t option ;
    invalidValues: [ `Filter ] option ;
    countTitle: string option ;
    circle: MarkConfig.t option ;
    bar: BarConfig.t option ;
    background: string option ;
    axisY: VgAxisConfig.t option ;
    axisX: VgAxisConfig.t option ;
    axisTop: VgAxisConfig.t option ;
    axisRight: VgAxisConfig.t option ;
    axisLeft: VgAxisConfig.t option ;
    axisBottom: VgAxisConfig.t option ;
    axisBand: VgAxisConfig.t option ;
    axis: AxisConfig.t option ;
    autoResize: bool option ;
    area: MarkConfig.t option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?area:MarkConfig.t ->
      ?autoResize:bool ->
        ?axis:AxisConfig.t ->
          ?axisBand:VgAxisConfig.t ->
            ?axisBottom:VgAxisConfig.t ->
              ?axisLeft:VgAxisConfig.t ->
                ?axisRight:VgAxisConfig.t ->
                  ?axisTop:VgAxisConfig.t ->
                    ?axisX:VgAxisConfig.t ->
                      ?axisY:VgAxisConfig.t ->
                        ?background:string ->
                          ?bar:BarConfig.t ->
                            ?circle:MarkConfig.t ->
                              ?countTitle:string ->
                                ?invalidValues:
                                  [ `Filter ] ->
                                  ?legend:LegendConfig.t
                                    ->
                                    ?line:MarkConfig.t
                                      ->
                                      ?mark:MarkConfig.t
                                        ->
                                        ?numberFormat:string
                                          ->
                                          ?padding:Padding.t
                                            ->
                                            ?point:MarkConfig.t
                                            ->
                                            ?range:RangeConfig.t
                                            ->
                                            ?rect:MarkConfig.t
                                            ->
                                            ?rule:MarkConfig.t
                                            ->
                                            ?scale:ScaleConfig.t
                                            ->
                                            ?selection:SelectionConfig.t
                                            ->
                                            ?square:MarkConfig.t
                                            ->
                                            ?stack:StackOffset.t
                                            ->
                                            ?style:StyleConfigIndex.t
                                            ->
                                            ?text:TextConfig.t
                                            ->
                                            ?tick:TickConfig.t
                                            ->
                                            ?timeFormat:string
                                            ->
                                            ?title:VgTitleConfig.t
                                            ->
                                            ?view:ViewConfig.t
                                            ->
                                            unit -> t
  val withArea : MarkConfig.t -> t -> t
  val withAutoResize : bool -> t -> t
  val withAxis : AxisConfig.t -> t -> t
  val withAxisBand : VgAxisConfig.t -> t -> t
  val withAxisBottom : VgAxisConfig.t -> t -> t
  val withAxisLeft : VgAxisConfig.t -> t -> t
  val withAxisRight : VgAxisConfig.t -> t -> t
  val withAxisTop : VgAxisConfig.t -> t -> t
  val withAxisX : VgAxisConfig.t -> t -> t
  val withAxisY : VgAxisConfig.t -> t -> t
  val withBackground : string -> t -> t
  val withBar : BarConfig.t -> t -> t
  val withCircle : MarkConfig.t -> t -> t
  val withCountTitle : string -> t -> t
  val withInvalidValues : [ `Filter ] -> t -> t
  val withLegend : LegendConfig.t -> t -> t
  val withLine : MarkConfig.t -> t -> t
  val withMark : MarkConfig.t -> t -> t
  val withNumberFormat : string -> t -> t
  val withPadding : Padding.t -> t -> t
  val withPoint : MarkConfig.t -> t -> t
  val withRange : RangeConfig.t -> t -> t
  val withRect : MarkConfig.t -> t -> t
  val withRule : MarkConfig.t -> t -> t
  val withScale : ScaleConfig.t -> t -> t
  val withSelection : SelectionConfig.t -> t -> t
  val withSquare : MarkConfig.t -> t -> t
  val withStack : StackOffset.t -> t -> t
  val withStyle : StyleConfigIndex.t -> t -> t
  val withText : TextConfig.t -> t -> t
  val withTick : TickConfig.t -> t -> t
  val withTimeFormat : string -> t -> t
  val withTitle : VgTitleConfig.t -> t -> t
  val withView : ViewConfig.t -> t -> t
end =
struct
  type nonrec t =
    {
    view: ViewConfig.t option ;
    title: VgTitleConfig.t option ;
    timeFormat: string option ;
    tick: TickConfig.t option ;
    text: TextConfig.t option ;
    style: StyleConfigIndex.t option ;
    stack: StackOffset.t option ;
    square: MarkConfig.t option ;
    selection: SelectionConfig.t option ;
    scale: ScaleConfig.t option ;
    rule: MarkConfig.t option ;
    rect: MarkConfig.t option ;
    range: RangeConfig.t option ;
    point: MarkConfig.t option ;
    padding: Padding.t option ;
    numberFormat: string option ;
    mark: MarkConfig.t option ;
    line: MarkConfig.t option ;
    legend: LegendConfig.t option ;
    invalidValues: [ `Filter ] option ;
    countTitle: string option ;
    circle: MarkConfig.t option ;
    bar: BarConfig.t option ;
    background: string option ;
    axisY: VgAxisConfig.t option ;
    axisX: VgAxisConfig.t option ;
    axisTop: VgAxisConfig.t option ;
    axisRight: VgAxisConfig.t option ;
    axisLeft: VgAxisConfig.t option ;
    axisBottom: VgAxisConfig.t option ;
    axisBand: VgAxisConfig.t option ;
    axis: AxisConfig.t option ;
    autoResize: bool option ;
    area: MarkConfig.t option }

  (** Fields
  
    view:
      Default properties for [single view plots](spec.html#single). 
  
    title:
      Title configuration, which determines default properties for all [titles](title.html). For a full list of title configuration options, please see the [corresponding section of the title documentation](title.html#config).
  
    timeFormat:
      Default datetime format for axis and legend labels. The format can be set directly on each axis and legend. Use [D3's time format pattern](https://github.com/d3/d3-time-format#locale_format).
      
      __Default value:__ `'%b %d, %Y'`.
  
    tick:
      Tick-Specific Config 
  
    text:
      Text-Specific Config 
  
    style:
      An object hash that defines key-value mappings to determine default properties for marks with a given [style](mark.html#mark-def).  The keys represent styles names; the value are valid [mark configuration objects](mark.html#config).  
  
    stack:
      Default stack offset for stackable mark. 
  
    square:
      Square-Specific Config 
  
    selection:
      An object hash for defining default properties for each type of selections. 
  
    scale:
      Scale configuration determines default properties for all [scales](scale.html). For a full list of scale configuration options, please see the [corresponding section of the scale documentation](scale.html#config).
  
    rule:
      Rule-Specific Config 
  
    rect:
      Rect-Specific Config 
  
    range:
      An object hash that defines default range arrays or schemes for using with scales.
      For a full list of scale range configuration options, please see the [corresponding section of the scale documentation](scale.html#config).
  
    point:
      Point-Specific Config 
  
    padding:
      The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.
      If an object, the value should have the format `{"left": 5, "top": 5, "right": 5, "bottom": 5}` to specify padding for each side of the visualization.
      
      __Default value__: `5`
  
    numberFormat:
      D3 Number format for axis labels and text tables. For example "s" for SI units. Use [D3's number format pattern](https://github.com/d3/d3-format#locale_format).
  
    mark:
      Mark Config 
  
    line:
      Line-Specific Config 
  
    legend:
      Legend configuration, which determines default properties for all [legends](legend.html). For a full list of legend configuration options, please see the [corresponding section of in the legend documentation](legend.html#config).
  
    invalidValues:
      Defines how Vega-Lite should handle invalid values (`null` and `NaN`).
      - If set to `"filter"` (default), all data items with null values are filtered.
      - If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes.
  
    countTitle:
      Default axis and legend title for count fields.
      
      __Default value:__ `'Number of Records'`.
  
    circle:
      Circle-Specific Config 
  
    bar:
      Bar-Specific Config 
  
    background:
      CSS color property to use as the background of visualization.
      
      __Default value:__ none (transparent)
  
    axisY:
      Y-axis specific config.
  
    axisX:
      X-axis specific config.
  
    axisTop:
      Specific axis config for x-axis along the top edge of the chart.
  
    axisRight:
      Specific axis config for y-axis along the right edge of the chart.
  
    axisLeft:
      Specific axis config for y-axis along the left edge of the chart.
  
    axisBottom:
      Specific axis config for x-axis along the bottom edge of the chart.
  
    axisBand:
      Specific axis config for axes with "band" scales.
  
    axis:
      Axis configuration, which determines default properties for all `x` and `y` [axes](axis.html). For a full list of axis configuration options, please see the [corresponding section of the axis documentation](axis.html#axis-config).
  
    autoResize:
      Resize is a boolean indicating if autosize layout should be re-calculated on every update.
      
      __Default value__: `false`
  
    area:
      Area-Specific Config 
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("area",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : MarkConfig.t)  ->
                       (MarkConfig.to_yojson x : Yojson.Safe.json)))
                     v)) x.area));
         ("autoResize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  ->
                      (`Bool b : Yojson.Safe.json))) v))
              x.autoResize));
         ("axis",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : AxisConfig.t)  ->
                      (AxisConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.axis));
         ("axisBand",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : VgAxisConfig.t)  ->
                      (VgAxisConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.axisBand));
         ("axisBottom",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : VgAxisConfig.t)  ->
                      (VgAxisConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.axisBottom));
         ("axisLeft",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : VgAxisConfig.t)  ->
                      (VgAxisConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.axisLeft));
         ("axisRight",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : VgAxisConfig.t)  ->
                      (VgAxisConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.axisRight));
         ("axisTop",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : VgAxisConfig.t)  ->
                      (VgAxisConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.axisTop));
         ("axisX",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : VgAxisConfig.t)  ->
                      (VgAxisConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.axisX));
         ("axisY",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : VgAxisConfig.t)  ->
                      (VgAxisConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.axisY));
         ("background",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.background));
         ("bar",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : BarConfig.t)  ->
                      (BarConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.bar));
         ("circle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : MarkConfig.t)  ->
                      (MarkConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.circle));
         ("countTitle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.countTitle));
         ("invalidValues",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Filter -> `String "filter"))
                    v)) x.invalidValues));
         ("legend",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : LegendConfig.t)  ->
                      (LegendConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.legend));
         ("line",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : MarkConfig.t)  ->
                      (MarkConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.line));
         ("mark",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : MarkConfig.t)  ->
                      (MarkConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.mark));
         ("numberFormat",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.numberFormat));
         ("padding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Padding.t)  ->
                      (Padding.to_yojson x : Yojson.Safe.json)))
                    v)) x.padding));
         ("point",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : MarkConfig.t)  ->
                      (MarkConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.point));
         ("range",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : RangeConfig.t)  ->
                      (RangeConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.range));
         ("rect",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : MarkConfig.t)  ->
                      (MarkConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.rect));
         ("rule",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : MarkConfig.t)  ->
                      (MarkConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.rule));
         ("scale",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : ScaleConfig.t)  ->
                      (ScaleConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.scale));
         ("selection",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : SelectionConfig.t)  ->
                      (SelectionConfig.to_yojson x : 
Yojson.Safe.json))) v)) x.selection));
         ("square",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : MarkConfig.t)  ->
                      (MarkConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.square));
         ("stack",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : StackOffset.t)  ->
                      (StackOffset.to_yojson x : Yojson.Safe.json)))
                    v)) x.stack));
         ("style",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : StyleConfigIndex.t)  ->
                      (StyleConfigIndex.to_yojson x : 
Yojson.Safe.json))) v)) x.style));
         ("text",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : TextConfig.t)  ->
                      (TextConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.text));
         ("tick",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : TickConfig.t)  ->
                      (TickConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.tick));
         ("timeFormat",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.timeFormat));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : VgTitleConfig.t)  ->
                      (VgTitleConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.title));
         ("view",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : ViewConfig.t)  ->
                      (ViewConfig.to_yojson x : Yojson.Safe.json)))
v)) x.view))])                      
  let make ?area  ?autoResize  ?axis  ?axisBand  ?axisBottom
     ?axisLeft  ?axisRight  ?axisTop  ?axisX  ?axisY 
    ?background  ?bar  ?circle  ?countTitle  ?invalidValues 
    ?legend  ?line  ?mark  ?numberFormat  ?padding  ?point 
    ?range  ?rect  ?rule  ?scale  ?selection  ?square 
    ?stack  ?style  ?text  ?tick  ?timeFormat  ?title  ?view
     () =
    {
      view;
      title;
      timeFormat;
      tick;
      text;
      style;
      stack;
      square;
      selection;
      scale;
      rule;
      rect;
      range;
      point;
      padding;
      numberFormat;
      mark;
      line;
      legend;
      invalidValues;
      countTitle;
      circle;
      bar;
      background;
      axisY;
      axisX;
      axisTop;
      axisRight;
      axisLeft;
      axisBottom;
      axisBand;
      axis;
      autoResize;
      area
    } 
  let withArea v x = { x with area = (Some v) } 
  let withAutoResize v x = { x with autoResize = (Some v) } 
  let withAxis v x = { x with axis = (Some v) } 
  let withAxisBand v x = { x with axisBand = (Some v) } 
  let withAxisBottom v x = { x with axisBottom = (Some v) } 
  let withAxisLeft v x = { x with axisLeft = (Some v) } 
  let withAxisRight v x = { x with axisRight = (Some v) } 
  let withAxisTop v x = { x with axisTop = (Some v) } 
  let withAxisX v x = { x with axisX = (Some v) } 
  let withAxisY v x = { x with axisY = (Some v) } 
  let withBackground v x = { x with background = (Some v) } 
  let withBar v x = { x with bar = (Some v) } 
  let withCircle v x = { x with circle = (Some v) } 
  let withCountTitle v x = { x with countTitle = (Some v) } 
  let withInvalidValues v x =
    { x with invalidValues = (Some v) } 
  let withLegend v x = { x with legend = (Some v) } 
  let withLine v x = { x with line = (Some v) } 
  let withMark v x = { x with mark = (Some v) } 
  let withNumberFormat v x =
    { x with numberFormat = (Some v) } 
  let withPadding v x = { x with padding = (Some v) } 
  let withPoint v x = { x with point = (Some v) } 
  let withRange v x = { x with range = (Some v) } 
  let withRect v x = { x with rect = (Some v) } 
  let withRule v x = { x with rule = (Some v) } 
  let withScale v x = { x with scale = (Some v) } 
  let withSelection v x = { x with selection = (Some v) } 
  let withSquare v x = { x with square = (Some v) } 
  let withStack v x = { x with stack = (Some v) } 
  let withStyle v x = { x with style = (Some v) } 
  let withText v x = { x with text = (Some v) } 
  let withTick v x = { x with tick = (Some v) } 
  let withTimeFormat v x = { x with timeFormat = (Some v) } 
  let withTitle v x = { x with title = (Some v) } 
  let withView v x = { x with view = (Some v) } 
end and
ConditionalTextValueDef:sig
  type nonrec t =
    {
    value:
      [ `Bool of bool 
      | `String of string 
      | `Float of float 
      | `Int of int ] option ;
    condition:
      [
        `Field of
ConditionTextFieldDef.t
           | `Value of
ConditionValueDef.t
               ]
        option
      }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?condition:[
                 `Field of
ConditionTextFieldDef.t
                    | `Value of
ConditionValueDef.t
                      ]
      ->
      ?value:[ `Bool of bool 
             | `String of
                 string 
             | `Float of float 
             | `Int of int ]
        -> unit -> t
  val withCondition :
    [
      `Field of
ConditionTextFieldDef.t 
    | `Value of
ConditionValueDef.t ]
      -> t -> t
  val withValue :
    [ `Bool of bool 
    | `String of string 
    | `Float of float 
    | `Int of int ] -> 
      t -> t
end =
struct
  type nonrec t =
    {
    value:
      [ `Bool of bool  | `String of string 
      | `Float of float  | `Int of int ] option ;
    condition:
      [ `Field of ConditionTextFieldDef.t 
      | `Value of ConditionValueDef.t ] option }

  (** A ValueDef with ConditionValueDef | FieldDef
  {
     condition: {field: ...} | {value: ...},
     value: ...,
  }
  
  
  Fields:
  
    value:
      A constant value in visual domain.
  
    condition:
      A field definition or a value definition with a selection predicate.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("condition",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function
                     | `Value v ->
                         ((fun
                             (x : ConditionValueDef.t) 
                             ->
                             (ConditionValueDef.to_yojson
                                x : Yojson.Safe.json)))
                           v
                     | `Field v ->
                         ((fun
                             (x :
ConditionTextFieldDef.t)
                              ->
                             (ConditionTextFieldDef.to_yojson
                                x : Yojson.Safe.json)))
                           v)) v)) x.condition));
         ("value",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int v ->
                        ((fun (i : int)  ->
                            (`Int i : Yojson.Safe.json)))
                          v
                    | `Float v ->
                        ((fun (f : float)  ->
                            (`Float f : Yojson.Safe.json)))
                          v
                    | `String v ->
                        ((fun (s : string)  ->
                            (`String s : Yojson.Safe.json)))
                          v
                    | `Bool v ->
                        ((fun (b : bool)  ->
                            (`Bool b : Yojson.Safe.json)))
v)) v)) x.value))])                           
  let make ?condition  ?value  () =
    { value; condition } 
  let withCondition v x =
    { x with condition = (Some v) } 
  let withValue v x = { x with value = (Some v) } 
end and
ConditionalTextFieldDef:sig
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit:
TimeUnit.t option ;
    format: string option ;
    field: Field.t option ;
    condition:
ConditionValueDef.t
        option
      ;
    bin:
      [ `Bool of bool 
      | `Params of
BinParams.t ]
        option
      ;
    aggregate:
Aggregate.t option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?aggregate:Aggregate.t
      ->
      ?bin:[
             `Bool of bool 
           | `Params of
BinParams.t ]
        ->
        ?condition:ConditionValueDef.t
          ->
          ?field:Field.t
            ->
            ?format:string
              ->
              ?timeUnit:TimeUnit.t
                ->
                typ:Type.t
                 ->
                 unit -> t
  val withAggregate :
Aggregate.t -> t -> t
  val withBin :
    [ `Bool of bool 
    | `Params of
BinParams.t ]
      -> t -> t
  val withCondition :
ConditionValueDef.t ->
      t -> t
  val withField :
Field.t -> t -> t
  val withFormat :
    string -> t -> t
  val withTimeUnit :
TimeUnit.t -> t -> t
  val withTyp :
Type.t -> t -> t
end =
struct
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit: TimeUnit.t option ;
    format: string option ;
    field: Field.t option ;
    condition: ConditionValueDef.t option ;
    bin:
      [ `Bool of bool  | `Params of BinParams.t ]
        option
      ;
    aggregate: Aggregate.t option }

  (** A FieldDef with ConditionValueDef
  {
     condition: {value: ...},
     field: ...,
     ...
  }
  
  
  Fields:
  
    type:
      The encoded field's type of measurement. This can be either a full type
      name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and `"nominal"`).
  
    timeUnit:
      Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).
      
      __Default value:__ `undefined` (None)
  
    format:
      The [formatting pattern](format.html) for a text field. If not defined, this will be determined automatically.
  
    field:
      __Required.__ A string defining the name of the field from which to pull a data value
      or an object defining iterated values from the [`repeat`](repeat.html) operator.
      
      __Note:__ `field` is not required if `aggregate` is `count`.
  
    condition:
      A value definition with a selection predicate.
      
      __Note:__ A field definition's `condition` property can only be a [value definition](encoding.html#value)
      since Vega-Lite only allows at mosty  one encoded field per encoding channel.
  
    bin:
      A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).
      If `true`, default [binning parameters](bin.html) will be applied.
      
      __Default value:__ `false`
  
    aggregate:
      Aggregation function for the field
      (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
      
      __Default value:__ `undefined` (None)
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("aggregate",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : Aggregate.t)  ->
                       (Aggregate.to_yojson x : 
Yojson.Safe.json))) v))
               x.aggregate));
         ("bin",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun (x : BinParams.t) 
                            ->
                            (BinParams.to_yojson x : 
Yojson.Safe.json))) v
                    | `Bool v ->
                        ((fun (b : bool)  ->
                            (`Bool b : Yojson.Safe.json)))
                          v)) v)) x.bin));
         ("condition",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : ConditionValueDef.t) 
                      ->
                      (ConditionValueDef.to_yojson
                         x : Yojson.Safe.json))) v))
              x.condition));
         ("field",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Field.t)  ->
                      (Field.to_yojson x : 
Yojson.Safe.json))) v))
              x.field));
         ("format",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.format));
         ("timeUnit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : TimeUnit.t)  ->
                      (TimeUnit.to_yojson x : 
Yojson.Safe.json))) v))
              x.timeUnit));
         ("type",
           (((fun (x : Type.t)  ->
                (Type.to_yojson x : Yojson.Safe.json)))
x.typ))])                                
  let make ?aggregate  ?bin  ?condition  ?field 
    ?format  ?timeUnit  ~typ  () =
    {
      typ;
      timeUnit;
      format;
      field;
      condition;
      bin;
      aggregate
    } 
  let withAggregate v x =
    { x with aggregate = (Some v) } 
  let withBin v x = { x with bin = (Some v) } 
  let withCondition v x =
    { x with condition = (Some v) } 
  let withField v x = { x with field = (Some v) } 
  let withFormat v x =
    { x with format = (Some v) } 
  let withTimeUnit v x =
    { x with timeUnit = (Some v) } 
  let withTyp v x = { x with typ = v } 
end and
ConditionalLegendValueDef:sig
  type nonrec t =
    {
    value:
      [
        `Bool of
          bool 
      | `String of
          string 
      | `Float of
          float 
      | `Int of int ]
        option
      ;
    condition:
      [
        `Field of
ConditionLegendFieldDef.t
           | 
        `Value of
ConditionValueDef.t
          ]
        option
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?condition:
      [
        `Field of
ConditionLegendFieldDef.t
           | 
        `Value of
ConditionValueDef.t
          ]
      ->
      ?value:
        [
          `Bool of
          bool 
        | `String
          of 
          string 
        | `Float of
          float 
        | `Int of
          int ]
        ->
        unit -> t
  val withCondition
    :
    [
      `Field of
ConditionLegendFieldDef.t
         | 
      `Value of
ConditionValueDef.t
        ]
      -> t -> t
  val withValue :
    [
      `Bool of bool 
    | `String of
        string 
    | `Float of
        float 
    | `Int of int ]
      -> t -> t
end =
struct
  type nonrec t =
    {
    value:
      [ `Bool of bool  | `String of string 
      | `Float of float  | `Int of int ]
        option
      ;
    condition:
      [ `Field of ConditionLegendFieldDef.t 
      | `Value of ConditionValueDef.t ]
        option
      }

  (** A ValueDef with ConditionValueDef | FieldDef
  {
     condition: {field: ...} | {value: ...},
     value: ...,
  }
  
  
  Fields:
  
    value:
      A constant value in visual domain.
  
    condition:
      A field definition or a value definition with a selection predicate.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("condition",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function
                     | `Value v ->
                         ((fun
                             (x :
ConditionValueDef.t)
                              ->
                             (ConditionValueDef.to_yojson
                                x : Yojson.Safe.json)))
                           v
                     | `Field v ->
                         ((fun
                             (x :
ConditionLegendFieldDef.t)
                              ->
                             (ConditionLegendFieldDef.to_yojson
                                x : Yojson.Safe.json)))
                           v)) v))
               x.condition));
         ("value",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int v ->
                        ((fun (i : int)  ->
                            (`Int i : 
Yojson.Safe.json)))
                          v
                    | `Float v ->
                        ((fun (f : float)  ->
                            (`Float f : 
Yojson.Safe.json)))
                          v
                    | `String v ->
                        ((fun (s : string) 
                            ->
                            (`String s : 
Yojson.Safe.json)))
                          v
                    | `Bool v ->
                        ((fun (b : bool)  ->
                            (`Bool b : 
Yojson.Safe.json)))
v)) v)) x.value))])                                     
  let make ?condition  ?value  () =
    { value; condition } 
  let withCondition v x =
    { x with condition = (Some v) } 
  let withValue v x =
    { x with value = (Some v) } 
end and
ConditionalLegendFieldDef:sig
  type nonrec t =
    {
    typ:
Type.t ;
    timeUnit:
TimeUnit.t
     option ;
    sort:
     [
     `Order of
SortOrder.t
      | 
     `Field of
SortField.t
     ] option ;
    scale:
Scale.t
     option ;
    legend:
Legend.t
     option ;
    field:
Field.t
     option ;
    condition:
ConditionValueDef.t
     option ;
    bin:
     [
     `Bool of
     bool 
     | `Params
     of
BinParams.t
     ] option ;
    aggregate:
Aggregate.t
     option }
  val
    to_yojson
    :
    t ->
Yojson.Safe.json
  val make :
    ?aggregate:Aggregate.t
     ->
     ?bin:
     [
     `Bool of
     bool 
     | `Params
     of
BinParams.t
     ] ->
     ?condition:ConditionValueDef.t
     ->
     ?field:Field.t
     ->
     ?legend:Legend.t
     ->
     ?scale:Scale.t
     ->
     ?sort:
     [
     `Order of
SortOrder.t
      | 
     `Field of
SortField.t
     ] ->
     ?timeUnit:TimeUnit.t
     ->
     typ:Type.t
     ->
     unit -> t
  val
    withAggregate
    :
Aggregate.t
     -> 
     t -> t
  val withBin
    :
    [
     `Bool of
     bool 
    | `Params
     of
BinParams.t
     ] ->
     t -> t
  val
    withCondition
    :
ConditionValueDef.t
     -> 
     t -> t
  val
    withField
    :
Field.t ->
     t -> t
  val
    withLegend
    :
Legend.t
     -> 
     t -> t
  val
    withScale
    :
Scale.t ->
     t -> t
  val withSort
    :
    [
     `Order of
SortOrder.t
      | 
     `Field of
SortField.t
     ] ->
     t -> t
  val
    withTimeUnit
    :
TimeUnit.t
     -> 
     t -> t
  val withTyp
    :
Type.t ->
     t -> t
end =
struct
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit: TimeUnit.t option ;
    sort:
      [ `Order of SortOrder.t 
      | `Field of SortField.t ] option ;
    scale: Scale.t option ;
    legend: Legend.t option ;
    field: Field.t option ;
    condition:
ConditionValueDef.t option ;
    bin:
      [ `Bool of bool 
      | `Params of BinParams.t ] option ;
    aggregate: Aggregate.t option }

  (** A FieldDef with ConditionValueDef
  {
     condition: {value: ...},
     field: ...,
     ...
  }
  
  
  Fields:
  
    type:
      The encoded field's type of measurement. This can be either a full type
      name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and `"nominal"`).
  
    timeUnit:
      Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).
      
      __Default value:__ `undefined` (None)
  
    sort:
      Sort order for the encoded field.
      Supported `sort` values include `"ascending"`, `"descending"` and `null` (no sorting).
      For fields with discrete domains, `sort` can also be a [sort field definition object](sort.html#sort-field).
      
      __Default value:__ `"ascending"`
  
    scale:
      An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
      
      __Default value:__ If undefined, default [scale properties](scale.html) are applied.
  
    legend:
      An object defining properties of the legend.
      If `null`, the legend for the encoding channel will be removed.
      
      __Default value:__ If undefined, default [legend properties](legend.html) are applied.
  
    field:
      __Required.__ A string defining the name of the field from which to pull a data value
      or an object defining iterated values from the [`repeat`](repeat.html) operator.
      
      __Note:__ `field` is not required if `aggregate` is `count`.
  
    condition:
      A value definition with a selection predicate.
      
      __Note:__ A field definition's `condition` property can only be a [value definition](encoding.html#value)
      since Vega-Lite only allows at mosty  one encoded field per encoding channel.
  
    bin:
      A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).
      If `true`, default [binning parameters](bin.html) will be applied.
      
      __Default value:__ `false`
  
    aggregate:
      Aggregation function for the field
      (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
      
      __Default value:__ `undefined` (None)
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("aggregate",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun
                       (x : Aggregate.t)
                        ->
                       (Aggregate.to_yojson
                          x : Yojson.Safe.json)))
                     v)) x.aggregate));
         ("bin",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun
                            (x :
BinParams.t)
                             ->
                            (BinParams.to_yojson
                               x : 
Yojson.Safe.json)))
                          v
                    | `Bool v ->
                        ((fun (b : bool)
                             ->
                            (`Bool b : 
Yojson.Safe.json)))
                          v)) v)) x.bin));
         ("condition",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
ConditionValueDef.t)
                       ->
                      (ConditionValueDef.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.condition));
         ("field",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Field.t) 
                      ->
                      (Field.to_yojson x : 
Yojson.Safe.json)))
                    v)) x.field));
         ("legend",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Legend.t) 
                      ->
                      (Legend.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.legend));
         ("scale",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Scale.t) 
                      ->
                      (Scale.to_yojson x : 
Yojson.Safe.json)))
                    v)) x.scale));
         ("sort",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Field v ->
                        ((fun
                            (x :
SortField.t)
                             ->
                            (SortField.to_yojson
                               x : 
Yojson.Safe.json)))
                          v
                    | `Order v ->
                        ((fun
                            (x :
SortOrder.t)
                             ->
                            (SortOrder.to_yojson
                               x : 
Yojson.Safe.json)))
                          v)) v)) x.sort));
         ("timeUnit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : TimeUnit.t)
                       ->
                      (TimeUnit.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.timeUnit));
         ("type",
           (((fun (x : Type.t)  ->
                (Type.to_yojson x : 
Yojson.Safe.json)))
x.typ))])                                          
  let make ?aggregate  ?bin  ?condition 
    ?field  ?legend  ?scale  ?sort 
    ?timeUnit  ~typ  () =
    {
      typ;
      timeUnit;
      sort;
      scale;
      legend;
      field;
      condition;
      bin;
      aggregate
    } 
  let withAggregate v x =
    { x with aggregate = (Some v) } 
  let withBin v x =
    { x with bin = (Some v) } 
  let withCondition v x =
    { x with condition = (Some v) } 
  let withField v x =
    { x with field = (Some v) } 
  let withLegend v x =
    { x with legend = (Some v) } 
  let withScale v x =
    { x with scale = (Some v) } 
  let withSort v x =
    { x with sort = (Some v) } 
  let withTimeUnit v x =
    { x with timeUnit = (Some v) } 
  let withTyp v x = { x with typ = v } 
end and
ConditionValueDef:sig
  type nonrec t =
    {
    value:
      [
        `Bool of
        bool 
      | `String
        of 
        string 
      | `Float of
        float 
      | `Int of
        int ]
      ;
    selection:
SelectionOperand.t
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    selection:SelectionOperand.t
      ->
      value:
        [
        `Bool of
        bool 
        | `String
        of string 
        | `Float
        of float 
        | `Int of
        int ] ->
        unit -> t
  val
    withSelection
    :
SelectionOperand.t
      -> 
      t -> t
  val withValue :
    [
      `Bool of
        bool 
    | `String of
        string 
    | `Float of
        float 
    | `Int of int ]
      -> 
      t -> t
end =
struct
  type nonrec t =
    {
    value:
      [ `Bool of bool 
      | `String of string 
      | `Float of float 
      | `Int of int ] ;
    selection: SelectionOperand.t }

  (** Fields
  
    value:
      A constant value in visual domain.
  
    selection:
      A [selection name](selection.html), or a series of [composed selections](selection.html#compose).
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("selection",
            (((fun
                 (x :
SelectionOperand.t)
                  ->
                 (SelectionOperand.to_yojson
                    x : Yojson.Safe.json)))
               x.selection));
         ("value",
           (((function
              | `Int v ->
                  ((fun (i : int) 
                      ->
                      (`Int i : 
Yojson.Safe.json)))
                    v
              | `Float v ->
                  ((fun (f : float)
                       ->
                      (`Float f : 
Yojson.Safe.json)))
                    v
              | `String v ->
                  ((fun
                      (s : string) 
                      ->
                      (`String s : 
Yojson.Safe.json)))
                    v
              | `Bool v ->
                  ((fun (b : bool) 
                      ->
                      (`Bool b : 
Yojson.Safe.json)))
v)) x.value))])                                               
  let make ~selection  ~value  () =
    { value; selection } 
  let withSelection v x =
    { x with selection = v } 
  let withValue v x =
    { x with value = v } 
end and
ConditionTextFieldDef:
                                               sig
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit:
TimeUnit.t option ;
    selection:
SelectionOperand.t ;
    format: string option ;
    field: Field.t option ;
    bin:
      [ `Bool of bool 
      | `Params of BinParams.t ]
        option
      ;
    aggregate:
Aggregate.t option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?aggregate:Aggregate.t ->
      ?bin:[ `Bool of bool 
           | `Params of
BinParams.t ]
        ->
        ?field:Field.t ->
          ?format:string ->
            ?timeUnit:TimeUnit.t
              ->
              selection:SelectionOperand.t
                ->
                typ:Type.t ->
                  unit -> t
  val withAggregate :
Aggregate.t -> t -> t
  val withBin :
    [ `Bool of bool 
    | `Params of BinParams.t ]
      -> t -> t
  val withField :
Field.t -> t -> t
  val withFormat :
    string -> t -> t
  val withSelection :
SelectionOperand.t ->
      t -> t
  val withTimeUnit :
TimeUnit.t -> t -> t
  val withTyp :
Type.t -> t -> t
end =
struct
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit:
TimeUnit.t option ;
    selection:
SelectionOperand.t ;
    format: string option ;
    field: Field.t option ;
    bin:
      [ `Bool of bool 
      | `Params of BinParams.t ]
        option
      ;
    aggregate:
Aggregate.t option }

  (** Fields
  
    type:
      The encoded field's type of measurement. This can be either a full type
      name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and `"nominal"`).
  
    timeUnit:
      Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).
      
      __Default value:__ `undefined` (None)
  
    selection:
      A [selection name](selection.html), or a series of [composed selections](selection.html#compose).
  
    format:
      The [formatting pattern](format.html) for a text field. If not defined, this will be determined automatically.
  
    field:
      __Required.__ A string defining the name of the field from which to pull a data value
      or an object defining iterated values from the [`repeat`](repeat.html) operator.
      
      __Note:__ `field` is not required if `aggregate` is `count`.
  
    bin:
      A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).
      If `true`, default [binning parameters](bin.html) will be applied.
      
      __Default value:__ `false`
  
    aggregate:
      Aggregation function for the field
      (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
      
      __Default value:__ `undefined` (None)
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("aggregate",
            (((function
               | None  ->
                   `Null
               | Some v ->
                   ((fun
                     (x :
Aggregate.t)
                      ->
                     (Aggregate.to_yojson
                     x : 
Yojson.Safe.json)))
                     v))
               x.aggregate));
         ("bin",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Params v
                     ->
                     ((fun
                     (x :
BinParams.t)
                      ->
                     (BinParams.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `Bool v ->
                     ((fun
                     (b :
                     bool)  ->
                     (`Bool b : 
Yojson.Safe.json)))
                     v)) v))
              x.bin));
         ("field",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (x :
Field.t) 
                     ->
                     (Field.to_yojson
                     x : 
Yojson.Safe.json)))
                    v))
              x.field));
         ("format",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (s :
                     string) 
                     ->
                     (`String
                     s : 
Yojson.Safe.json)))
                    v))
              x.format));
         ("selection",
           (((fun
                (x :
SelectionOperand.t)
                 ->
                (SelectionOperand.to_yojson
                   x : 
Yojson.Safe.json)))
              x.selection));
         ("timeUnit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (x :
TimeUnit.t)
                      ->
                     (TimeUnit.to_yojson
                     x : 
Yojson.Safe.json)))
                    v))
              x.timeUnit));
         ("type",
           (((fun (x : Type.t)
                 ->
                (Type.to_yojson
                   x : 
Yojson.Safe.json)))
x.typ))])                                                    
  let make ?aggregate  ?bin 
    ?field  ?format  ?timeUnit
     ~selection  ~typ  () =
    {
      typ;
      selection;
      timeUnit;
      format;
      field;
      bin;
      aggregate
    } 
  let withAggregate v x =
    {
      x with
      aggregate = (Some v)
    } 
  let withBin v x =
    { x with bin = (Some v) } 
  let withField v x =
    { x with field = (Some v)
    } 
  let withFormat v x =
    { x with format = (Some v)
    } 
  let withSelection v x =
    { x with selection = v } 
  let withTimeUnit v x =
    {
      x with
      timeUnit = (Some v)
    } 
  let withTyp v x =
    { x with typ = v } 
end and
ConditionLegendFieldDef:
                                                    sig
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit:
TimeUnit.t option ;
    sort:
      [
        `Order of
SortOrder.t 
      | `Field of
SortField.t ]
        option
      ;
    selection:
SelectionOperand.t ;
    scale: Scale.t option ;
    legend:
Legend.t option ;
    field: Field.t option ;
    bin:
      [ `Bool of bool 
      | `Params of
BinParams.t ]
        option
      ;
    aggregate:
Aggregate.t option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?aggregate:Aggregate.t
      ->
      ?bin:[
             `Bool of
               bool 
           | `Params of
BinParams.t
               ]
        ->
        ?field:Field.t ->
          ?legend:Legend.t
            ->
            ?scale:Scale.t
              ->
              ?sort:
                [
                `Order of
SortOrder.t
                 | 
                `Field of
SortField.t
                ] ->
                ?timeUnit:TimeUnit.t
                ->
                selection:SelectionOperand.t
                ->
                typ:Type.t
                ->
                unit -> t
  val withAggregate :
Aggregate.t -> t -> t
  val withBin :
    [ `Bool of bool 
    | `Params of
BinParams.t ]
      -> t -> t
  val withField :
Field.t -> t -> t
  val withLegend :
Legend.t -> t -> t
  val withScale :
Scale.t -> t -> t
  val withSelection :
SelectionOperand.t ->
      t -> t
  val withSort :
    [
      `Order of
SortOrder.t 
    | `Field of
SortField.t ]
      -> t -> t
  val withTimeUnit :
TimeUnit.t -> t -> t
  val withTyp :
Type.t -> t -> t
end =
struct
  type nonrec t =
    {
    typ: Type.t ;
    timeUnit:
TimeUnit.t option ;
    sort:
      [
        `Order of
SortOrder.t 
      | `Field of
SortField.t ]
        option
      ;
    selection:
SelectionOperand.t ;
    scale: Scale.t option ;
    legend:
Legend.t option ;
    field: Field.t option ;
    bin:
      [ `Bool of bool 
      | `Params of
BinParams.t ]
        option
      ;
    aggregate:
Aggregate.t option }

  (** Fields
  
    type:
      The encoded field's type of measurement. This can be either a full type
      name (`"quantitative"`, `"temporal"`, `"ordinal"`,  and `"nominal"`).
  
    timeUnit:
      Time unit for a `temporal` field  (e.g., `year`, `yearmonth`, `month`, `hour`).
      
      __Default value:__ `undefined` (None)
  
    sort:
      Sort order for the encoded field.
      Supported `sort` values include `"ascending"`, `"descending"` and `null` (no sorting).
      For fields with discrete domains, `sort` can also be a [sort field definition object](sort.html#sort-field).
      
      __Default value:__ `"ascending"`
  
    selection:
      A [selection name](selection.html), or a series of [composed selections](selection.html#compose).
  
    scale:
      An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.
      
      __Default value:__ If undefined, default [scale properties](scale.html) are applied.
  
    legend:
      An object defining properties of the legend.
      If `null`, the legend for the encoding channel will be removed.
      
      __Default value:__ If undefined, default [legend properties](legend.html) are applied.
  
    field:
      __Required.__ A string defining the name of the field from which to pull a data value
      or an object defining iterated values from the [`repeat`](repeat.html) operator.
      
      __Note:__ `field` is not required if `aggregate` is `count`.
  
    bin:
      A flag for binning a `quantitative` field, or [an object defining binning parameters](bin.html#params).
      If `true`, default [binning parameters](bin.html) will be applied.
      
      __Default value:__ `false`
  
    aggregate:
      Aggregation function for the field
      (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).
      
      __Default value:__ `undefined` (None)
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null ->
                false
            | _ -> true)
         [("aggregate",
            (((function
               | 
None  ->
                `Null
               | 
Some v ->
                ((fun
                (x :
Aggregate.t)
                 ->
                (Aggregate.to_yojson
                x : Yojson.Safe.json)))
                v))
               x.aggregate));
         ("bin",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((function
                | `Params
                v ->
                ((fun
                (x :
BinParams.t)
                 ->
                (BinParams.to_yojson
                x : Yojson.Safe.json)))
                v
                | `Bool v
                ->
                ((fun
                (b :
                bool)  ->
                (`Bool b : 
Yojson.Safe.json)))
                v)) v))
              x.bin));
         ("field",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
Field.t) 
                ->
                (Field.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.field));
         ("legend",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
Legend.t)
                 ->
                (Legend.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.legend));
         ("scale",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
Scale.t) 
                ->
                (Scale.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.scale));
         ("selection",
           (((fun
                (x :
SelectionOperand.t)
                 ->
                (
SelectionOperand.to_yojson
                x : 
Yojson.Safe.json)))
              x.selection));
         ("sort",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((function
                | `Field
                v ->
                ((fun
                (x :
SortField.t)
                 ->
                (SortField.to_yojson
                x : Yojson.Safe.json)))
                v
                | `Order
                v ->
                ((fun
                (x :
SortOrder.t)
                 ->
                (SortOrder.to_yojson
                x : Yojson.Safe.json)))
                v)) v))
              x.sort));
         ("timeUnit",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
TimeUnit.t)
                 ->
                (TimeUnit.to_yojson
                x : Yojson.Safe.json)))
                v))
              x.timeUnit));
         ("type",
           (((fun
                (x :
Type.t) 
                ->
                (
Type.to_yojson
                x : 
Yojson.Safe.json)))
x.typ))])                                                         
  let make ?aggregate 
    ?bin  ?field  ?legend
     ?scale  ?sort 
    ?timeUnit  ~selection
     ~typ  () =
    {
      typ;
      selection;
      timeUnit;
      sort;
      scale;
      legend;
      field;
      bin;
      aggregate
    } 
  let withAggregate v x =
    {
      x with
      aggregate =
        (Some v)
    } 
  let withBin v x =
    {
      x with
      bin = (Some v)
    } 
  let withField v x =
    {
      x with
      field = (Some v)
    } 
  let withLegend v x =
    {
      x with
      legend = (Some v)
    } 
  let withScale v x =
    {
      x with
      scale = (Some v)
    } 
  let withSelection v x =
    {
      x with
      selection = v
    } 
  let withSort v x =
    {
      x with
      sort = (Some v)
    } 
  let withTimeUnit v x =
    {
      x with
      timeUnit = (Some v)
    } 
  let withTyp v x =
    { x with typ = v } 
end and
CompositeUnitSpec_Selection:
                                                         sig
  type nonrec t =
    (string *
SelectionDef.t)
      list
  val to_yojson :
    t ->
Yojson.Safe.json
end =
struct
  type nonrec t =
    (string *
SelectionDef.t)
      list

  let to_yojson x =
    let mapper 
      (k,v) =
      (k,
        ((fun
           (x :
SelectionDef.t)
            ->
           (SelectionDef.to_yojson
           x : 
Yojson.Safe.json))
           v))
       in
    `Assoc
      (List.map
mapper x)                                                              
end and
CompositeUnitSpec:
                                                              sig
  type nonrec t =
    {
    width:
      [
      `Int of
      int 
      | `Float
      of float ]
      option ;
    transform:
Transform.t
      list
      option ;
    title:
      [
      `String
      of 
      string 
      | `Params
      of
TitleParams.t
      ] option ;
    selection:
CompositeUnitSpec_Selection.t
      option ;
    name:
      string
      option ;
    mark:
AnyMark.t ;
    height:
      [
      `Int of
      int 
      | `Float
      of float ]
      option ;
    encoding:
Encoding.t
      ;
    description:
      string
      option ;
    data:
Data.t
      option }
  val to_yojson
    :
    t ->
Yojson.Safe.json
  val make :
    ?data:Data.t
      ->
      ?description:string
      ->
      ?height:
      [
      `Int of
      int 
      | `Float
      of float ]
      ->
      ?name:string
      ->
      ?selection:CompositeUnitSpec_Selection.t
      ->
      ?title:
      [
      `String
      of 
      string 
      | `Params
      of
TitleParams.t
      ] ->
      ?transform:Transform.t
      list ->
      ?width:
      [
      `Int of
      int 
      | `Float
      of float ]
      ->
      encoding:Encoding.t
      ->
      mark:AnyMark.t
      ->
      unit -> t
  val withData
    :
Data.t ->
      t -> t
  val
    withDescription
    :
    string ->
      t -> t
  val
    withEncoding
    :
Encoding.t
      -> 
      t -> t
  val
    withHeight
    :
    [
      `Int of
      int 
    | `Float of
      float ]
      -> 
      t -> t
  val withMark
    :
AnyMark.t
      -> 
      t -> t
  val withName
    :
    string ->
      t -> t
  val
    withSelection
    :
CompositeUnitSpec_Selection.t
      -> 
      t -> t
  val withTitle
    :
    [
      `String
      of 
      string 
    | `Params
      of
TitleParams.t
      ] ->
      t -> t
  val
    withTransform
    :
Transform.t
      list ->
      t -> t
  val withWidth
    :
    [
      `Int of
      int 
    | `Float of
      float ]
      -> 
      t -> t
end =
struct
  type nonrec t =
    {
    width:
      [
      `Int of
      int 
      | `Float
      of float ]
      option ;
    transform:
Transform.t
      list
      option ;
    title:
      [
      `String
      of 
      string 
      | `Params
      of
TitleParams.t
      ] option ;
    selection:
CompositeUnitSpec_Selection.t
      option ;
    name:
      string
      option ;
    mark:
AnyMark.t ;
    height:
      [
      `Int of
      int 
      | `Float
      of float ]
      option ;
    encoding:
Encoding.t
      ;
    description:
      string
      option ;
    data:
Data.t
      option }

  (** Fields
  
    width:
      The width of a visualization.
      
      __Default value:__ This will be determined by the following rules:
      
      - For x-axis with a continuous (non-ordinal) scale, the width will be the value of [`config.view.width`](spec.html#config).
      - For x-axis with an ordinal scale: if [`rangeStep`](scale.html#ordinal) is a numeric value (default), the width is determined by the value of `rangeStep` and the cardinality of the field mapped to x-channel.   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](spec.html#config).
      - If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.
      
      __Note:__ For plot with `row` and `column` channels, this represents the width of a single view.
      
      __See also:__ The documentation for [width and height](size.html) contains more examples.
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    selection:
      A key-value mapping between selection names and definitions.
  
    name:
      Name of the visualization for later reference.
  
    mark:
      A string describing the mark type (one of `"bar"`, `"circle"`, `"square"`, `"tick"`, `"line"`,
      `"area"`, `"point"`, `"rule"`, and `"text"`) or a [mark definition object](mark.html#mark-def).
  
    height:
      The height of a visualization.
      
      __Default value:__
      - For y-axis with a continuous (non-ordinal) scale, the height will be the value of [`config.view.height`](spec.html#config).
      - For y-axis with an ordinal scale: if [`rangeStep`](scale.html#ordinal) is a numeric value (default), the height is determined by the value of `rangeStep` and the cardinality of the field mapped to y-channel.   Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](spec.html#config).
      - If no field is mapped to `x` channel, the `height` will be the value of `rangeStep`.
      
      __Note__: For plot with `row` and `column` channels, this represents the height of a single view.
      
      __See also:__ The documentation for [width and height](size.html) contains more examples.
  
    encoding:
      A key-value mapping between encoding channels and definition of fields.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  *)
  let to_yojson
    x =
    `Assoc
      (
List.filter
      (fun
      (k,v)  ->
      match v
      with
      | 
      `Null ->
      false
      | 
      _ -> true)
      [
      ("data",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
Data.t) 
      ->
      (Data.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.data));
      ("description",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (s :
      string) 
      ->
      (`String
      s : Yojson.Safe.json)))
      v))
      x.description));
      ("encoding",
      (((fun
      (x :
Encoding.t)
       ->
      (Encoding.to_yojson
      x : Yojson.Safe.json)))
      x.encoding));
      ("height",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((function
      | `Int i
      -> `Int i
      | `Float
      f ->
      `Float f))
      v))
      x.height));
      ("mark",
      (((fun
      (x :
AnyMark.t)
       ->
      (AnyMark.to_yojson
      x : Yojson.Safe.json)))
      x.mark));
      ("name",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (s :
      string) 
      ->
      (`String
      s : Yojson.Safe.json)))
      v))
      x.name));
      ("selection",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
CompositeUnitSpec_Selection.t)
       ->
      (CompositeUnitSpec_Selection.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.selection));
      ("title",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((function
      | `Params
      v ->
      ((fun
      (x :
TitleParams.t)
       ->
      (TitleParams.to_yojson
      x : Yojson.Safe.json)))
      v
      | `String
      v ->
      ((fun
      (s :
      string) 
      ->
      (`String
      s : Yojson.Safe.json)))
      v)) v))
      x.title));
      ("transform",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (l :
Transform.t
      list)  ->
      let yojson_of_el
      (x :
Transform.t)
      =
      (Transform.to_yojson
      x : 
Yojson.Safe.json)
       in
      (`List
      (List.map
      yojson_of_el
      l) : 
Yojson.Safe.json)))
      v))
      x.transform));
      ("width",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((function
      | `Int i
      -> `Int i
      | `Float
      f ->
      `Float f))
      v))
x.width))])                                                                   
  let make
    ?data 
    ?description
     ?height 
    ?name 
    ?selection 
    ?title 
    ?transform 
    ?width 
    ~encoding 
    ~mark  () =
    {
      mark;
      encoding;
      width;
      transform;
      title;
      selection;
      name;
      height;
      description;
      data
    } 
  let withData
    v x =
    {
      x with
      data =
      (Some v)
    } 
  let withDescription
    v x =
    {
      x with
      description
      =
      (Some v)
    } 
  let withEncoding
    v x =
    {
      x with
      encoding
      = v
    } 
  let withHeight
    v x =
    {
      x with
      height =
      (Some v)
    } 
  let withMark
    v x =
    {
      x with
      mark = v
    } 
  let withName
    v x =
    {
      x with
      name =
      (Some v)
    } 
  let withSelection
    v x =
    {
      x with
      selection
      =
      (Some v)
    } 
  let withTitle
    v x =
    {
      x with
      title =
      (Some v)
    } 
  let withTransform
    v x =
    {
      x with
      transform
      =
      (Some v)
    } 
  let withWidth
    v x =
    {
      x with
      width =
      (Some v)
    } 
end and
CompositeMarkConfigMixins:
                                                                   sig
 type t =
BoxPlotConfigMixins.t
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
end =
struct
 type t =
BoxPlotConfigMixins.t

 let to_yojson
 (x :
BoxPlotConfigMixins.t)
 =
 (BoxPlotConfigMixins.to_yojson
 x : 
Yojson.Safe.json)                                                                     
end
and
CalculateTransform:sig
  type nonrec t = {
    calculate: string ;
    nameAs: string }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    nameAs:string -> calculate:string -> unit -> t
  val withNameAs : string -> t -> t
  val withCalculate : string -> t -> t
end =
struct
  type nonrec t = {
    calculate: string ;
    nameAs: string }

  (** Fields
  
    calculate:
      A string containing a Vega Expression. Use the variable `datum` to refer to the current data object.
  
    as:
      The field for storing the computed formula value.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("as",
            (((fun (s : string)  -> (`String s : Yojson.Safe.json)))
               x.nameAs));
         ("calculate",
           (((fun (s : string)  -> (`String s : Yojson.Safe.json)))
x.calculate))])       
  let make ~nameAs  ~calculate  () = { calculate; nameAs } 
  let withNameAs v x = { x with nameAs = v } 
  let withCalculate v x = { x with calculate = v } 
end and
BrushConfig:sig
  type nonrec t =
    {
    strokeWidth: [ `Int of int  | `Float of float ] option ;
    strokeOpacity:
      [ `Int of int  | `Float of float ] option ;
    strokeDashOffset:
      [ `Int of int  | `Float of float ] option ;
    strokeDash:
      [ `Int of int  | `Float of float ] list option ;
    stroke: string option ;
    fillOpacity: [ `Int of int  | `Float of float ] option ;
    fill: string option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?fill:string ->
      ?fillOpacity:[ `Int of int  | `Float of float ] ->
        ?stroke:string ->
          ?strokeDash:[ `Int of int  | `Float of float ]
            list ->
            ?strokeDashOffset:[ `Int of int 
                              | `Float of float ]
              ->
              ?strokeOpacity:[ `Int of int 
                             | `Float of float ]
                ->
                ?strokeWidth:[ `Int of int 
                             | `Float of float ]
                  -> unit -> t
  val withFill : string -> t -> t
  val withFillOpacity :
    [ `Int of int  | `Float of float ] -> t -> t
  val withStroke : string -> t -> t
  val withStrokeDash :
    [ `Int of int  | `Float of float ] list -> t -> t
  val withStrokeDashOffset :
    [ `Int of int  | `Float of float ] -> t -> t
  val withStrokeOpacity :
    [ `Int of int  | `Float of float ] -> t -> t
  val withStrokeWidth :
    [ `Int of int  | `Float of float ] -> t -> t
end =
struct
  type nonrec t =
    {
    strokeWidth: [ `Int of int  | `Float of float ] option ;
    strokeOpacity: [ `Int of int  | `Float of float ] option ;
    strokeDashOffset: [ `Int of int  | `Float of float ] option ;
    strokeDash: [ `Int of int  | `Float of float ] list option ;
    stroke: string option ;
    fillOpacity: [ `Int of int  | `Float of float ] option ;
    fill: string option }

  (** Fields
  
    strokeWidth:
      The stroke width of the interval mark.
  
    strokeOpacity:
      The stroke opacity of the interval mark (a value between 0 and 1).
  
    strokeDashOffset:
      The offset (in pixels) with which to begin drawing the stroke dash array.
  
    strokeDash:
      An array of alternating stroke and space lengths,
      for creating dashed or dotted lines.
  
    stroke:
      The stroke color of the interval mark.
      
      __Default value:__ `#ffffff`
  
    fillOpacity:
      The fill opacity of the interval mark (a value between 0 and 1).
      
      __Default value:__ `0.125`
  
    fill:
      The fill color of the interval mark.
      
      __Default value:__ `#333333`
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("fill",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (s : string)  ->
                       (`String s : Yojson.Safe.json))) v)) x.fill));
         ("fillOpacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f))
                    v)) x.fillOpacity));
         ("stroke",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v)) x.stroke));
         ("strokeDash",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (l : [ `Int of int  | `Float of float ] list) 
                      ->
                      let yojson_of_el =
                        function
                        | `Int i -> `Int i
                        | `Float f -> `Float f  in
                      (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
                    v)) x.strokeDash));
         ("strokeDashOffset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f))
                    v)) x.strokeDashOffset));
         ("strokeOpacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f))
                    v)) x.strokeOpacity));
         ("strokeWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f))
v)) x.strokeWidth))])            
  let make ?fill  ?fillOpacity  ?stroke  ?strokeDash 
    ?strokeDashOffset  ?strokeOpacity  ?strokeWidth  () =
    {
      strokeWidth;
      strokeOpacity;
      strokeDashOffset;
      strokeDash;
      stroke;
      fillOpacity;
      fill
    } 
  let withFill v x = { x with fill = (Some v) } 
  let withFillOpacity v x = { x with fillOpacity = (Some v) } 
  let withStroke v x = { x with stroke = (Some v) } 
  let withStrokeDash v x = { x with strokeDash = (Some v) } 
  let withStrokeDashOffset v x =
    { x with strokeDashOffset = (Some v) } 
  let withStrokeOpacity v x = { x with strokeOpacity = (Some v) } 
  let withStrokeWidth v x = { x with strokeWidth = (Some v) } 
end and
BoxPlotConfigMixins:sig
  type nonrec t =
    {
    boxWhisker: MarkConfig.t option ;
    boxMid: MarkConfig.t option ;
    box: BoxPlotConfig.t option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?box:BoxPlotConfig.t ->
      ?boxMid:MarkConfig.t ->
        ?boxWhisker:MarkConfig.t -> unit -> t
  val withBox : BoxPlotConfig.t -> t -> t
  val withBoxMid : MarkConfig.t -> t -> t
  val withBoxWhisker : MarkConfig.t -> t -> t
end =
struct
  type nonrec t =
    {
    boxWhisker: MarkConfig.t option ;
    boxMid: MarkConfig.t option ;
    box: BoxPlotConfig.t option }

  (** Fields
  
    box:
      Box Config 
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("box",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : BoxPlotConfig.t)  ->
                       (BoxPlotConfig.to_yojson x : Yojson.Safe.json)))
                     v)) x.box));
         ("boxMid",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : MarkConfig.t)  ->
                      (MarkConfig.to_yojson x : Yojson.Safe.json)))
                    v)) x.boxMid));
         ("boxWhisker",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : MarkConfig.t)  ->
                      (MarkConfig.to_yojson x : Yojson.Safe.json)))
v)) x.boxWhisker))])                 
  let make ?box  ?boxMid  ?boxWhisker  () =
    { boxWhisker; boxMid; box } 
  let withBox v x = { x with box = (Some v) } 
  let withBoxMid v x = { x with boxMid = (Some v) } 
  let withBoxWhisker v x = { x with boxWhisker = (Some v) } 
end and
BoxPlotConfig:sig
  type nonrec t =
    {
    theta:
      [ `Int of int  | `Float of float ]
        option
      ;
    text: string option ;
    tension:
      [ `Int of int  | `Float of float ]
        option
      ;
    strokeWidth:
      [ `Int of int  | `Float of float ]
        option
      ;
    strokeOpacity:
      [ `Int of int  | `Float of float ]
        option
      ;
    strokeDashOffset:
      [ `Int of int  | `Float of float ]
        option
      ;
    strokeDash:
      [ `Int of int  | `Float of float ] list
        option
      ;
    stroke: string option ;
    size:
      [ `Int of int  | `Float of float ]
        option
      ;
    shape: string option ;
    radius:
      [ `Int of int  | `Float of float ]
        option
      ;
    orient: Orient.t option ;
    opacity:
      [ `Int of int  | `Float of float ]
        option
      ;
    limit:
      [ `Int of int  | `Float of float ]
        option
      ;
    interpolate: Interpolate.t option ;
    fontWeight:
      [ `FontWeight of FontWeight.t 
      | `Num of FontWeightNumber.t ] option ;
    fontStyle: FontStyle.t option ;
    fontSize:
      [ `Int of int  | `Float of float ]
        option
      ;
    font: string option ;
    filled: bool option ;
    fillOpacity:
      [ `Int of int  | `Float of float ]
        option
      ;
    fill: string option ;
    dy:
      [ `Int of int  | `Float of float ]
        option
      ;
    dx:
      [ `Int of int  | `Float of float ]
        option
      ;
    color: string option ;
    baseline: VerticalAlign.t option ;
    angle:
      [ `Int of int  | `Float of float ]
        option
      ;
    align: HorizontalAlign.t option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?align:HorizontalAlign.t ->
      ?angle:[ `Int of int 
             | `Float of float ]
        ->
        ?baseline:VerticalAlign.t ->
          ?color:string ->
            ?dx:[ `Int of int 
                | `Float of float ]
              ->
              ?dy:[ `Int of int 
                  | `Float of float ]
                ->
                ?fill:string ->
                  ?fillOpacity:[ `Int of int 
                               | `Float of
                                   float ]
                    ->
                    ?filled:bool ->
                      ?font:string ->
                        ?fontSize:[
                                    `Int of
                                     int 
                                  | `Float of
                                     float ]
                          ->
                          ?fontStyle:FontStyle.t
                            ->
                            ?fontWeight:
                              [
                                `FontWeight of
FontWeight.t 
                              | `Num of
FontWeightNumber.t
                                  ]
                              ->
                              ?interpolate:Interpolate.t
                                ->
                                ?limit:
                                  [
                                    `Int of
                                     int 
                                  | `Float of
                                     float ]
                                  ->
                                  ?opacity:
                                    [
                                     `Int of
                                     int 
                                    | `Float
                                     of float ]
                                    ->
                                    ?orient:Orient.t
                                     ->
                                     ?radius:
                                     [
                                     `Int of
                                     int 
                                     | `Float
                                     of float ]
                                     ->
                                     ?shape:string
                                     ->
                                     ?size:
                                     [
                                     `Int of
                                     int 
                                     | `Float
                                     of float ]
                                     ->
                                     ?stroke:string
                                     ->
                                     ?strokeDash:
                                     [
                                     `Int of
                                     int 
                                     | `Float
                                     of float ]
                                     list ->
                                     ?strokeDashOffset:
                                     [
                                     `Int of
                                     int 
                                     | `Float
                                     of float ]
                                     ->
                                     ?strokeOpacity:
                                     [
                                     `Int of
                                     int 
                                     | `Float
                                     of float ]
                                     ->
                                     ?strokeWidth:
                                     [
                                     `Int of
                                     int 
                                     | `Float
                                     of float ]
                                     ->
                                     ?tension:
                                     [
                                     `Int of
                                     int 
                                     | `Float
                                     of float ]
                                     ->
                                     ?text:string
                                     ->
                                     ?theta:
                                     [
                                     `Int of
                                     int 
                                     | `Float
                                     of float ]
                                     ->
                                     unit -> t
  val withAlign : HorizontalAlign.t -> t -> t
  val withAngle :
    [ `Int of int  | `Float of float ] ->
      t -> t
  val withBaseline : VerticalAlign.t -> t -> t
  val withColor : string -> t -> t
  val withDx :
    [ `Int of int  | `Float of float ] ->
      t -> t
  val withDy :
    [ `Int of int  | `Float of float ] ->
      t -> t
  val withFill : string -> t -> t
  val withFillOpacity :
    [ `Int of int  | `Float of float ] ->
      t -> t
  val withFilled : bool -> t -> t
  val withFont : string -> t -> t
  val withFontSize :
    [ `Int of int  | `Float of float ] ->
      t -> t
  val withFontStyle : FontStyle.t -> t -> t
  val withFontWeight :
    [ `FontWeight of FontWeight.t 
    | `Num of FontWeightNumber.t ] -> 
      t -> t
  val withInterpolate :
Interpolate.t -> t -> t
  val withLimit :
    [ `Int of int  | `Float of float ] ->
      t -> t
  val withOpacity :
    [ `Int of int  | `Float of float ] ->
      t -> t
  val withOrient : Orient.t -> t -> t
  val withRadius :
    [ `Int of int  | `Float of float ] ->
      t -> t
  val withShape : string -> t -> t
  val withSize :
    [ `Int of int  | `Float of float ] ->
      t -> t
  val withStroke : string -> t -> t
  val withStrokeDash :
    [ `Int of int  | `Float of float ] list ->
      t -> t
  val withStrokeDashOffset :
    [ `Int of int  | `Float of float ] ->
      t -> t
  val withStrokeOpacity :
    [ `Int of int  | `Float of float ] ->
      t -> t
  val withStrokeWidth :
    [ `Int of int  | `Float of float ] ->
      t -> t
  val withTension :
    [ `Int of int  | `Float of float ] ->
      t -> t
  val withText : string -> t -> t
  val withTheta :
    [ `Int of int  | `Float of float ] ->
      t -> t
end =
struct
  type nonrec t =
    {
    theta: [ `Int of int  | `Float of float ] option ;
    text: string option ;
    tension: [ `Int of int  | `Float of float ] option ;
    strokeWidth: [ `Int of int  | `Float of float ] option ;
    strokeOpacity: [ `Int of int  | `Float of float ] option ;
    strokeDashOffset:
      [ `Int of int  | `Float of float ] option ;
    strokeDash:
      [ `Int of int  | `Float of float ] list option ;
    stroke: string option ;
    size: [ `Int of int  | `Float of float ] option ;
    shape: string option ;
    radius: [ `Int of int  | `Float of float ] option ;
    orient: Orient.t option ;
    opacity: [ `Int of int  | `Float of float ] option ;
    limit: [ `Int of int  | `Float of float ] option ;
    interpolate: Interpolate.t option ;
    fontWeight:
      [ `FontWeight of FontWeight.t 
      | `Num of FontWeightNumber.t ] option ;
    fontStyle: FontStyle.t option ;
    fontSize: [ `Int of int  | `Float of float ] option ;
    font: string option ;
    filled: bool option ;
    fillOpacity: [ `Int of int  | `Float of float ] option ;
    fill: string option ;
    dy: [ `Int of int  | `Float of float ] option ;
    dx: [ `Int of int  | `Float of float ] option ;
    color: string option ;
    baseline: VerticalAlign.t option ;
    angle: [ `Int of int  | `Float of float ] option ;
    align: HorizontalAlign.t option }

  (** Fields
  
    theta:
      Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating "north".
  
    text:
      Placeholder text if the `text` channel is not specified
  
    tension:
      Depending on the interpolation type, sets the tension parameter (for line and area marks).
  
    strokeWidth:
      The stroke width, in pixels.
  
    strokeOpacity:
      The stroke opacity (value between [0,1]).
      
      __Default value:__ `1`
  
    strokeDashOffset:
      The offset (in pixels) into which to begin drawing with the stroke dash array.
  
    strokeDash:
      An array of alternating stroke, space lengths for creating dashed or dotted lines.
  
    stroke:
      Default Stroke Color.  This has higher precedence than config.color
      
      __Default value:__ (None)
  
    size:
      Size of the box and mid tick of a box plot 
  
    shape:
      The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
      
      __Default value:__ `"circle"`
  
    radius:
      Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.
  
    orient:
      The orientation of a non-stacked bar, tick, area, and line charts.
      The value is either horizontal (default) or vertical.
      - For bar, rule and tick, this determines whether the size of the bar and tick
      should be applied to x or y dimension.
      - For area, this property determines the orient property of the Vega output.
      - For line, this property determines the sort order of the points in the line
      if `config.sortLineBy` is not specified.
      For stacked charts, this is always determined by the orientation of the stack;
      therefore explicitly specified value will be ignored.
  
    opacity:
      The overall opacity (value between [0,1]).
      
      __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
  
    limit:
      The maximum length of the text mark in pixels (default 0, indicating no limit). The text value will be automatically truncated if the rendered size exceeds the limit.
  
    interpolate:
      The line interpolation method to use for line and area marks. One of the following:
      - `"linear"`: piecewise linear segments, as in a polyline.
      - `"linear-closed"`: close the linear segments to form a polygon.
      - `"step"`: alternate between horizontal and vertical segments, as in a step function.
      - `"step-before"`: alternate between vertical and horizontal segments, as in a step function.
      - `"step-after"`: alternate between horizontal and vertical segments, as in a step function.
      - `"basis"`: a B-spline, with control point duplication on the ends.
      - `"basis-open"`: an open B-spline; may not intersect the start or end.
      - `"basis-closed"`: a closed B-spline, as in a loop.
      - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
      - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
      - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
      - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the spline.
      - `"monotone"`: cubic interpolation that preserves monotonicity in y.
  
    fontWeight:
      The font weight (e.g., `"bold"`).
  
    fontStyle:
      The font style (e.g., `"italic"`).
  
    fontSize:
      The font size, in pixels.
  
    font:
      The typeface to set the text in (e.g., `"Helvetica Neue"`).
  
    filled:
      Whether the mark's color should be used as fill color instead of stroke color.
      
      __Default value:__ `true` for all marks except `point` and `false` for `point`.
      
      __Applicable for:__ `bar`, `point`, `circle`, `square`, and `area` marks.
  
    fillOpacity:
      The fill opacity (value between [0,1]).
      
      __Default value:__ `1`
  
    fill:
      Default Fill Color.  This has higher precedence than config.color
      
      __Default value:__ (None)
  
    dy:
      The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.
  
    dx:
      The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.
  
    color:
      Default color.  Note that `fill` and `stroke` have higher precedence than `color` and will override `color`.
      
      __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
  
    baseline:
      The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
      
      __Default value:__ `"middle"`
  
    angle:
      The rotation angle of the text, in degrees.
  
    align:
      The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("align",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : HorizontalAlign.t)  ->
                       (HorizontalAlign.to_yojson x : 
Yojson.Safe.json))) v)) x.align));
         ("angle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v)) x.angle));
         ("baseline",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : VerticalAlign.t)  ->
                      (VerticalAlign.to_yojson x : Yojson.Safe.json)))
                    v)) x.baseline));
         ("color",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.color));
         ("dx",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v)) x.dx));
         ("dy",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v)) x.dy));
         ("fill",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.fill));
         ("fillOpacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v))
              x.fillOpacity));
         ("filled",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  ->
                      (`Bool b : Yojson.Safe.json))) v))
              x.filled));
         ("font",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.font));
         ("fontSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v)) x.fontSize));
         ("fontStyle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : FontStyle.t)  ->
                      (FontStyle.to_yojson x : Yojson.Safe.json)))
                    v)) x.fontStyle));
         ("fontWeight",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Num v ->
                        ((fun (x : FontWeightNumber.t)  ->
                            (FontWeightNumber.to_yojson x : 
Yojson.Safe.json))) v
                    | `FontWeight v ->
                        ((fun (x : FontWeight.t)  ->
                            (FontWeight.to_yojson x : 
Yojson.Safe.json))) v)) v))
              x.fontWeight));
         ("interpolate",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Interpolate.t)  ->
                      (Interpolate.to_yojson x : Yojson.Safe.json)))
                    v)) x.interpolate));
         ("limit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v)) x.limit));
         ("opacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v)) x.opacity));
         ("orient",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : Orient.t)  ->
                      (Orient.to_yojson x : Yojson.Safe.json)))
                    v)) x.orient));
         ("radius",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v)) x.radius));
         ("shape",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.shape));
         ("size",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v)) x.size));
         ("stroke",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.stroke));
         ("strokeDash",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (l :
                        [ `Int of int  | `Float of float ]
                          list)
                       ->
                      let yojson_of_el =
                        function
                        | `Int i -> `Int i
                        | `Float f -> `Float f  in
                      (`List (List.map yojson_of_el l) : 
Yojson.Safe.json))) v)) x.strokeDash));
         ("strokeDashOffset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v))
              x.strokeDashOffset));
         ("strokeOpacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v))
              x.strokeOpacity));
         ("strokeWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v))
              x.strokeWidth));
         ("tension",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v)) x.tension));
         ("text",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json))) v))
              x.text));
         ("theta",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
| `Float f -> `Float f)) v)) x.theta))])                      
  let make ?align  ?angle  ?baseline  ?color  ?dx  ?dy 
    ?fill  ?fillOpacity  ?filled  ?font  ?fontSize 
    ?fontStyle  ?fontWeight  ?interpolate  ?limit  ?opacity 
    ?orient  ?radius  ?shape  ?size  ?stroke  ?strokeDash 
    ?strokeDashOffset  ?strokeOpacity  ?strokeWidth 
    ?tension  ?text  ?theta  () =
    {
      theta;
      text;
      tension;
      strokeWidth;
      strokeOpacity;
      strokeDashOffset;
      strokeDash;
      stroke;
      size;
      shape;
      radius;
      orient;
      opacity;
      limit;
      interpolate;
      fontWeight;
      fontStyle;
      fontSize;
      font;
      filled;
      fillOpacity;
      fill;
      dy;
      dx;
      color;
      baseline;
      angle;
      align
    } 
  let withAlign v x = { x with align = (Some v) } 
  let withAngle v x = { x with angle = (Some v) } 
  let withBaseline v x = { x with baseline = (Some v) } 
  let withColor v x = { x with color = (Some v) } 
  let withDx v x = { x with dx = (Some v) } 
  let withDy v x = { x with dy = (Some v) } 
  let withFill v x = { x with fill = (Some v) } 
  let withFillOpacity v x =
    { x with fillOpacity = (Some v) } 
  let withFilled v x = { x with filled = (Some v) } 
  let withFont v x = { x with font = (Some v) } 
  let withFontSize v x = { x with fontSize = (Some v) } 
  let withFontStyle v x = { x with fontStyle = (Some v) } 
  let withFontWeight v x = { x with fontWeight = (Some v) } 
  let withInterpolate v x =
    { x with interpolate = (Some v) } 
  let withLimit v x = { x with limit = (Some v) } 
  let withOpacity v x = { x with opacity = (Some v) } 
  let withOrient v x = { x with orient = (Some v) } 
  let withRadius v x = { x with radius = (Some v) } 
  let withShape v x = { x with shape = (Some v) } 
  let withSize v x = { x with size = (Some v) } 
  let withStroke v x = { x with stroke = (Some v) } 
  let withStrokeDash v x = { x with strokeDash = (Some v) } 
  let withStrokeDashOffset v x =
    { x with strokeDashOffset = (Some v) } 
  let withStrokeOpacity v x =
    { x with strokeOpacity = (Some v) } 
  let withStrokeWidth v x =
    { x with strokeWidth = (Some v) } 
  let withTension v x = { x with tension = (Some v) } 
  let withText v x = { x with text = (Some v) } 
  let withTheta v x = { x with theta = (Some v) } 
end and
BinTransform:sig
  type nonrec t =
    {
    field: string ;
    bin:
      [ `Bool of bool 
      | `Params of BinParams.t ] ;
    nameAs: string }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    nameAs:string ->
      bin:[ `Bool of bool 
          | `Params of BinParams.t ]
        -> field:string -> unit -> t
  val withNameAs : string -> t -> t
  val withBin :
    [ `Bool of bool 
    | `Params of BinParams.t ] -> 
      t -> t
  val withField : string -> t -> t
end =
struct
  type nonrec t =
    {
    field: string ;
    bin: [ `Bool of bool  | `Params of BinParams.t ] ;
    nameAs: string }

  (** Fields
  
    field:
      The data field to bin.
  
    bin:
      An object indicating bin properties, or simply `true` for using default bin parameters.
  
    as:
      The output fields at which to write the start and end bin values.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with | `Null -> false | _ -> true)
         [("as",
            (((fun (s : string)  ->
                 (`String s : Yojson.Safe.json)))
               x.nameAs));
         ("bin",
           (((function
              | `Params v ->
                  ((fun (x : BinParams.t)  ->
                      (BinParams.to_yojson x : 
Yojson.Safe.json))) v
              | `Bool v ->
                  ((fun (b : bool)  ->
                      (`Bool b : Yojson.Safe.json))) v))
              x.bin));
         ("field",
           (((fun (s : string)  ->
                (`String s : Yojson.Safe.json)))
x.field))])                           
  let make ~nameAs  ~bin  ~field  () =
    { field; bin; nameAs } 
  let withNameAs v x = { x with nameAs = v } 
  let withBin v x = { x with bin = v } 
  let withField v x = { x with field = v } 
end and
BinParams:sig
  type nonrec t =
    {
    steps:
      [ `Int of int  | `Float of float ]
        list option
      ;
    step:
      [ `Int of int  | `Float of float ]
        option
      ;
    nice: bool option ;
    minstep:
      [ `Int of int  | `Float of float ]
        option
      ;
    maxbins:
      [ `Int of int  | `Float of float ]
        option
      ;
    extent:
      [ `Int of int  | `Float of float ]
        list option
      ;
    divide:
      [ `Int of int  | `Float of float ]
        list option
      ;
    base:
      [ `Int of int  | `Float of float ]
        option
      }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?base:[ `Int of int 
          | `Float of float ]
      ->
      ?divide:[ `Int of int 
              | `Float of float ]
        list ->
        ?extent:[ `Int of int 
                | `Float of float ]
          list ->
          ?maxbins:[ `Int of int 
                   | `Float of float ]
            ->
            ?minstep:[ `Int of int 
                     | `Float of float ]
              ->
              ?nice:bool ->
                ?step:[ `Int of int 
                      | `Float of float ]
                  ->
                  ?steps:[ `Int of int 
                         | `Float of
                             float ]
                    list -> unit -> t
  val withBase :
    [ `Int of int  | `Float of float ]
      -> t -> t
  val withDivide :
    [ `Int of int  | `Float of float ]
      list -> t -> t
  val withExtent :
    [ `Int of int  | `Float of float ]
      list -> t -> t
  val withMaxbins :
    [ `Int of int  | `Float of float ]
      -> t -> t
  val withMinstep :
    [ `Int of int  | `Float of float ]
      -> t -> t
  val withNice : bool -> t -> t
  val withStep :
    [ `Int of int  | `Float of float ]
      -> t -> t
  val withSteps :
    [ `Int of int  | `Float of float ]
      list -> t -> t
end =
struct
  type nonrec t =
    {
    steps:
      [ `Int of int  | `Float of float ] list
        option
      ;
    step:
      [ `Int of int  | `Float of float ] option ;
    nice: bool option ;
    minstep:
      [ `Int of int  | `Float of float ] option ;
    maxbins:
      [ `Int of int  | `Float of float ] option ;
    extent:
      [ `Int of int  | `Float of float ] list
        option
      ;
    divide:
      [ `Int of int  | `Float of float ] list
        option
      ;
    base:
      [ `Int of int  | `Float of float ] option }

  (** Binning properties or boolean flag for determining whether to bin data or not.
  
  
  Fields:
  
    steps:
      An array of allowable step sizes to choose from.
  
    step:
      An exact step size to use between bins.
      
      __Note:__ If provided, options such as maxbins will be ignored.
  
    nice:
      If true (the default), attempts to make the bin boundaries use human-friendly boundaries, such as multiples of ten.
  
    minstep:
      A minimum allowable step size (particularly useful for integer values).
  
    maxbins:
      Maximum number of bins.
      
      __Default value:__ `6` for `row`, `column` and `shape` channels; `10` for other channels
  
    extent:
      A two-element (`[min, max]`) array indicating the range of desired bin values.
  
    divide:
      Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.
      
      __Default value:__ `[5, 2]`
  
    base:
      The number base to use for automatic bin determination (default is base 10).
      
      __Default value:__ `10`
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("base",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function
                     | `Int i -> `Int i
                     | `Float f -> `Float f)) v))
               x.base));
         ("divide",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (l :
                        [ `Int of int 
                        | `Float of float ] list)
                       ->
                      let yojson_of_el =
                        function
                        | `Int i -> `Int i
                        | `Float f -> `Float f  in
                      (`List
                         (List.map yojson_of_el l) : 
Yojson.Safe.json))) v))
              x.divide));
         ("extent",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (l :
                        [ `Int of int 
                        | `Float of float ] list)
                       ->
                      let yojson_of_el =
                        function
                        | `Int i -> `Int i
                        | `Float f -> `Float f  in
                      (`List
                         (List.map yojson_of_el l) : 
Yojson.Safe.json))) v))
              x.extent));
         ("maxbins",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v))
              x.maxbins));
         ("minstep",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v))
              x.minstep));
         ("nice",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  ->
                      (`Bool b : Yojson.Safe.json)))
                    v)) x.nice));
         ("step",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i -> `Int i
                    | `Float f -> `Float f)) v))
              x.step));
         ("steps",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (l :
                        [ `Int of int 
                        | `Float of float ] list)
                       ->
                      let yojson_of_el =
                        function
                        | `Int i -> `Int i
                        | `Float f -> `Float f  in
                      (`List
                         (List.map yojson_of_el l) : 
Yojson.Safe.json))) v))
x.steps))])                                
  let make ?base  ?divide  ?extent  ?maxbins 
    ?minstep  ?nice  ?step  ?steps  () =
    {
      steps;
      step;
      nice;
      minstep;
      maxbins;
      extent;
      divide;
      base
    } 
  let withBase v x = { x with base = (Some v) } 
  let withDivide v x =
    { x with divide = (Some v) } 
  let withExtent v x =
    { x with extent = (Some v) } 
  let withMaxbins v x =
    { x with maxbins = (Some v) } 
  let withMinstep v x =
    { x with minstep = (Some v) } 
  let withNice v x = { x with nice = (Some v) } 
  let withStep v x = { x with step = (Some v) } 
  let withSteps v x = { x with steps = (Some v) } 
end and
BaseSpec:sig
  type nonrec t =
    {
    transform:
Transform.t list option ;
    title:
      [ `String of string 
      | `Params of TitleParams.t ]
        option
      ;
    name: string option ;
    description: string option ;
    data: Data.t option }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?data:Data.t ->
      ?description:string ->
        ?name:string ->
          ?title:[
                   `String of string 
                 | `Params of
TitleParams.t ]
            ->
            ?transform:Transform.t
              list -> unit -> t
  val withData : Data.t -> t -> t
  val withDescription :
    string -> t -> t
  val withName : string -> t -> t
  val withTitle :
    [ `String of string 
    | `Params of TitleParams.t ] ->
      t -> t
  val withTransform :
Transform.t list -> t -> t
end =
struct
  type nonrec t =
    {
    transform: Transform.t list option ;
    title:
      [ `String of string 
      | `Params of TitleParams.t ] option ;
    name: string option ;
    description: string option ;
    data: Data.t option }

  (** Fields
  
    transform:
      An array of data transformations such as filter and new field calculation.
  
    title:
      Title for the plot.
  
    name:
      Name of the visualization for later reference.
  
    description:
      An optional description of this mark for commenting purpose.
  
    data:
      An object describing the data source
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("data",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (x : Data.t)  ->
                       (Data.to_yojson x : 
Yojson.Safe.json))) v))
               x.data));
         ("description",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.description));
         ("name",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  ->
                      (`String s : Yojson.Safe.json)))
                    v)) x.name));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Params v ->
                        ((fun
                            (x :
TitleParams.t)
                             ->
                            (TitleParams.to_yojson
                               x : Yojson.Safe.json)))
                          v
                    | `String v ->
                        ((fun (s : string) 
                            ->
                            (`String s : 
Yojson.Safe.json)))
                          v)) v)) x.title));
         ("transform",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (l : Transform.t list) 
                      ->
                      let yojson_of_el
                        (x : Transform.t) =
                        (Transform.to_yojson
                           x : Yojson.Safe.json)
                         in
                      (`List
                         (List.map
                            yojson_of_el l) : 
Yojson.Safe.json))) v))
x.transform))])                                     
  let make ?data  ?description  ?name  ?title
     ?transform  () =
    {
      transform;
      title;
      name;
      description;
      data
    } 
  let withData v x =
    { x with data = (Some v) } 
  let withDescription v x =
    { x with description = (Some v) } 
  let withName v x =
    { x with name = (Some v) } 
  let withTitle v x =
    { x with title = (Some v) } 
  let withTransform v x =
    { x with transform = (Some v) } 
end and
BaseSelectionDef:sig
  type nonrec t =
    {
    resolve:
SelectionResolution.t
        option
      ;
    on:
VgEventStream.t
        option
      ;
    fields:
      string list
        option
      ;
    encodings:
SingleDefChannel.t
        list option
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?encodings:SingleDefChannel.t
      list ->
      ?fields:string
        list ->
        ?on:VgEventStream.t
          ->
          ?resolve:SelectionResolution.t
            ->
            unit -> t
  val withEncodings :
SingleDefChannel.t
      list -> t -> t
  val withFields :
    string list ->
      t -> t
  val withOn :
VgEventStream.t ->
      t -> t
  val withResolve :
SelectionResolution.t
      -> t -> t
end =
struct
  type nonrec t =
    {
    resolve:
SelectionResolution.t option ;
    on: VgEventStream.t option ;
    fields: string list option ;
    encodings:
SingleDefChannel.t list option }

  (** Fields
  
    resolve:
      With layered and multi-view displays, a strategy that determines how
      selections' data queries are resolved when applied in a filter transform,
      conditional encoding rule, or scale domain.
  
    on:
      A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.
      For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).
  
    fields:
      An array of field names whose values must match for a data tuple to
      fall within the selection.
  
    encodings:
      An array of encoding channels. The corresponding data field values
      must match for a data tuple to fall within the selection.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("encodings",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun
                       (l :
SingleDefChannel.t
                           list)
                        ->
                       let yojson_of_el
                         (x :
SingleDefChannel.t)
                         =
                         (SingleDefChannel.to_yojson
                            x : 
Yojson.Safe.json)
                          in
                       (`List
                          (List.map
                             yojson_of_el
                             l) : 
Yojson.Safe.json)))
                     v)) x.encodings));
         ("fields",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (l : string list) 
                      ->
                      let yojson_of_el
                        (s : string) =
                        (`String s : 
Yojson.Safe.json)
                         in
                      (`List
                         (List.map
                            yojson_of_el
                            l) : 
Yojson.Safe.json)))
                    v)) x.fields));
         ("on",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
VgEventStream.t)
                       ->
                      (VgEventStream.to_yojson
                         x : Yojson.Safe.json)))
                    v)) x.on));
         ("resolve",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (x :
SelectionResolution.t)
                       ->
                      (SelectionResolution.to_yojson
                         x : Yojson.Safe.json)))
v)) x.resolve))])                                          
  let make ?encodings  ?fields  ?on 
    ?resolve  () =
    { resolve; on; fields; encodings } 
  let withEncodings v x =
    { x with encodings = (Some v) } 
  let withFields v x =
    { x with fields = (Some v) } 
  let withOn v x =
    { x with on = (Some v) } 
  let withResolve v x =
    { x with resolve = (Some v) } 
end and
BaseBin:sig
  type nonrec t =
    {
    steps:
      [ `Int of int 
      | `Float of float ]
        list option
      ;
    step:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    nice: bool option ;
    minstep:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    maxbins:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    divide:
      [ `Int of int 
      | `Float of float ]
        list option
      ;
    base:
      [ `Int of int 
      | `Float of float ]
        option
      }
  val to_yojson :
    t -> Yojson.Safe.json
  val make :
    ?base:[ `Int of int 
          | `Float of float ]
      ->
      ?divide:[
                `Int of int 
              | `Float of
                  float ]
        list ->
        ?maxbins:[
                  `Int of
                  int 
                 | `Float
                  of float ]
          ->
          ?minstep:
            [ `Int of int 
            | `Float of
                float ]
            ->
            ?nice:bool ->
              ?step:
                [
                  `Int of
                  int 
                | `Float of
                  float ]
                ->
                ?steps:
                  [
                  `Int of
                  int 
                  | `Float
                  of float ]
                  list ->
                  unit -> t
  val withBase :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withDivide :
    [ `Int of int 
    | `Float of float ]
      list -> t -> t
  val withMaxbins :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withMinstep :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withNice :
    bool -> t -> t
  val withStep :
    [ `Int of int 
    | `Float of float ] ->
      t -> t
  val withSteps :
    [ `Int of int 
    | `Float of float ]
      list -> t -> t
end =
struct
  type nonrec t =
    {
    steps:
      [ `Int of int 
      | `Float of float ] list
        option
      ;
    step:
      [ `Int of int 
      | `Float of float ] option ;
    nice: bool option ;
    minstep:
      [ `Int of int 
      | `Float of float ] option ;
    maxbins:
      [ `Int of int 
      | `Float of float ] option ;
    divide:
      [ `Int of int 
      | `Float of float ] list
        option
      ;
    base:
      [ `Int of int 
      | `Float of float ] option }

  (** Fields
  
    steps:
      An array of allowable step sizes to choose from.
  
    step:
      An exact step size to use between bins.
      
      __Note:__ If provided, options such as maxbins will be ignored.
  
    nice:
      If true (the default), attempts to make the bin boundaries use human-friendly boundaries, such as multiples of ten.
  
    minstep:
      A minimum allowable step size (particularly useful for integer values).
  
    maxbins:
      Maximum number of bins.
      
      __Default value:__ `6` for `row`, `column` and `shape` channels; `10` for other channels
  
    divide:
      Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.
      
      __Default value:__ `[5, 2]`
  
    base:
      The number base to use for automatic bin determination (default is base 10).
      
      __Default value:__ `10`
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("base",
            (((function
               | None  -> `Null
               | Some v ->
                   ((function
                     | `Int i ->
                         `Int i
                     | `Float f ->
                         `Float f))
                     v)) x.base));
         ("divide",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (l :
                        [
                          `Int of
                          int 
                        | `Float of
                          float ]
                          list)
                       ->
                      let yojson_of_el
                        =
                        function
                        | `Int i ->
                          `Int i
                        | `Float f
                          ->
                          `Float f
                         in
                      (`List
                         (List.map
                          yojson_of_el
                          l) : 
Yojson.Safe.json)))
                    v)) x.divide));
         ("maxbins",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i ->
                        `Int i
                    | `Float f ->
                        `Float f))
                    v)) x.maxbins));
         ("minstep",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i ->
                        `Int i
                    | `Float f ->
                        `Float f))
                    v)) x.minstep));
         ("nice",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool) 
                      ->
                      (`Bool b : 
Yojson.Safe.json)))
                    v)) x.nice));
         ("step",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Int i ->
                        `Int i
                    | `Float f ->
                        `Float f))
                    v)) x.step));
         ("steps",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                      (l :
                        [
                          `Int of
                          int 
                        | `Float of
                          float ]
                          list)
                       ->
                      let yojson_of_el
                        =
                        function
                        | `Int i ->
                          `Int i
                        | `Float f
                          ->
                          `Float f
                         in
                      (`List
                         (List.map
                          yojson_of_el
                          l) : 
Yojson.Safe.json)))
v)) x.steps))])                                               
  let make ?base  ?divide  ?maxbins
     ?minstep  ?nice  ?step  ?steps
     () =
    {
      steps;
      step;
      nice;
      minstep;
      maxbins;
      divide;
      base
    } 
  let withBase v x =
    { x with base = (Some v) } 
  let withDivide v x =
    { x with divide = (Some v) } 
  let withMaxbins v x =
    { x with maxbins = (Some v) } 
  let withMinstep v x =
    { x with minstep = (Some v) } 
  let withNice v x =
    { x with nice = (Some v) } 
  let withStep v x =
    { x with step = (Some v) } 
  let withSteps v x =
    { x with steps = (Some v) } 
end and
BarConfig:sig
  type nonrec t =
    {
    theta:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    text:
      string option ;
    tension:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    strokeWidth:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    strokeOpacity:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    strokeDashOffset:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    strokeDash:
      [ `Int of int 
      | `Float of
          float ]
        list option
      ;
    stroke:
      string option ;
    size:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    shape:
      string option ;
    radius:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    orient:
Orient.t
        option
      ;
    opacity:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    limit:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    interpolate:
Interpolate.t
        option
      ;
    fontWeight:
      [
        `FontWeight
          of
FontWeight.t
           | 
        `Num of
FontWeightNumber.t
          ]
        option
      ;
    fontStyle:
FontStyle.t
        option
      ;
    fontSize:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    font:
      string option ;
    filled:
      bool option ;
    fillOpacity:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    fill:
      string option ;
    dy:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    dx:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    discreteBandSize:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    continuousBandSize:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    color:
      string option ;
    binSpacing:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    baseline:
VerticalAlign.t
        option
      ;
    angle:
      [ `Int of int 
      | `Float of
          float ]
        option
      ;
    align:
HorizontalAlign.t
        option
      }
  val to_yojson :
    t ->
Yojson.Safe.json
  val make :
    ?align:HorizontalAlign.t
      ->
      ?angle:
        [
          `Int of
           int 
        | `Float of
           float ]
        ->
        ?baseline:VerticalAlign.t
          ->
          ?binSpacing:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?color:string
           ->
           ?continuousBandSize:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?discreteBandSize:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?dx:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?dy:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?fill:string
           ->
           ?fillOpacity:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?filled:bool
           ->
           ?font:string
           ->
           ?fontSize:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?fontStyle:FontStyle.t
           ->
           ?fontWeight:
           [
           `FontWeight
           of
FontWeight.t
            | 
           `Num of
FontWeightNumber.t
           ] ->
           ?interpolate:Interpolate.t
           ->
           ?limit:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?opacity:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?orient:Orient.t
           ->
           ?radius:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?shape:string
           ->
           ?size:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?stroke:string
           ->
           ?strokeDash:
           [
           `Int of
           int 
           | `Float
           of float ]
           list ->
           ?strokeDashOffset:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?strokeOpacity:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?strokeWidth:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?tension:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           ?text:string
           ->
           ?theta:
           [
           `Int of
           int 
           | `Float
           of float ]
           ->
           unit -> t
  val withAlign :
HorizontalAlign.t
      -> t -> t
  val withAngle :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withBaseline :
VerticalAlign.t
      -> t -> t
  val withBinSpacing
    :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withColor :
    string -> t -> t
  val
    withContinuousBandSize
    :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val
    withDiscreteBandSize
    :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withDx :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withDy :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withFill :
    string -> t -> t
  val
    withFillOpacity
    :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withFilled :
    bool -> t -> t
  val withFont :
    string -> t -> t
  val withFontSize :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withFontStyle
    :
FontStyle.t ->
      t -> t
  val withFontWeight
    :
    [
      `FontWeight of
FontWeight.t 
    | `Num of
FontWeightNumber.t
        ]
      -> t -> t
  val
    withInterpolate
    :
Interpolate.t ->
      t -> t
  val withLimit :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withOpacity :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withOrient :
Orient.t ->
      t -> t
  val withRadius :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withShape :
    string -> t -> t
  val withSize :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withStroke :
    string -> t -> t
  val withStrokeDash
    :
    [ `Int of int 
    | `Float of
        float ]
      list -> 
      t -> t
  val
    withStrokeDashOffset
    :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val
    withStrokeOpacity
    :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val
    withStrokeWidth
    :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withTension :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
  val withText :
    string -> t -> t
  val withTheta :
    [ `Int of int 
    | `Float of
        float ]
      -> t -> t
end =
struct
  type nonrec t =
    {
    theta:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    text: string option ;
    tension:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    strokeWidth:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    strokeOpacity:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    strokeDashOffset:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    strokeDash:
      [ `Int of int 
      | `Float of float ] list
        option
      ;
    stroke: string option ;
    size:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    shape: string option ;
    radius:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    orient: Orient.t option ;
    opacity:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    limit:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    interpolate:
Interpolate.t option ;
    fontWeight:
      [
        `FontWeight of
FontWeight.t 
      | `Num of
FontWeightNumber.t ]
        option
      ;
    fontStyle:
FontStyle.t option ;
    fontSize:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    font: string option ;
    filled: bool option ;
    fillOpacity:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    fill: string option ;
    dy:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    dx:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    discreteBandSize:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    continuousBandSize:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    color: string option ;
    binSpacing:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    baseline:
VerticalAlign.t option ;
    angle:
      [ `Int of int 
      | `Float of float ]
        option
      ;
    align:
HorizontalAlign.t option }

  (** Fields
  
    theta:
      Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating "north".
  
    text:
      Placeholder text if the `text` channel is not specified
  
    tension:
      Depending on the interpolation type, sets the tension parameter (for line and area marks).
  
    strokeWidth:
      The stroke width, in pixels.
  
    strokeOpacity:
      The stroke opacity (value between [0,1]).
      
      __Default value:__ `1`
  
    strokeDashOffset:
      The offset (in pixels) into which to begin drawing with the stroke dash array.
  
    strokeDash:
      An array of alternating stroke, space lengths for creating dashed or dotted lines.
  
    stroke:
      Default Stroke Color.  This has higher precedence than config.color
      
      __Default value:__ (None)
  
    size:
      The pixel area each the point/circle/square.
      For example: in the case of circles, the radius is determined in part by the square root of the size value.
      
      __Default value:__ `30`
  
    shape:
      The default symbol shape to use. One of: `"circle"` (default), `"square"`, `"cross"`, `"diamond"`, `"triangle-up"`, or `"triangle-down"`, or a custom SVG path.
      
      __Default value:__ `"circle"`
  
    radius:
      Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.
  
    orient:
      The orientation of a non-stacked bar, tick, area, and line charts.
      The value is either horizontal (default) or vertical.
      - For bar, rule and tick, this determines whether the size of the bar and tick
      should be applied to x or y dimension.
      - For area, this property determines the orient property of the Vega output.
      - For line, this property determines the sort order of the points in the line
      if `config.sortLineBy` is not specified.
      For stacked charts, this is always determined by the orientation of the stack;
      therefore explicitly specified value will be ignored.
  
    opacity:
      The overall opacity (value between [0,1]).
      
      __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.
  
    limit:
      The maximum length of the text mark in pixels (default 0, indicating no limit). The text value will be automatically truncated if the rendered size exceeds the limit.
  
    interpolate:
      The line interpolation method to use for line and area marks. One of the following:
      - `"linear"`: piecewise linear segments, as in a polyline.
      - `"linear-closed"`: close the linear segments to form a polygon.
      - `"step"`: alternate between horizontal and vertical segments, as in a step function.
      - `"step-before"`: alternate between vertical and horizontal segments, as in a step function.
      - `"step-after"`: alternate between horizontal and vertical segments, as in a step function.
      - `"basis"`: a B-spline, with control point duplication on the ends.
      - `"basis-open"`: an open B-spline; may not intersect the start or end.
      - `"basis-closed"`: a closed B-spline, as in a loop.
      - `"cardinal"`: a Cardinal spline, with control point duplication on the ends.
      - `"cardinal-open"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
      - `"cardinal-closed"`: a closed Cardinal spline, as in a loop.
      - `"bundle"`: equivalent to basis, except the tension parameter is used to straighten the spline.
      - `"monotone"`: cubic interpolation that preserves monotonicity in y.
  
    fontWeight:
      The font weight (e.g., `"bold"`).
  
    fontStyle:
      The font style (e.g., `"italic"`).
  
    fontSize:
      The font size, in pixels.
  
    font:
      The typeface to set the text in (e.g., `"Helvetica Neue"`).
  
    filled:
      Whether the mark's color should be used as fill color instead of stroke color.
      
      __Default value:__ `true` for all marks except `point` and `false` for `point`.
      
      __Applicable for:__ `bar`, `point`, `circle`, `square`, and `area` marks.
  
    fillOpacity:
      The fill opacity (value between [0,1]).
      
      __Default value:__ `1`
  
    fill:
      Default Fill Color.  This has higher precedence than config.color
      
      __Default value:__ (None)
  
    dy:
      The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.
  
    dx:
      The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.
  
    discreteBandSize:
      The size of the bars.  If unspecified, the default size is  `bandSize-1`,
      which provides 1 pixel offset between bars.
  
    continuousBandSize:
      The default size of the bars on continuous scales.
      
      __Default value:__ `2`
  
    color:
      Default color.  Note that `fill` and `stroke` have higher precedence than `color` and will override `color`.
      
      __Default value:__ <span style="color: #4682b4;">&#9632;</span> `"#4682b4"`
  
    binSpacing:
      Offset between bar for binned field.  Ideal value for this is either 0 (Preferred by statisticians) or 1 (Vega-Lite Default, D3 example style).
      
      __Default value:__ `1`
  
    baseline:
      The vertical alignment of the text. One of `"top"`, `"middle"`, `"bottom"`.
      
      __Default value:__ `"middle"`
  
    angle:
      The rotation angle of the text, in degrees.
  
    align:
      The horizontal alignment of the text. One of `"left"`, `"right"`, `"center"`.
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null -> false
            | _ -> true)
         [("align",
            (((function
               | None  ->
                   `Null
               | Some v ->
                   ((fun
                     (x :
HorizontalAlign.t)
                      ->
                     (HorizontalAlign.to_yojson
                     x : 
Yojson.Safe.json)))
                     v))
               x.align));
         ("angle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.angle));
         ("baseline",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (x :
VerticalAlign.t)
                      ->
                     (VerticalAlign.to_yojson
                     x : 
Yojson.Safe.json)))
                    v))
              x.baseline));
         ("binSpacing",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.binSpacing));
         ("color",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (s :
                     string) 
                     ->
                     (`String
                     s : 
Yojson.Safe.json)))
                    v))
              x.color));
         ("continuousBandSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.continuousBandSize));
         ("discreteBandSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.discreteBandSize));
         ("dx",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v)) x.dx));
         ("dy",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v)) x.dy));
         ("fill",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (s :
                     string) 
                     ->
                     (`String
                     s : 
Yojson.Safe.json)))
                    v)) x.fill));
         ("fillOpacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.fillOpacity));
         ("filled",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (b :
                     bool)  ->
                     (`Bool b : 
Yojson.Safe.json)))
                    v))
              x.filled));
         ("font",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (s :
                     string) 
                     ->
                     (`String
                     s : 
Yojson.Safe.json)))
                    v)) x.font));
         ("fontSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.fontSize));
         ("fontStyle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (x :
FontStyle.t)
                      ->
                     (FontStyle.to_yojson
                     x : 
Yojson.Safe.json)))
                    v))
              x.fontStyle));
         ("fontWeight",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Num v ->
                     ((fun
                     (x :
FontWeightNumber.t)
                      ->
                     (FontWeightNumber.to_yojson
                     x : Yojson.Safe.json)))
                     v
                    | 
                    `FontWeight
                     v ->
                     ((fun
                     (x :
FontWeight.t)
                      ->
                     (FontWeight.to_yojson
                     x : Yojson.Safe.json)))
                     v)) v))
              x.fontWeight));
         ("interpolate",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (x :
Interpolate.t)
                      ->
                     (Interpolate.to_yojson
                     x : 
Yojson.Safe.json)))
                    v))
              x.interpolate));
         ("limit",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.limit));
         ("opacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.opacity));
         ("orient",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (x :
Orient.t)
                      ->
                     (Orient.to_yojson
                     x : 
Yojson.Safe.json)))
                    v))
              x.orient));
         ("radius",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.radius));
         ("shape",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (s :
                     string) 
                     ->
                     (`String
                     s : 
Yojson.Safe.json)))
                    v))
              x.shape));
         ("size",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v)) x.size));
         ("stroke",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (s :
                     string) 
                     ->
                     (`String
                     s : 
Yojson.Safe.json)))
                    v))
              x.stroke));
         ("strokeDash",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (l :
                     [
                     `Int of
                     int 
                     | `Float
                     of float ]
                     list)  ->
                     let yojson_of_el
                     =
                     function
                     | 
                     `Int i ->
                     `Int i
                     | 
                     `Float f
                     ->
                     `Float f
                      in
                     (`List
                     (List.map
                     yojson_of_el
                     l) : 
Yojson.Safe.json)))
                    v))
              x.strokeDash));
         ("strokeDashOffset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.strokeDashOffset));
         ("strokeOpacity",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.strokeOpacity));
         ("strokeWidth",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.strokeWidth));
         ("tension",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
              x.tension));
         ("text",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun
                     (s :
                     string) 
                     ->
                     (`String
                     s : 
Yojson.Safe.json)))
                    v)) x.text));
         ("theta",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | 
                    `Int i ->
                     `Int i
                    | 
                    `Float f
                     ->
                     `Float f))
                    v))
x.theta))])                                                    
  let make ?align  ?angle 
    ?baseline  ?binSpacing 
    ?color 
    ?continuousBandSize 
    ?discreteBandSize  ?dx 
    ?dy  ?fill  ?fillOpacity 
    ?filled  ?font  ?fontSize 
    ?fontStyle  ?fontWeight 
    ?interpolate  ?limit 
    ?opacity  ?orient  ?radius
     ?shape  ?size  ?stroke 
    ?strokeDash 
    ?strokeDashOffset 
    ?strokeOpacity 
    ?strokeWidth  ?tension 
    ?text  ?theta  () =
    {
      theta;
      text;
      tension;
      strokeWidth;
      strokeOpacity;
      strokeDashOffset;
      strokeDash;
      stroke;
      size;
      shape;
      radius;
      orient;
      opacity;
      limit;
      interpolate;
      fontWeight;
      fontStyle;
      fontSize;
      font;
      filled;
      fillOpacity;
      fill;
      dy;
      dx;
      discreteBandSize;
      continuousBandSize;
      color;
      binSpacing;
      baseline;
      angle;
      align
    } 
  let withAlign v x =
    { x with align = (Some v)
    } 
  let withAngle v x =
    { x with angle = (Some v)
    } 
  let withBaseline v x =
    {
      x with
      baseline = (Some v)
    } 
  let withBinSpacing v x =
    {
      x with
      binSpacing = (Some v)
    } 
  let withColor v x =
    { x with color = (Some v)
    } 
  let withContinuousBandSize v
    x =
    {
      x with
      continuousBandSize =
        (Some v)
    } 
  let withDiscreteBandSize v x
    =
    {
      x with
      discreteBandSize =
        (Some v)
    } 
  let withDx v x =
    { x with dx = (Some v) } 
  let withDy v x =
    { x with dy = (Some v) } 
  let withFill v x =
    { x with fill = (Some v) } 
  let withFillOpacity v x =
    {
      x with
      fillOpacity = (Some v)
    } 
  let withFilled v x =
    { x with filled = (Some v)
    } 
  let withFont v x =
    { x with font = (Some v) } 
  let withFontSize v x =
    {
      x with
      fontSize = (Some v)
    } 
  let withFontStyle v x =
    {
      x with
      fontStyle = (Some v)
    } 
  let withFontWeight v x =
    {
      x with
      fontWeight = (Some v)
    } 
  let withInterpolate v x =
    {
      x with
      interpolate = (Some v)
    } 
  let withLimit v x =
    { x with limit = (Some v)
    } 
  let withOpacity v x =
    {
      x with
      opacity = (Some v)
    } 
  let withOrient v x =
    { x with orient = (Some v)
    } 
  let withRadius v x =
    { x with radius = (Some v)
    } 
  let withShape v x =
    { x with shape = (Some v)
    } 
  let withSize v x =
    { x with size = (Some v) } 
  let withStroke v x =
    { x with stroke = (Some v)
    } 
  let withStrokeDash v x =
    {
      x with
      strokeDash = (Some v)
    } 
  let withStrokeDashOffset v x
    =
    {
      x with
      strokeDashOffset =
        (Some v)
    } 
  let withStrokeOpacity v x =
    {
      x with
      strokeOpacity = (Some v)
    } 
  let withStrokeWidth v x =
    {
      x with
      strokeWidth = (Some v)
    } 
  let withTension v x =
    {
      x with
      tension = (Some v)
    } 
  let withText v x =
    { x with text = (Some v) } 
  let withTheta v x =
    { x with theta = (Some v)
    } 
end and
AxisResolveMap:sig
 type nonrec t =
 {
 y:
ResolveMode.t
 option ;
 x:
ResolveMode.t
 option }
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
 val make
 :
 ?x:ResolveMode.t
 ->
 ?y:ResolveMode.t
 ->
 unit -> t
 val withX
 :
ResolveMode.t
 -> 
 t -> t
 val withY
 :
ResolveMode.t
 -> 
 t -> t
end =
struct
  type nonrec t =
    {
    y:
ResolveMode.t
        option
      ;
    x:
ResolveMode.t
        option
      }

  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  ->
            match v with
            | `Null ->
                false
            | _ -> true)
         [("x",
            (((function
               | 
None  ->
                `Null
               | 
Some v ->
                ((fun
                (x :
ResolveMode.t)
                 ->
                (ResolveMode.to_yojson
                x : Yojson.Safe.json)))
                v)) x.x));
         ("y",
           (((function
              | None  ->
                `Null
              | Some v ->
                ((fun
                (x :
ResolveMode.t)
                 ->
                (ResolveMode.to_yojson
                x : Yojson.Safe.json)))
v)) x.y))])                                                         
  let make ?x  ?y  () =
    { y; x } 
  let withX v x =
    { x with x = (Some v)
    } 
  let withY v x =
    { x with y = (Some v)
    } 
end and
AxisOrient:sig
                                                                    type t =
                                                                    [ `Top 
                                                                    | `Right 
                                                                    | `Left 
                                                                    | `Bottom ]
                                                                    val
                                                                    to_yojson
                                                                    :
                                                                    t ->
Yojson.Safe.json
end =
struct
  type t =
    [ `Top 
    | `Right 
    | `Left 
    | `Bottom ]

  let to_yojson =
    function
    | `Bottom ->
        `String
          "bottom"
    | `Left ->
        `String
          "left"
    | `Right ->
        `String
          "right"
    | `Top ->
        `String
"top"                                                              
end and
AxisConfigMixins:
                                                              sig
  type nonrec t =
    {
    axisY:
VgAxisConfig.t
      option ;
    axisX:
VgAxisConfig.t
      option ;
    axisTop:
VgAxisConfig.t
      option ;
    axisRight:
VgAxisConfig.t
      option ;
    axisLeft:
VgAxisConfig.t
      option ;
    axisBottom:
VgAxisConfig.t
      option ;
    axisBand:
VgAxisConfig.t
      option ;
    axis:
AxisConfig.t
      option }
  val to_yojson
    :
    t ->
Yojson.Safe.json
  val make :
    ?axis:AxisConfig.t
      ->
      ?axisBand:VgAxisConfig.t
      ->
      ?axisBottom:VgAxisConfig.t
      ->
      ?axisLeft:VgAxisConfig.t
      ->
      ?axisRight:VgAxisConfig.t
      ->
      ?axisTop:VgAxisConfig.t
      ->
      ?axisX:VgAxisConfig.t
      ->
      ?axisY:VgAxisConfig.t
      ->
      unit -> t
  val withAxis
    :
AxisConfig.t
      -> 
      t -> t
  val
    withAxisBand
    :
VgAxisConfig.t
      -> 
      t -> t
  val
    withAxisBottom
    :
VgAxisConfig.t
      -> 
      t -> t
  val
    withAxisLeft
    :
VgAxisConfig.t
      -> 
      t -> t
  val
    withAxisRight
    :
VgAxisConfig.t
      -> 
      t -> t
  val
    withAxisTop
    :
VgAxisConfig.t
      -> 
      t -> t
  val withAxisX
    :
VgAxisConfig.t
      -> 
      t -> t
  val withAxisY
    :
VgAxisConfig.t
      -> 
      t -> t
end =
struct
  type nonrec t =
    {
    axisY:
VgAxisConfig.t
      option ;
    axisX:
VgAxisConfig.t
      option ;
    axisTop:
VgAxisConfig.t
      option ;
    axisRight:
VgAxisConfig.t
      option ;
    axisLeft:
VgAxisConfig.t
      option ;
    axisBottom:
VgAxisConfig.t
      option ;
    axisBand:
VgAxisConfig.t
      option ;
    axis:
AxisConfig.t
      option }

  (** Fields
  
    axisY:
      Y-axis specific config.
  
    axisX:
      X-axis specific config.
  
    axisTop:
      Specific axis config for x-axis along the top edge of the chart.
  
    axisRight:
      Specific axis config for y-axis along the right edge of the chart.
  
    axisLeft:
      Specific axis config for y-axis along the left edge of the chart.
  
    axisBottom:
      Specific axis config for x-axis along the bottom edge of the chart.
  
    axisBand:
      Specific axis config for axes with "band" scales.
  
    axis:
      Axis configuration, which determines default properties for all `x` and `y` [axes](axis.html). For a full list of axis configuration options, please see the [corresponding section of the axis documentation](axis.html#axis-config).
  *)
  let to_yojson
    x =
    `Assoc
      (
List.filter
      (fun
      (k,v)  ->
      match v
      with
      | 
      `Null ->
      false
      | 
      _ -> true)
      [
      ("axis",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
AxisConfig.t)
       ->
      (AxisConfig.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.axis));
      ("axisBand",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
VgAxisConfig.t)
       ->
      (VgAxisConfig.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.axisBand));
      ("axisBottom",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
VgAxisConfig.t)
       ->
      (VgAxisConfig.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.axisBottom));
      ("axisLeft",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
VgAxisConfig.t)
       ->
      (VgAxisConfig.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.axisLeft));
      ("axisRight",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
VgAxisConfig.t)
       ->
      (VgAxisConfig.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.axisRight));
      ("axisTop",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
VgAxisConfig.t)
       ->
      (VgAxisConfig.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.axisTop));
      ("axisX",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
VgAxisConfig.t)
       ->
      (VgAxisConfig.to_yojson
      x : Yojson.Safe.json)))
      v))
      x.axisX));
      ("axisY",
      (((function
      | None 
      -> `Null
      | Some v
      ->
      ((fun
      (x :
VgAxisConfig.t)
       ->
      (VgAxisConfig.to_yojson
      x : Yojson.Safe.json)))
      v))
x.axisY))])                                                                   
  let make
    ?axis 
    ?axisBand 
    ?axisBottom
     ?axisLeft 
    ?axisRight 
    ?axisTop 
    ?axisX 
    ?axisY  ()
    =
    {
      axisY;
      axisX;
      axisTop;
      axisRight;
      axisLeft;
      axisBottom;
      axisBand;
      axis
    } 
  let withAxis
    v x =
    {
      x with
      axis =
      (Some v)
    } 
  let withAxisBand
    v x =
    {
      x with
      axisBand
      =
      (Some v)
    } 
  let withAxisBottom
    v x =
    {
      x with
      axisBottom
      =
      (Some v)
    } 
  let withAxisLeft
    v x =
    {
      x with
      axisLeft
      =
      (Some v)
    } 
  let withAxisRight
    v x =
    {
      x with
      axisRight
      =
      (Some v)
    } 
  let withAxisTop
    v x =
    {
      x with
      axisTop =
      (Some v)
    } 
  let withAxisX
    v x =
    {
      x with
      axisX =
      (Some v)
    } 
  let withAxisY
    v x =
    {
      x with
      axisY =
      (Some v)
    } 
end and
AxisConfig:
                                                                   sig
 type nonrec t =
 {
 titleY:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleX:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titlePadding:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleMaxLength:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleLimit:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleFontWeight:
 [
 `Float of
 float 
 | `Int of
 int 
 | `String
 of string ]
 option ;
 titleFontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleFont:
 string
 option ;
 titleColor:
 string
 option ;
 titleBaseline:
 string
 option ;
 titleAngle:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleAlign:
 string
 option ;
 ticks:
 bool
 option ;
 tickWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 tickSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 tickRound:
 bool
 option ;
 tickColor:
 string
 option ;
 shortTimeLabels:
 bool
 option ;
 minExtent:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 maxExtent:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labels:
 bool
 option ;
 labelPadding:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labelOverlap:
 [
 `Greedy 
 | `Parity 
 | `Bool
 of bool ]
 option ;
 labelLimit:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labelFontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labelFont:
 string
 option ;
 labelColor:
 string
 option ;
 labelAngle:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 gridWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 gridOpacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 gridDash:
 [
 `Int of
 int 
 | `Float
 of float ]
 list
 option ;
 gridColor:
 string
 option ;
 grid:
 bool
 option ;
 domainWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 domainColor:
 string
 option ;
 domain:
 bool
 option ;
 bandPosition:
 [
 `Int of
 int 
 | `Float
 of float ]
 option }
 val
 to_yojson
 :
 t ->
Yojson.Safe.json
 val make
 :
 ?bandPosition:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?domain:bool
 ->
 ?domainColor:string
 ->
 ?domainWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?grid:bool
 ->
 ?gridColor:string
 ->
 ?gridDash:
 [
 `Int of
 int 
 | `Float
 of float ]
 list ->
 ?gridOpacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?gridWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?labelAngle:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?labelColor:string
 ->
 ?labelFont:string
 ->
 ?labelFontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?labelLimit:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?labelOverlap:
 [
 `Greedy 
 | `Parity 
 | `Bool
 of bool ]
 ->
 ?labelPadding:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?labels:bool
 ->
 ?maxExtent:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?minExtent:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?shortTimeLabels:bool
 ->
 ?tickColor:string
 ->
 ?tickRound:bool
 ->
 ?tickSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?tickWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?ticks:bool
 ->
 ?titleAlign:string
 ->
 ?titleAngle:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?titleBaseline:string
 ->
 ?titleColor:string
 ->
 ?titleFont:string
 ->
 ?titleFontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?titleFontWeight:
 [
 `Float of
 float 
 | `Int of
 int 
 | `String
 of string ]
 ->
 ?titleLimit:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?titleMaxLength:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?titlePadding:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?titleX:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 ?titleY:
 [
 `Int of
 int 
 | `Float
 of float ]
 ->
 unit -> t
 val
 withBandPosition
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withDomain
 :
 bool ->
 t -> t
 val
 withDomainColor
 :
 string ->
 t -> t
 val
 withDomainWidth
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withGrid
 :
 bool ->
 t -> t
 val
 withGridColor
 :
 string ->
 t -> t
 val
 withGridDash
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 list ->
 t -> t
 val
 withGridOpacity
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withGridWidth
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withLabelAngle
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withLabelColor
 :
 string ->
 t -> t
 val
 withLabelFont
 :
 string ->
 t -> t
 val
 withLabelFontSize
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withLabelLimit
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withLabelOverlap
 :
 [
 `Greedy 
 | `Parity 
 | `Bool
 of bool ]
 -> 
 t -> t
 val
 withLabelPadding
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withLabels
 :
 bool ->
 t -> t
 val
 withMaxExtent
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withMinExtent
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withShortTimeLabels
 :
 bool ->
 t -> t
 val
 withTickColor
 :
 string ->
 t -> t
 val
 withTickRound
 :
 bool ->
 t -> t
 val
 withTickSize
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTickWidth
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTicks
 :
 bool ->
 t -> t
 val
 withTitleAlign
 :
 string ->
 t -> t
 val
 withTitleAngle
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTitleBaseline
 :
 string ->
 t -> t
 val
 withTitleColor
 :
 string ->
 t -> t
 val
 withTitleFont
 :
 string ->
 t -> t
 val
 withTitleFontSize
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTitleFontWeight
 :
 [
 `Float of
 float 
 | `Int of
 int 
 | `String
 of string ]
 -> 
 t -> t
 val
 withTitleLimit
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTitleMaxLength
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTitlePadding
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTitleX
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
 val
 withTitleY
 :
 [
 `Int of
 int 
 | `Float
 of float ]
 -> 
 t -> t
end =
struct
 type nonrec t =
 {
 titleY:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleX:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titlePadding:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleMaxLength:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleLimit:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleFontWeight:
 [
 `Float of
 float 
 | `Int of
 int 
 | `String
 of string ]
 option ;
 titleFontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleFont:
 string
 option ;
 titleColor:
 string
 option ;
 titleBaseline:
 string
 option ;
 titleAngle:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 titleAlign:
 string
 option ;
 ticks:
 bool
 option ;
 tickWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 tickSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 tickRound:
 bool
 option ;
 tickColor:
 string
 option ;
 shortTimeLabels:
 bool
 option ;
 minExtent:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 maxExtent:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labels:
 bool
 option ;
 labelPadding:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labelOverlap:
 [
 `Greedy 
 | `Parity 
 | `Bool
 of bool ]
 option ;
 labelLimit:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labelFontSize:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 labelFont:
 string
 option ;
 labelColor:
 string
 option ;
 labelAngle:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 gridWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 gridOpacity:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 gridDash:
 [
 `Int of
 int 
 | `Float
 of float ]
 list
 option ;
 gridColor:
 string
 option ;
 grid:
 bool
 option ;
 domainWidth:
 [
 `Int of
 int 
 | `Float
 of float ]
 option ;
 domainColor:
 string
 option ;
 domain:
 bool
 option ;
 bandPosition:
 [
 `Int of
 int 
 | `Float
 of float ]
 option }

  (** Fields
  
    titleY:
      Y-coordinate of the axis title relative to the axis group.
  
    titleX:
      X-coordinate of the axis title relative to the axis group.
  
    titlePadding:
      The padding, in pixels, between title and axis.
  
    titleMaxLength:
      Max length for axis title if the title is automatically generated from the field's description.
  
    titleLimit:
      Maximum allowed pixel width of axis titles.
  
    titleFontWeight:
      Font weight of the title. (e.g., `"bold"`).
  
    titleFontSize:
      Font size of the title.
  
    titleFont:
      Font of the title. (e.g., `"Helvetica Neue"`).
  
    titleColor:
      Color of the title, can be in hex color code or regular color name.
  
    titleBaseline:
      Vertical text baseline for axis titles.
  
    titleAngle:
      Angle in degrees of axis titles.
  
    titleAlign:
      Horizontal text alignment of axis titles.
  
    ticks:
      Boolean value that determines whether the axis should include ticks.
  
    tickWidth:
      The width, in pixels, of ticks.
  
    tickSize:
      The size in pixels of axis ticks.
  
    tickRound:
      Boolean flag indicating if pixel position values should be rounded to the nearest integer.
  
    tickColor:
      The color of the axis's tick.
  
    shortTimeLabels:
      Whether month names and weekday names should be abbreviated.
      
      __Default value:__  `false`
  
    minExtent:
      The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.
      
      __Default value:__ `30` for y-axis; `undefined` for x-axis.
  
    maxExtent:
      The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.
      
      __Default value:__ `undefined`.
  
    labels:
      A boolean flag indicating if labels should be included as part of the axis.
      
      __Default value:__  `true`.
  
    labelPadding:
      The padding, in pixels, between axis and text labels.
  
    labelOverlap:
      The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).
      
      __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log scales; otherwise `false`.
  
    labelLimit:
      Maximum allowed pixel width of axis tick labels.
  
    labelFontSize:
      The font size of the label, in pixels.
  
    labelFont:
      The font of the tick label.
  
    labelColor:
      The color of the tick label, can be in hex color code or regular color name.
  
    labelAngle:
      The rotation angle of the axis labels.
      
      __Default value:__ `-90` for nominal, ordinal, temporal, and binned fields; `0` otherwise.
  
    gridWidth:
      The grid width, in pixels.
  
    gridOpacity:
      The stroke opacity of grid (value between [0,1])
      
      __Default value:__ (`1` by default)
  
    gridDash:
      The offset (in pixels) into which to begin drawing with the grid dash array.
  
    gridColor:
      Color of gridlines.
  
    grid:
      A boolean flag indicating if grid lines should be included as part of the axis
      
      __Default value:__ `true` for [continuous scales](scale.html#continuous) that are not binned; otherwise, `false`.
  
    domainWidth:
      Stroke width of axis domain line
      
      __Default value:__  (none, using Vega default).
  
    domainColor:
      Color of axis domain line.
      
      __Default value:__  (none, using Vega default).
  
    domain:
      A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis.
      
      __Default value:__ `true`
  
    bandPosition:
      An interpolation fraction indicating where, for `band` scales, axis ticks should be positioned. A value of `0` places ticks at the left edge of their bands. A value of `0.5` places ticks in the middle of their bands.
  *)
 let to_yojson
 x =
 `Assoc
 (List.filter
 (fun
 (k,v)  ->
 match v
 with
 | 
 `Null ->
 false
 | 
 _ -> true)
 [
 ("bandPosition",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.bandPosition));
 ("domain",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.domain));
 ("domainColor",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.domainColor));
 ("domainWidth",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.domainWidth));
 ("grid",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.grid));
 ("gridColor",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.gridColor));
 ("gridDash",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (l :
 [
 `Int of
 int 
 | `Float
 of float ]
 list)  ->
 let yojson_of_el
 =
 function
 | 
 `Int i ->
 `Int i
 | 
 `Float f
 ->
 `Float f
  in
 (`List
 (List.map
 yojson_of_el
 l) : 
Yojson.Safe.json)))
 v))
 x.gridDash));
 ("gridOpacity",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.gridOpacity));
 ("gridWidth",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.gridWidth));
 ("labelAngle",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.labelAngle));
 ("labelColor",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.labelColor));
 ("labelFont",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.labelFont));
 ("labelFontSize",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.labelFontSize));
 ("labelLimit",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.labelLimit));
 ("labelOverlap",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Bool v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v
 | `Parity
 ->
 `String
 "parity"
 | `Greedy
 ->
 `String
 "greedy"))
 v))
 x.labelOverlap));
 ("labelPadding",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.labelPadding));
 ("labels",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.labels));
 ("maxExtent",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.maxExtent));
 ("minExtent",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.minExtent));
 ("shortTimeLabels",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.shortTimeLabels));
 ("tickColor",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.tickColor));
 ("tickRound",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.tickRound));
 ("tickSize",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.tickSize));
 ("tickWidth",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.tickWidth));
 ("ticks",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (b :
 bool)  ->
 (`Bool b : 
Yojson.Safe.json)))
 v))
 x.ticks));
 ("titleAlign",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.titleAlign));
 ("titleAngle",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.titleAngle));
 ("titleBaseline",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.titleBaseline));
 ("titleColor",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.titleColor));
 ("titleFont",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v))
 x.titleFont));
 ("titleFontSize",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.titleFontSize));
 ("titleFontWeight",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `String
 v ->
 ((fun
 (s :
 string) 
 ->
 (`String
 s : Yojson.Safe.json)))
 v
 | `Int v
 ->
 ((fun
 (i : int)
  ->
 (`Int i : 
Yojson.Safe.json)))
 v
 | `Float
 v ->
 ((fun
 (f :
 float) 
 ->
 (`Float f : 
Yojson.Safe.json)))
 v)) v))
 x.titleFontWeight));
 ("titleLimit",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.titleLimit));
 ("titleMaxLength",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.titleMaxLength));
 ("titlePadding",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.titlePadding));
 ("titleX",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
 x.titleX));
 ("titleY",
 (((function
 | None 
 -> `Null
 | Some v
 ->
 ((function
 | `Int i
 -> `Int i
 | `Float
 f ->
 `Float f))
 v))
x.titleY))])                                                                     
 let make
 ?bandPosition
  ?domain 
 ?domainColor
  ?domainWidth
  ?grid 
 ?gridColor
  ?gridDash
  ?gridOpacity
  ?gridWidth
  ?labelAngle
  ?labelColor
  ?labelFont
  ?labelFontSize
  ?labelLimit
  ?labelOverlap
  ?labelPadding
  ?labels 
 ?maxExtent
  ?minExtent
  ?shortTimeLabels
  ?tickColor
  ?tickRound
  ?tickSize
  ?tickWidth
  ?ticks 
 ?titleAlign
  ?titleAngle
  ?titleBaseline
  ?titleColor
  ?titleFont
  ?titleFontSize
  ?titleFontWeight
  ?titleLimit
  ?titleMaxLength
  ?titlePadding
  ?titleX 
 ?titleY 
 () =
 {
 titleY;
 titleX;
 titlePadding;
 titleMaxLength;
 titleLimit;
 titleFontWeight;
 titleFontSize;
 titleFont;
 titleColor;
 titleBaseline;
 titleAngle;
 titleAlign;
 ticks;
 tickWidth;
 tickSize;
 tickRound;
 tickColor;
 shortTimeLabels;
 minExtent;
 maxExtent;
 labels;
 labelPadding;
 labelOverlap;
 labelLimit;
 labelFontSize;
 labelFont;
 labelColor;
 labelAngle;
 gridWidth;
 gridOpacity;
 gridDash;
 gridColor;
 grid;
 domainWidth;
 domainColor;
 domain;
 bandPosition
 } 
 let withBandPosition
 v x =
 {
 x with
 bandPosition
 =
 (Some v)
 } 
 let withDomain
 v x =
 {
 x with
 domain =
 (Some v)
 } 
 let withDomainColor
 v x =
 {
 x with
 domainColor
 =
 (Some v)
 } 
 let withDomainWidth
 v x =
 {
 x with
 domainWidth
 =
 (Some v)
 } 
 let withGrid
 v x =
 {
 x with
 grid =
 (Some v)
 } 
 let withGridColor
 v x =
 {
 x with
 gridColor
 =
 (Some v)
 } 
 let withGridDash
 v x =
 {
 x with
 gridDash
 =
 (Some v)
 } 
 let withGridOpacity
 v x =
 {
 x with
 gridOpacity
 =
 (Some v)
 } 
 let withGridWidth
 v x =
 {
 x with
 gridWidth
 =
 (Some v)
 } 
 let withLabelAngle
 v x =
 {
 x with
 labelAngle
 =
 (Some v)
 } 
 let withLabelColor
 v x =
 {
 x with
 labelColor
 =
 (Some v)
 } 
 let withLabelFont
 v x =
 {
 x with
 labelFont
 =
 (Some v)
 } 
 let withLabelFontSize
 v x =
 {
 x with
 labelFontSize
 =
 (Some v)
 } 
 let withLabelLimit
 v x =
 {
 x with
 labelLimit
 =
 (Some v)
 } 
 let withLabelOverlap
 v x =
 {
 x with
 labelOverlap
 =
 (Some v)
 } 
 let withLabelPadding
 v x =
 {
 x with
 labelPadding
 =
 (Some v)
 } 
 let withLabels
 v x =
 {
 x with
 labels =
 (Some v)
 } 
 let withMaxExtent
 v x =
 {
 x with
 maxExtent
 =
 (Some v)
 } 
 let withMinExtent
 v x =
 {
 x with
 minExtent
 =
 (Some v)
 } 
 let withShortTimeLabels
 v x =
 {
 x with
 shortTimeLabels
 =
 (Some v)
 } 
 let withTickColor
 v x =
 {
 x with
 tickColor
 =
 (Some v)
 } 
 let withTickRound
 v x =
 {
 x with
 tickRound
 =
 (Some v)
 } 
 let withTickSize
 v x =
 {
 x with
 tickSize
 =
 (Some v)
 } 
 let withTickWidth
 v x =
 {
 x with
 tickWidth
 =
 (Some v)
 } 
 let withTicks
 v x =
 {
 x with
 ticks =
 (Some v)
 } 
 let withTitleAlign
 v x =
 {
 x with
 titleAlign
 =
 (Some v)
 } 
 let withTitleAngle
 v x =
 {
 x with
 titleAngle
 =
 (Some v)
 } 
 let withTitleBaseline
 v x =
 {
 x with
 titleBaseline
 =
 (Some v)
 } 
 let withTitleColor
 v x =
 {
 x with
 titleColor
 =
 (Some v)
 } 
 let withTitleFont
 v x =
 {
 x with
 titleFont
 =
 (Some v)
 } 
 let withTitleFontSize
 v x =
 {
 x with
 titleFontSize
 =
 (Some v)
 } 
 let withTitleFontWeight
 v x =
 {
 x with
 titleFontWeight
 =
 (Some v)
 } 
 let withTitleLimit
 v x =
 {
 x with
 titleLimit
 =
 (Some v)
 } 
 let withTitleMaxLength
 v x =
 {
 x with
 titleMaxLength
 =
 (Some v)
 } 
 let withTitlePadding
 v x =
 {
 x with
 titlePadding
 =
 (Some v)
 } 
 let withTitleX
 v x =
 {
 x with
 titleX =
 (Some v)
 } 
 let withTitleY
 v x =
 {
 x with
 titleY =
 (Some v)
 } 
end
and
Axis:sig
  type nonrec t =
    {
    zindex: [ `Int of int  | `Float of float ] option ;
    values:
      [ `Nums of [ `Int of int  | `Float of float ] list 
      | `DateTimes of DateTime.t list ] option ;
    titlePadding: [ `Int of int  | `Float of float ] option ;
    titleMaxLength: [ `Int of int  | `Float of float ] option ;
    titleAngle: [ `Int of int  | `Float of float ] option ;
    titleAlign: string option ;
    title: string option ;
    ticks: bool option ;
    tickSize: [ `Int of int  | `Float of float ] option ;
    tickCount: [ `Int of int  | `Float of float ] option ;
    position: [ `Int of int  | `Float of float ] option ;
    orient: AxisOrient.t option ;
    offset: [ `Int of int  | `Float of float ] option ;
    minExtent: [ `Int of int  | `Float of float ] option ;
    maxExtent: [ `Int of int  | `Float of float ] option ;
    labels: bool option ;
    labelPadding: [ `Int of int  | `Float of float ] option ;
    labelOverlap: [ `Greedy  | `Parity  | `Bool of bool ] option ;
    labelAngle: [ `Int of int  | `Float of float ] option ;
    grid: bool option ;
    format: string option ;
    domain: bool option }
  val to_yojson : t -> Yojson.Safe.json
  val make :
    ?domain:bool ->
      ?format:string ->
        ?grid:bool ->
          ?labelAngle:[ `Int of int  | `Float of float ] ->
            ?labelOverlap:[ `Greedy  | `Parity  | `Bool of bool ] ->
              ?labelPadding:[ `Int of int  | `Float of float ] ->
                ?labels:bool ->
                  ?maxExtent:[ `Int of int  | `Float of float ] ->
                    ?minExtent:[ `Int of int  | `Float of float ] ->
                      ?offset:[ `Int of int  | `Float of float ] ->
                        ?orient:AxisOrient.t ->
                          ?position:[ `Int of int  | `Float of float ]
                            ->
                            ?tickCount:[ `Int of int 
                                       | `Float of float ]
                              ->
                              ?tickSize:[ `Int of int 
                                        | `Float of float ]
                                ->
                                ?ticks:bool ->
                                  ?title:string ->
                                    ?titleAlign:string ->
                                      ?titleAngle:[ `Int of int 
                                                  | `Float of float ]
                                        ->
                                        ?titleMaxLength:[ `Int of int 
                                                        | `Float of
                                                            float ]
                                          ->
                                          ?titlePadding:[ `Int of int 
                                                        | `Float of
                                                            float ]
                                            ->
                                            ?values:[
                                                      `Nums of
                                                        [ `Int of int 
                                                        | `Float of
                                                            float ]
                                                          list
                                                         | `DateTimes
                                                             of
DateTime.t
                                                             list ]
                                              ->
                                              ?zindex:[ `Int of int 
                                                      | `Float of
                                                          float ]
                                                -> unit -> t
  val withDomain : bool -> t -> t
  val withFormat : string -> t -> t
  val withGrid : bool -> t -> t
  val withLabelAngle : [ `Int of int  | `Float of float ] -> t -> t
  val withLabelOverlap :
    [ `Greedy  | `Parity  | `Bool of bool ] -> t -> t
  val withLabelPadding : [ `Int of int  | `Float of float ] -> t -> t
  val withLabels : bool -> t -> t
  val withMaxExtent : [ `Int of int  | `Float of float ] -> t -> t
  val withMinExtent : [ `Int of int  | `Float of float ] -> t -> t
  val withOffset : [ `Int of int  | `Float of float ] -> t -> t
  val withOrient : AxisOrient.t -> t -> t
  val withPosition : [ `Int of int  | `Float of float ] -> t -> t
  val withTickCount : [ `Int of int  | `Float of float ] -> t -> t
  val withTickSize : [ `Int of int  | `Float of float ] -> t -> t
  val withTicks : bool -> t -> t
  val withTitle : string -> t -> t
  val withTitleAlign : string -> t -> t
  val withTitleAngle : [ `Int of int  | `Float of float ] -> t -> t
  val withTitleMaxLength :
    [ `Int of int  | `Float of float ] -> t -> t
  val withTitlePadding : [ `Int of int  | `Float of float ] -> t -> t
  val withValues :
    [ `Nums of [ `Int of int  | `Float of float ] list 
    | `DateTimes of DateTime.t list ] -> t -> t
  val withZindex : [ `Int of int  | `Float of float ] -> t -> t
end =
struct
  type nonrec t =
    {
    zindex: [ `Int of int  | `Float of float ] option ;
    values:
      [ `Nums of [ `Int of int  | `Float of float ] list 
      | `DateTimes of DateTime.t list ] option ;
    titlePadding: [ `Int of int  | `Float of float ] option ;
    titleMaxLength: [ `Int of int  | `Float of float ] option ;
    titleAngle: [ `Int of int  | `Float of float ] option ;
    titleAlign: string option ;
    title: string option ;
    ticks: bool option ;
    tickSize: [ `Int of int  | `Float of float ] option ;
    tickCount: [ `Int of int  | `Float of float ] option ;
    position: [ `Int of int  | `Float of float ] option ;
    orient: AxisOrient.t option ;
    offset: [ `Int of int  | `Float of float ] option ;
    minExtent: [ `Int of int  | `Float of float ] option ;
    maxExtent: [ `Int of int  | `Float of float ] option ;
    labels: bool option ;
    labelPadding: [ `Int of int  | `Float of float ] option ;
    labelOverlap: [ `Greedy  | `Parity  | `Bool of bool ] option ;
    labelAngle: [ `Int of int  | `Float of float ] option ;
    grid: bool option ;
    format: string option ;
    domain: bool option }

  (** Fields
  
    zindex:
      A non-positive integer indicating z-index of the axis.
      If zindex is 0, axes should be drawn behind all chart elements.
      To put them in front, use `"zindex = 1"`.
      
      __Default value:__ `1` (in front of the marks) for actual axis and `0` (behind the marks) for grids.
  
    values:
      Explicitly set the visible axis tick values.
  
    titlePadding:
      The padding, in pixels, between title and axis.
  
    titleMaxLength:
      Max length for axis title if the title is automatically generated from the field's description.
  
    titleAngle:
      Angle in degrees of axis titles.
  
    titleAlign:
      Horizontal text alignment of axis titles.
  
    title:
      A title for the field.
      
      __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`).  If the field has a function, the function is displayed as an all capped text with parentheses wrapping the field name (e.g., `"SUM(field_name)"`, `"BIN(field_name)"`, `"YEAR(field_name)"`).  Otherwise, the title is simply the field name.
  
    ticks:
      Boolean value that determines whether the axis should include ticks.
  
    tickSize:
      The size in pixels of axis ticks.
  
    tickCount:
      A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are "nice" (multiples of 2, 5, 10) and lie within the underlying scale's range.
  
    position:
      The anchor position of the axis in pixels. For x-axis with top or bottom orientation, this sets the axis group x coordinate. For y-axis with left or right orientation, this sets the axis group y coordinate.
      
      __Default value__: `0`
  
    orient:
      The orientation of the axis. One of `"top"`, `"bottom"`, `"left"` or `"right"`. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).
      
      __Default value:__ `"bottom"` for x-axes and `"left"` for y-axes.
  
    offset:
      The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.
      
      __Default value:__ derived from the [axis config](config.html#facet-scale-config)'s `offset` (`0` by default)
  
    minExtent:
      The minimum extent in pixels that axis ticks and labels should use. This determines a minimum offset value for axis titles.
      
      __Default value:__ `30` for y-axis; `undefined` for x-axis.
  
    maxExtent:
      The maximum extent in pixels that axis ticks and labels should use. This determines a maximum offset value for axis titles.
      
      __Default value:__ `undefined`.
  
    labels:
      A boolean flag indicating if labels should be included as part of the axis.
      
      __Default value:__  `true`.
  
    labelPadding:
      The padding, in pixels, between axis and text labels.
  
    labelOverlap:
      The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `"parity"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `"greedy"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).
      
      __Default value:__ `true` for non-nominal fields with non-log scales; `"greedy"` for log scales; otherwise `false`.
  
    labelAngle:
      The rotation angle of the axis labels.
      
      __Default value:__ `-90` for nominal, ordinal, temporal, and binned fields; `0` otherwise.
  
    grid:
      A boolean flag indicating if grid lines should be included as part of the axis
      
      __Default value:__ `true` for [continuous scales](scale.html#continuous) that are not binned; otherwise, `false`.
  
    format:
      The formatting pattern for labels. This is D3's [number format pattern](https://github.com/d3/d3-format#locale_format) for quantitative fields and D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format) for time field.
      
      See the [format documentation](format.html) for more information.
      
      __Default value:__  derived from [numberFormat](config.html#format) config for quantitative fields and from [timeFormat](config.html#format) config for temporal fields.
  
    domain:
      A boolean flag indicating if the domain (the axis baseline) should be included as part of the axis.
      
      __Default value:__ `true`
  *)
  let to_yojson x =
    `Assoc
      (List.filter
         (fun (k,v)  -> match v with | `Null -> false | _ -> true)
         [("domain",
            (((function
               | None  -> `Null
               | Some v ->
                   ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) v))
               x.domain));
         ("format",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  -> (`String s : Yojson.Safe.json))) v))
              x.format));
         ("grid",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) v))
              x.grid));
         ("labelAngle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.labelAngle));
         ("labelOverlap",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `Bool v ->
                        ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json)))
                          v
                    | `Parity -> `String "parity"
                    | `Greedy -> `String "greedy")) v)) x.labelOverlap));
         ("labelPadding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.labelPadding));
         ("labels",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) v))
              x.labels));
         ("maxExtent",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.maxExtent));
         ("minExtent",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.minExtent));
         ("offset",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.offset));
         ("orient",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (x : AxisOrient.t)  ->
                      (AxisOrient.to_yojson x : Yojson.Safe.json))) v))
              x.orient));
         ("position",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.position));
         ("tickCount",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.tickCount));
         ("tickSize",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.tickSize));
         ("ticks",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (b : bool)  -> (`Bool b : Yojson.Safe.json))) v))
              x.ticks));
         ("title",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  -> (`String s : Yojson.Safe.json))) v))
              x.title));
         ("titleAlign",
           (((function
              | None  -> `Null
              | Some v ->
                  ((fun (s : string)  -> (`String s : Yojson.Safe.json))) v))
              x.titleAlign));
         ("titleAngle",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.titleAngle));
         ("titleMaxLength",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.titleMaxLength));
         ("titlePadding",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
              x.titlePadding));
         ("values",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function
                    | `DateTimes v ->
                        ((fun (l : DateTime.t list)  ->
                            let yojson_of_el (x : DateTime.t) =
                              (DateTime.to_yojson x : Yojson.Safe.json)  in
                            (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
                          v
                    | `Nums v ->
                        ((fun (l : [ `Int of int  | `Float of float ] list)
                             ->
                            let yojson_of_el =
                              function
                              | `Int i -> `Int i
                              | `Float f -> `Float f  in
                            (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
                          v)) v)) x.values));
         ("zindex",
           (((function
              | None  -> `Null
              | Some v ->
                  ((function | `Int i -> `Int i | `Float f -> `Float f)) v))
x.zindex))])       
  let make ?domain  ?format  ?grid  ?labelAngle  ?labelOverlap 
    ?labelPadding  ?labels  ?maxExtent  ?minExtent  ?offset  ?orient 
    ?position  ?tickCount  ?tickSize  ?ticks  ?title  ?titleAlign 
    ?titleAngle  ?titleMaxLength  ?titlePadding  ?values  ?zindex  () =
    {
      zindex;
      values;
      titlePadding;
      titleMaxLength;
      titleAngle;
      titleAlign;
      title;
      ticks;
      tickSize;
      tickCount;
      position;
      orient;
      offset;
      minExtent;
      maxExtent;
      labels;
      labelPadding;
      labelOverlap;
      labelAngle;
      grid;
      format;
      domain
    } 
  let withDomain v x = { x with domain = (Some v) } 
  let withFormat v x = { x with format = (Some v) } 
  let withGrid v x = { x with grid = (Some v) } 
  let withLabelAngle v x = { x with labelAngle = (Some v) } 
  let withLabelOverlap v x = { x with labelOverlap = (Some v) } 
  let withLabelPadding v x = { x with labelPadding = (Some v) } 
  let withLabels v x = { x with labels = (Some v) } 
  let withMaxExtent v x = { x with maxExtent = (Some v) } 
  let withMinExtent v x = { x with minExtent = (Some v) } 
  let withOffset v x = { x with offset = (Some v) } 
  let withOrient v x = { x with orient = (Some v) } 
  let withPosition v x = { x with position = (Some v) } 
  let withTickCount v x = { x with tickCount = (Some v) } 
  let withTickSize v x = { x with tickSize = (Some v) } 
  let withTicks v x = { x with ticks = (Some v) } 
  let withTitle v x = { x with title = (Some v) } 
  let withTitleAlign v x = { x with titleAlign = (Some v) } 
  let withTitleAngle v x = { x with titleAngle = (Some v) } 
  let withTitleMaxLength v x = { x with titleMaxLength = (Some v) } 
  let withTitlePadding v x = { x with titlePadding = (Some v) } 
  let withValues v x = { x with values = (Some v) } 
  let withZindex v x = { x with zindex = (Some v) } 
end and
AnyMark:sig
  type t = [ `Mark of Mark.t  | `MarkDef of MarkDef.t ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = [ `Mark of Mark.t  | `MarkDef of MarkDef.t ]

  let to_yojson =
    function
    | `MarkDef v ->
        ((fun (x : MarkDef.t)  ->
            (MarkDef.to_yojson x : Yojson.Safe.json))) v
    | `Mark v ->
        ((fun (x : Mark.t)  -> (Mark.to_yojson x : Yojson.Safe.json)))
v            
end and
AndFilter:sig
  type t = FilterOperand.t list
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = FilterOperand.t list

  let to_yojson x =
    `Assoc
      [("and",
         (((fun (l : FilterOperand.t list)  ->
              let yojson_of_el (x : FilterOperand.t) =
                (FilterOperand.to_yojson x : Yojson.Safe.json)
                 in
              (`List (List.map yojson_of_el l) : Yojson.Safe.json)))
x))]                 
end and
Anchor:sig
  type t = [ `Start  | `Middle  | `End ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = [ `Start  | `Middle  | `End ]

  let to_yojson =
    function
    | `End -> `String "end"
    | `Middle -> `String "middle"
    | `Start -> `String "start" 
end and
AggregateOp:sig
  type t =
    [ `Argmax  | `Argmin  | `Average 
    | `Count  | `Distinct  | `Max  | 
      `Mean 
    | `Median  | `Min  | `Missing  | 
      `Q1 
    | `Q3  | `Ci0  | `Ci1  | `Stdev 
    | `Stdevp  | `Sum  | `Valid  | 
      `Values 
    | `Variance  | `Variancep ]
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t =
    [ `Argmax  | `Argmin  | `Average  | `Count 
    | `Distinct  | `Max  | `Mean  | `Median  | 
      `Min 
    | `Missing  | `Q1  | `Q3  | `Ci0  | `Ci1  | 
      `Stdev 
    | `Stdevp  | `Sum  | `Valid  | `Values 
    | `Variance  | `Variancep ]

  let to_yojson =
    function
    | `Variancep -> `String "variancep"
    | `Variance -> `String "variance"
    | `Values -> `String "values"
    | `Valid -> `String "valid"
    | `Sum -> `String "sum"
    | `Stdevp -> `String "stdevp"
    | `Stdev -> `String "stdev"
    | `Ci1 -> `String "ci1"
    | `Ci0 -> `String "ci0"
    | `Q3 -> `String "q3"
    | `Q1 -> `String "q1"
    | `Missing -> `String "missing"
    | `Min -> `String "min"
    | `Median -> `String "median"
    | `Mean -> `String "mean"
    | `Max -> `String "max"
    | `Distinct -> `String "distinct"
    | `Count -> `String "count"
    | `Average -> `String "average"
    | `Argmin -> `String "argmin"
    | `Argmax -> `String "argmax" 
end and
Aggregate:sig
  type t = AggregateOp.t
  val to_yojson : t -> Yojson.Safe.json
end =
struct
  type t = AggregateOp.t

  let to_yojson (x : AggregateOp.t) =
    (AggregateOp.to_yojson x : Yojson.Safe.json) 
end
end
